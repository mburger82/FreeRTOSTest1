
FreeRTOSTest1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000037ae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00802000  000037ae  00003842  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000c99  0080200e  0080200e  00003850  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003850  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000038ac  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006f0  00000000  00000000  000038ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b369  00000000  00000000  00003fdc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000481d  00000000  00000000  0000f345  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000047f1  00000000  00000000  00013b62  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001928  00000000  00000000  00018354  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006005  00000000  00000000  00019c7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003400  00000000  00000000  0001fc81  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005f0  00000000  00000000  00023081  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 02 01 	jmp	0x204	; 0x204 <__ctors_end>
       4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
       8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
       c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      10:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      14:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      18:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      1c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      20:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      24:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      28:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      2c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      30:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      34:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      38:	0c 94 ee 09 	jmp	0x13dc	; 0x13dc <__vector_14>
      3c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      40:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      44:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      48:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      4c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      50:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      54:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      58:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      5c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      60:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      64:	0c 94 c1 02 	jmp	0x582	; 0x582 <__vector_25>
      68:	0c 94 f3 03 	jmp	0x7e6	; 0x7e6 <__vector_26>
      6c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      70:	0c 94 27 03 	jmp	0x64e	; 0x64e <__vector_28>
      74:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      78:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      7c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      80:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      84:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      88:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      8c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      90:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      94:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      98:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      9c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      a0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      a4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      a8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      ac:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      b0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      b4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      b8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      bc:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      c0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      c4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      c8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      cc:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      d0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      d4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      d8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      dc:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      e0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      e4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      e8:	0c 94 8d 03 	jmp	0x71a	; 0x71a <__vector_58>
      ec:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      f0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      f4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      f8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
      fc:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     100:	0c 94 58 17 	jmp	0x2eb0	; 0x2eb0 <__vector_64>
     104:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     108:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     10c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     110:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     114:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     118:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     11c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     120:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     124:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     128:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     12c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     130:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     134:	0c 94 f4 18 	jmp	0x31e8	; 0x31e8 <__vector_77>
     138:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     13c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     140:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     144:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     148:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     14c:	0c 94 22 19 	jmp	0x3244	; 0x3244 <__vector_83>
     150:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     154:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     158:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     15c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     160:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     164:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     168:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     16c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     170:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     174:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     178:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     17c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     180:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     184:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     188:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     18c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     190:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     194:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     198:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     19c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1a0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1a4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1a8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1ac:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1b0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1b4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1b8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1bc:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1c0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1c4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1c8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1cc:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1d0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1d4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1d8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1dc:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1e0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1e4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1e8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1ec:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1f0:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1f4:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>
     1f8:	0c 94 2c 01 	jmp	0x258	; 0x258 <__bad_interrupt>

000001fc <__trampolines_start>:
     1fc:	0c 94 a7 12 	jmp	0x254e	; 0x254e <prvIdleTask>
     200:	0c 94 7a 18 	jmp	0x30f4	; 0x30f4 <vLedBlink>

00000204 <__ctors_end>:
     204:	11 24       	eor	r1, r1
     206:	1f be       	out	0x3f, r1	; 63
     208:	cf ef       	ldi	r28, 0xFF	; 255
     20a:	cd bf       	out	0x3d, r28	; 61
     20c:	df e3       	ldi	r29, 0x3F	; 63
     20e:	de bf       	out	0x3e, r29	; 62
     210:	00 e0       	ldi	r16, 0x00	; 0
     212:	0c bf       	out	0x3c, r16	; 60

00000214 <init_mem>:
// !!! Never call this function, it is part of .init-Code
void __attribute__ ((naked, section(".init3"))) init_mem (void);
void init_mem (void)
{
   //  Use inline assembler so it works even with optimization turned off
   __asm volatile (
     214:	e7 ea       	ldi	r30, 0xA7	; 167
     216:	fc e2       	ldi	r31, 0x2C	; 44
     218:	8a ea       	ldi	r24, 0xAA	; 170
     21a:	90 e4       	ldi	r25, 0x40	; 64
     21c:	81 93       	st	Z+, r24
     21e:	e0 30       	cpi	r30, 0x00	; 0
     220:	f9 07       	cpc	r31, r25
     222:	e0 f3       	brcs	.-8      	; 0x21c <init_mem+0x8>
	...

00000226 <__do_copy_data>:
     226:	10 e2       	ldi	r17, 0x20	; 32
     228:	a0 e0       	ldi	r26, 0x00	; 0
     22a:	b0 e2       	ldi	r27, 0x20	; 32
     22c:	ee ea       	ldi	r30, 0xAE	; 174
     22e:	f7 e3       	ldi	r31, 0x37	; 55
     230:	00 e0       	ldi	r16, 0x00	; 0
     232:	0b bf       	out	0x3b, r16	; 59
     234:	02 c0       	rjmp	.+4      	; 0x23a <__do_copy_data+0x14>
     236:	07 90       	elpm	r0, Z+
     238:	0d 92       	st	X+, r0
     23a:	ae 30       	cpi	r26, 0x0E	; 14
     23c:	b1 07       	cpc	r27, r17
     23e:	d9 f7       	brne	.-10     	; 0x236 <__do_copy_data+0x10>

00000240 <__do_clear_bss>:
     240:	2c e2       	ldi	r18, 0x2C	; 44
     242:	ae e0       	ldi	r26, 0x0E	; 14
     244:	b0 e2       	ldi	r27, 0x20	; 32
     246:	01 c0       	rjmp	.+2      	; 0x24a <.do_clear_bss_start>

00000248 <.do_clear_bss_loop>:
     248:	1d 92       	st	X+, r1

0000024a <.do_clear_bss_start>:
     24a:	a7 3a       	cpi	r26, 0xA7	; 167
     24c:	b2 07       	cpc	r27, r18
     24e:	e1 f7       	brne	.-8      	; 0x248 <.do_clear_bss_loop>
     250:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <main>
     254:	0c 94 d5 1b 	jmp	0x37aa	; 0x37aa <_exit>

00000258 <__bad_interrupt>:
     258:	0c 94 59 04 	jmp	0x8b2	; 0x8b2 <__vector_default>

0000025c <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     25c:	0f 93       	push	r16
     25e:	cf 93       	push	r28
     260:	df 93       	push	r29
     262:	00 d0       	rcall	.+0      	; 0x264 <CCPWrite+0x8>
     264:	00 d0       	rcall	.+0      	; 0x266 <CCPWrite+0xa>
     266:	cd b7       	in	r28, 0x3d	; 61
     268:	de b7       	in	r29, 0x3e	; 62
     26a:	8c 83       	std	Y+4, r24	; 0x04
     26c:	9d 83       	std	Y+5, r25	; 0x05
     26e:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     270:	8f e3       	ldi	r24, 0x3F	; 63
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	fc 01       	movw	r30, r24
     276:	80 81       	ld	r24, Z
     278:	8b 83       	std	Y+3, r24	; 0x03
     27a:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
     27c:	8c 81       	ldd	r24, Y+4	; 0x04
     27e:	9d 81       	ldd	r25, Y+5	; 0x05
     280:	89 83       	std	Y+1, r24	; 0x01
     282:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
     284:	8b e3       	ldi	r24, 0x3B	; 59
     286:	90 e0       	ldi	r25, 0x00	; 0
     288:	fc 01       	movw	r30, r24
     28a:	10 82       	st	Z, r1
#endif
	asm volatile(
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	9a 81       	ldd	r25, Y+2	; 0x02
     290:	2e 81       	ldd	r18, Y+6	; 0x06
     292:	fc 01       	movw	r30, r24
     294:	08 ed       	ldi	r16, 0xD8	; 216
     296:	04 bf       	out	0x34, r16	; 52
     298:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     29a:	8f e3       	ldi	r24, 0x3F	; 63
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	2b 81       	ldd	r18, Y+3	; 0x03
     2a0:	fc 01       	movw	r30, r24
     2a2:	20 83       	st	Z, r18
#endif
}
     2a4:	00 00       	nop
     2a6:	26 96       	adiw	r28, 0x06	; 6
     2a8:	cd bf       	out	0x3d, r28	; 61
     2aa:	de bf       	out	0x3e, r29	; 62
     2ac:	df 91       	pop	r29
     2ae:	cf 91       	pop	r28
     2b0:	0f 91       	pop	r16
     2b2:	08 95       	ret

000002b4 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
     2b4:	cf 93       	push	r28
     2b6:	df 93       	push	r29
     2b8:	00 d0       	rcall	.+0      	; 0x2ba <CLKSYS_XOSC_Config+0x6>
     2ba:	cd b7       	in	r28, 0x3d	; 61
     2bc:	de b7       	in	r29, 0x3e	; 62
     2be:	89 83       	std	Y+1, r24	; 0x01
     2c0:	6a 83       	std	Y+2, r22	; 0x02
     2c2:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
     2c4:	80 e5       	ldi	r24, 0x50	; 80
     2c6:	90 e0       	ldi	r25, 0x00	; 0
     2c8:	2a 81       	ldd	r18, Y+2	; 0x02
     2ca:	22 23       	and	r18, r18
     2cc:	11 f0       	breq	.+4      	; 0x2d2 <CLKSYS_XOSC_Config+0x1e>
     2ce:	20 e2       	ldi	r18, 0x20	; 32
     2d0:	01 c0       	rjmp	.+2      	; 0x2d4 <CLKSYS_XOSC_Config+0x20>
     2d2:	20 e0       	ldi	r18, 0x00	; 0
     2d4:	39 81       	ldd	r19, Y+1	; 0x01
     2d6:	32 2b       	or	r19, r18
     2d8:	2b 81       	ldd	r18, Y+3	; 0x03
     2da:	23 2b       	or	r18, r19
     2dc:	fc 01       	movw	r30, r24
     2de:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
     2e0:	00 00       	nop
     2e2:	23 96       	adiw	r28, 0x03	; 3
     2e4:	cd bf       	out	0x3d, r28	; 61
     2e6:	de bf       	out	0x3e, r29	; 62
     2e8:	df 91       	pop	r29
     2ea:	cf 91       	pop	r28
     2ec:	08 95       	ret

000002ee <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
     2ee:	cf 93       	push	r28
     2f0:	df 93       	push	r29
     2f2:	1f 92       	push	r1
     2f4:	1f 92       	push	r1
     2f6:	cd b7       	in	r28, 0x3d	; 61
     2f8:	de b7       	in	r29, 0x3e	; 62
     2fa:	89 83       	std	Y+1, r24	; 0x01
     2fc:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
     2fe:	8a 81       	ldd	r24, Y+2	; 0x02
     300:	8f 71       	andi	r24, 0x1F	; 31
     302:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     304:	80 e5       	ldi	r24, 0x50	; 80
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	39 81       	ldd	r19, Y+1	; 0x01
     30a:	2a 81       	ldd	r18, Y+2	; 0x02
     30c:	23 2b       	or	r18, r19
     30e:	fc 01       	movw	r30, r24
     310:	25 83       	std	Z+5, r18	; 0x05
}
     312:	00 00       	nop
     314:	0f 90       	pop	r0
     316:	0f 90       	pop	r0
     318:	df 91       	pop	r29
     31a:	cf 91       	pop	r28
     31c:	08 95       	ret

0000031e <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
     31e:	cf 93       	push	r28
     320:	df 93       	push	r29
     322:	1f 92       	push	r1
     324:	1f 92       	push	r1
     326:	cd b7       	in	r28, 0x3d	; 61
     328:	de b7       	in	r29, 0x3e	; 62
     32a:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
     32c:	80 e5       	ldi	r24, 0x50	; 80
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	20 e5       	ldi	r18, 0x50	; 80
     332:	30 e0       	ldi	r19, 0x00	; 0
     334:	f9 01       	movw	r30, r18
     336:	20 81       	ld	r18, Z
     338:	32 2f       	mov	r19, r18
     33a:	2a 81       	ldd	r18, Y+2	; 0x02
     33c:	20 95       	com	r18
     33e:	23 23       	and	r18, r19
     340:	fc 01       	movw	r30, r24
     342:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     344:	80 e5       	ldi	r24, 0x50	; 80
     346:	90 e0       	ldi	r25, 0x00	; 0
     348:	fc 01       	movw	r30, r24
     34a:	90 81       	ld	r25, Z
     34c:	8a 81       	ldd	r24, Y+2	; 0x02
     34e:	89 23       	and	r24, r25
     350:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
     352:	89 81       	ldd	r24, Y+1	; 0x01
}
     354:	0f 90       	pop	r0
     356:	0f 90       	pop	r0
     358:	df 91       	pop	r29
     35a:	cf 91       	pop	r28
     35c:	08 95       	ret

0000035e <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
     35e:	cf 93       	push	r28
     360:	df 93       	push	r29
     362:	00 d0       	rcall	.+0      	; 0x364 <CLKSYS_Prescalers_Config+0x6>
     364:	cd b7       	in	r28, 0x3d	; 61
     366:	de b7       	in	r29, 0x3e	; 62
     368:	8a 83       	std	Y+2, r24	; 0x02
     36a:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
     36c:	9a 81       	ldd	r25, Y+2	; 0x02
     36e:	8b 81       	ldd	r24, Y+3	; 0x03
     370:	89 2b       	or	r24, r25
     372:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
     374:	69 81       	ldd	r22, Y+1	; 0x01
     376:	81 e4       	ldi	r24, 0x41	; 65
     378:	90 e0       	ldi	r25, 0x00	; 0
     37a:	0e 94 2e 01 	call	0x25c	; 0x25c <CCPWrite>
}
     37e:	00 00       	nop
     380:	23 96       	adiw	r28, 0x03	; 3
     382:	cd bf       	out	0x3d, r28	; 61
     384:	de bf       	out	0x3e, r29	; 62
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	08 95       	ret

0000038c <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     38c:	cf 93       	push	r28
     38e:	df 93       	push	r29
     390:	1f 92       	push	r1
     392:	1f 92       	push	r1
     394:	cd b7       	in	r28, 0x3d	; 61
     396:	de b7       	in	r29, 0x3e	; 62
     398:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     39a:	80 e4       	ldi	r24, 0x40	; 64
     39c:	90 e0       	ldi	r25, 0x00	; 0
     39e:	fc 01       	movw	r30, r24
     3a0:	80 81       	ld	r24, Z
     3a2:	98 2f       	mov	r25, r24
     3a4:	98 7f       	andi	r25, 0xF8	; 248
     3a6:	8a 81       	ldd	r24, Y+2	; 0x02
     3a8:	89 2b       	or	r24, r25
     3aa:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
     3ac:	69 81       	ldd	r22, Y+1	; 0x01
     3ae:	80 e4       	ldi	r24, 0x40	; 64
     3b0:	90 e0       	ldi	r25, 0x00	; 0
     3b2:	0e 94 2e 01 	call	0x25c	; 0x25c <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     3b6:	80 e4       	ldi	r24, 0x40	; 64
     3b8:	90 e0       	ldi	r25, 0x00	; 0
     3ba:	fc 01       	movw	r30, r24
     3bc:	90 81       	ld	r25, Z
     3be:	8a 81       	ldd	r24, Y+2	; 0x02
     3c0:	89 23       	and	r24, r25
     3c2:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
     3c4:	89 81       	ldd	r24, Y+1	; 0x01
}
     3c6:	0f 90       	pop	r0
     3c8:	0f 90       	pop	r0
     3ca:	df 91       	pop	r29
     3cc:	cf 91       	pop	r28
     3ce:	08 95       	ret

000003d0 <USART_InterruptDriver_Initialize>:
bool USART_RXBuffer_GetByte(USART_data_t * usart_data, uint8_t *data, portTickType xBlockTime)
{
	/* Get the next character from the buffer.  Return false if no characters
	 are available, or arrive before xBlockTime expires. */
	return xQueueReceive( usart_data->xRxQueue, data, xBlockTime );
}
     3d0:	0f 93       	push	r16
     3d2:	cf 93       	push	r28
     3d4:	df 93       	push	r29
     3d6:	cd b7       	in	r28, 0x3d	; 61
     3d8:	de b7       	in	r29, 0x3e	; 62
     3da:	27 97       	sbiw	r28, 0x07	; 7
     3dc:	cd bf       	out	0x3d, r28	; 61
     3de:	de bf       	out	0x3e, r29	; 62
     3e0:	89 83       	std	Y+1, r24	; 0x01
     3e2:	9a 83       	std	Y+2, r25	; 0x02
     3e4:	6b 83       	std	Y+3, r22	; 0x03
     3e6:	4c 83       	std	Y+4, r20	; 0x04
     3e8:	2d 83       	std	Y+5, r18	; 0x05
     3ea:	3e 83       	std	Y+6, r19	; 0x06
     3ec:	0f 83       	std	Y+7, r16	; 0x07
     3ee:	89 81       	ldd	r24, Y+1	; 0x01
     3f0:	9a 81       	ldd	r25, Y+2	; 0x02
     3f2:	2d 81       	ldd	r18, Y+5	; 0x05
     3f4:	3e 81       	ldd	r19, Y+6	; 0x06
     3f6:	fc 01       	movw	r30, r24
     3f8:	20 83       	st	Z, r18
     3fa:	31 83       	std	Z+1, r19	; 0x01
     3fc:	89 81       	ldd	r24, Y+1	; 0x01
     3fe:	9a 81       	ldd	r25, Y+2	; 0x02
     400:	2f 81       	ldd	r18, Y+7	; 0x07
     402:	fc 01       	movw	r30, r24
     404:	22 83       	std	Z+2, r18	; 0x02
     406:	8c 81       	ldd	r24, Y+4	; 0x04
     408:	88 23       	and	r24, r24
     40a:	19 f0       	breq	.+6      	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
     40c:	8c 81       	ldd	r24, Y+4	; 0x04
     40e:	81 30       	cpi	r24, 0x01	; 1
     410:	a9 f4       	brne	.+42     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
     412:	40 e0       	ldi	r20, 0x00	; 0
     414:	61 e0       	ldi	r22, 0x01	; 1
     416:	8b 81       	ldd	r24, Y+3	; 0x03
     418:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xQueueGenericCreate>
     41c:	9c 01       	movw	r18, r24
     41e:	89 81       	ldd	r24, Y+1	; 0x01
     420:	9a 81       	ldd	r25, Y+2	; 0x02
     422:	fc 01       	movw	r30, r24
     424:	23 83       	std	Z+3, r18	; 0x03
     426:	34 83       	std	Z+4, r19	; 0x04
     428:	89 81       	ldd	r24, Y+1	; 0x01
     42a:	9a 81       	ldd	r25, Y+2	; 0x02
     42c:	fc 01       	movw	r30, r24
     42e:	83 81       	ldd	r24, Z+3	; 0x03
     430:	94 81       	ldd	r25, Z+4	; 0x04
     432:	89 2b       	or	r24, r25
     434:	19 f4       	brne	.+6      	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
     436:	8a e2       	ldi	r24, 0x2A	; 42
     438:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
     43c:	8c 81       	ldd	r24, Y+4	; 0x04
     43e:	88 23       	and	r24, r24
     440:	19 f0       	breq	.+6      	; 0x448 <__LOCK_REGION_LENGTH__+0x48>
     442:	8c 81       	ldd	r24, Y+4	; 0x04
     444:	82 30       	cpi	r24, 0x02	; 2
     446:	a9 f4       	brne	.+42     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
     448:	40 e0       	ldi	r20, 0x00	; 0
     44a:	61 e0       	ldi	r22, 0x01	; 1
     44c:	8b 81       	ldd	r24, Y+3	; 0x03
     44e:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xQueueGenericCreate>
     452:	9c 01       	movw	r18, r24
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	9a 81       	ldd	r25, Y+2	; 0x02
     458:	fc 01       	movw	r30, r24
     45a:	25 83       	std	Z+5, r18	; 0x05
     45c:	36 83       	std	Z+6, r19	; 0x06
     45e:	89 81       	ldd	r24, Y+1	; 0x01
     460:	9a 81       	ldd	r25, Y+2	; 0x02
     462:	fc 01       	movw	r30, r24
     464:	85 81       	ldd	r24, Z+5	; 0x05
     466:	96 81       	ldd	r25, Z+6	; 0x06
     468:	89 2b       	or	r24, r25
     46a:	19 f4       	brne	.+6      	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
     46c:	8a e2       	ldi	r24, 0x2A	; 42
     46e:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
     472:	89 81       	ldd	r24, Y+1	; 0x01
     474:	9a 81       	ldd	r25, Y+2	; 0x02
     476:	07 96       	adiw	r24, 0x07	; 7
     478:	0e 94 a6 19 	call	0x334c	; 0x334c <sm_init>
     47c:	00 00       	nop
     47e:	27 96       	adiw	r28, 0x07	; 7
     480:	cd bf       	out	0x3d, r28	; 61
     482:	de bf       	out	0x3e, r29	; 62
     484:	df 91       	pop	r29
     486:	cf 91       	pop	r28
     488:	0f 91       	pop	r16
     48a:	08 95       	ret

0000048c <USART_RXComplete>:
	return xTaskWokenBySend; 
}
#endif

bool USART_RXComplete(USART_data_t * usart_data)
{
     48c:	cf 93       	push	r28
     48e:	df 93       	push	r29
     490:	00 d0       	rcall	.+0      	; 0x492 <USART_RXComplete+0x6>
     492:	1f 92       	push	r1
     494:	cd b7       	in	r28, 0x3d	; 61
     496:	de b7       	in	r29, 0x3e	; 62
     498:	8b 83       	std	Y+3, r24	; 0x03
     49a:	9c 83       	std	Y+4, r25	; 0x04
	signed char cChar;
	signed portBASE_TYPE xTaskWokenBySend = pdFALSE;
     49c:	1a 82       	std	Y+2, r1	; 0x02

	// Get the character and post it on the queue of Rxed characters.
	// If the post causes a task to wake force a context switch as the woken task
	// may have a higher priority than the task we have interrupted.
	//
	cChar = usart_data->usart->DATA;
     49e:	8b 81       	ldd	r24, Y+3	; 0x03
     4a0:	9c 81       	ldd	r25, Y+4	; 0x04
     4a2:	fc 01       	movw	r30, r24
     4a4:	80 81       	ld	r24, Z
     4a6:	91 81       	ldd	r25, Z+1	; 0x01
     4a8:	fc 01       	movw	r30, r24
     4aa:	80 81       	ld	r24, Z
     4ac:	89 83       	std	Y+1, r24	; 0x01
	if(xQueueSendFromISR( usart_data->xRxQueue, &cChar, &xTaskWokenBySend )!=pdTRUE)
     4ae:	8b 81       	ldd	r24, Y+3	; 0x03
     4b0:	9c 81       	ldd	r25, Y+4	; 0x04
     4b2:	fc 01       	movw	r30, r24
     4b4:	83 81       	ldd	r24, Z+3	; 0x03
     4b6:	94 81       	ldd	r25, Z+4	; 0x04
     4b8:	ae 01       	movw	r20, r28
     4ba:	4e 5f       	subi	r20, 0xFE	; 254
     4bc:	5f 4f       	sbci	r21, 0xFF	; 255
     4be:	20 e0       	ldi	r18, 0x00	; 0
     4c0:	be 01       	movw	r22, r28
     4c2:	6f 5f       	subi	r22, 0xFF	; 255
     4c4:	7f 4f       	sbci	r23, 0xFF	; 255
     4c6:	0e 94 af 0b 	call	0x175e	; 0x175e <xQueueGenericSendFromISR>
     4ca:	81 30       	cpi	r24, 0x01	; 1
     4cc:	19 f0       	breq	.+6      	; 0x4d4 <USART_RXComplete+0x48>
	{
		errorNonFatal(ERR_BYTE_LOST_ON_RECEIVE);
     4ce:	86 e3       	ldi	r24, 0x36	; 54
     4d0:	0e 94 8f 14 	call	0x291e	; 0x291e <errorNonFatal>
	}
	return xTaskWokenBySend; 
     4d4:	9a 81       	ldd	r25, Y+2	; 0x02
     4d6:	81 e0       	ldi	r24, 0x01	; 1
     4d8:	99 23       	and	r25, r25
     4da:	09 f4       	brne	.+2      	; 0x4de <USART_RXComplete+0x52>
     4dc:	80 e0       	ldi	r24, 0x00	; 0
}
     4de:	24 96       	adiw	r28, 0x04	; 4
     4e0:	cd bf       	out	0x3d, r28	; 61
     4e2:	de bf       	out	0x3e, r29	; 62
     4e4:	df 91       	pop	r29
     4e6:	cf 91       	pop	r28
     4e8:	08 95       	ret

000004ea <USART_DataRegEmpty>:
 *
 *  \param usart_data      The USART_data_t struct instance.
 */

bool USART_DataRegEmpty(USART_data_t * usart_data)
{
     4ea:	cf 93       	push	r28
     4ec:	df 93       	push	r29
     4ee:	00 d0       	rcall	.+0      	; 0x4f0 <USART_DataRegEmpty+0x6>
     4f0:	1f 92       	push	r1
     4f2:	cd b7       	in	r28, 0x3d	; 61
     4f4:	de b7       	in	r29, 0x3e	; 62
     4f6:	8b 83       	std	Y+3, r24	; 0x03
     4f8:	9c 83       	std	Y+4, r25	; 0x04
	char cChar;
	signed portBASE_TYPE xTaskWokenByReceive = pdFALSE;
     4fa:	1a 82       	std	Y+2, r1	; 0x02

	// Check if all data is transmitted.
	if (xQueueReceiveFromISR(usart_data->xTxQueue, &cChar, &xTaskWokenByReceive) == pdTRUE)
     4fc:	8b 81       	ldd	r24, Y+3	; 0x03
     4fe:	9c 81       	ldd	r25, Y+4	; 0x04
     500:	fc 01       	movw	r30, r24
     502:	85 81       	ldd	r24, Z+5	; 0x05
     504:	96 81       	ldd	r25, Z+6	; 0x06
     506:	9e 01       	movw	r18, r28
     508:	2e 5f       	subi	r18, 0xFE	; 254
     50a:	3f 4f       	sbci	r19, 0xFF	; 255
     50c:	a9 01       	movw	r20, r18
     50e:	9e 01       	movw	r18, r28
     510:	2f 5f       	subi	r18, 0xFF	; 255
     512:	3f 4f       	sbci	r19, 0xFF	; 255
     514:	b9 01       	movw	r22, r18
     516:	0e 94 0f 0c 	call	0x181e	; 0x181e <xQueueReceiveFromISR>
     51a:	81 30       	cpi	r24, 0x01	; 1
     51c:	c1 f4       	brne	.+48     	; 0x54e <USART_DataRegEmpty+0x64>
	{
		#if SERIAL_CHECK_SEND == 1
		if( !sm_setState(&(usart_data->sm), cChar) )
     51e:	29 81       	ldd	r18, Y+1	; 0x01
     520:	8b 81       	ldd	r24, Y+3	; 0x03
     522:	9c 81       	ldd	r25, Y+4	; 0x04
     524:	07 96       	adiw	r24, 0x07	; 7
     526:	62 2f       	mov	r22, r18
     528:	0e 94 b8 19 	call	0x3370	; 0x3370 <sm_setState>
     52c:	98 2f       	mov	r25, r24
     52e:	81 e0       	ldi	r24, 0x01	; 1
     530:	89 27       	eor	r24, r25
     532:	88 23       	and	r24, r24
     534:	19 f0       	breq	.+6      	; 0x53c <USART_DataRegEmpty+0x52>
				errorNonFatal(ERR_BYTE_LOST_ON_SEND);
     536:	85 e3       	ldi	r24, 0x35	; 53
     538:	0e 94 8f 14 	call	0x291e	; 0x291e <errorNonFatal>
		#endif

		// Start transmitting.
		//
		usart_data->usart->DATA = cChar;
     53c:	8b 81       	ldd	r24, Y+3	; 0x03
     53e:	9c 81       	ldd	r25, Y+4	; 0x04
     540:	fc 01       	movw	r30, r24
     542:	80 81       	ld	r24, Z
     544:	91 81       	ldd	r25, Z+1	; 0x01
     546:	29 81       	ldd	r18, Y+1	; 0x01
     548:	fc 01       	movw	r30, r24
     54a:	20 83       	st	Z, r18
     54c:	0f c0       	rjmp	.+30     	; 0x56c <USART_DataRegEmpty+0x82>
	}
	else
	{
		// Disable DRE interrupt

		USART_DreInterruptLevel_Set(usart_data->usart, USART_DREINTLVL_OFF_gc);
     54e:	8b 81       	ldd	r24, Y+3	; 0x03
     550:	9c 81       	ldd	r25, Y+4	; 0x04
     552:	fc 01       	movw	r30, r24
     554:	80 81       	ld	r24, Z
     556:	91 81       	ldd	r25, Z+1	; 0x01
     558:	2b 81       	ldd	r18, Y+3	; 0x03
     55a:	3c 81       	ldd	r19, Y+4	; 0x04
     55c:	f9 01       	movw	r30, r18
     55e:	20 81       	ld	r18, Z
     560:	31 81       	ldd	r19, Z+1	; 0x01
     562:	f9 01       	movw	r30, r18
     564:	23 81       	ldd	r18, Z+3	; 0x03
     566:	2c 7f       	andi	r18, 0xFC	; 252
     568:	fc 01       	movw	r30, r24
     56a:	23 83       	std	Z+3, r18	; 0x03
	}
	return xTaskWokenByReceive; 
     56c:	9a 81       	ldd	r25, Y+2	; 0x02
     56e:	81 e0       	ldi	r24, 0x01	; 1
     570:	99 23       	and	r25, r25
     572:	09 f4       	brne	.+2      	; 0x576 <USART_DataRegEmpty+0x8c>
     574:	80 e0       	ldi	r24, 0x00	; 0
}
     576:	24 96       	adiw	r28, 0x04	; 4
     578:	cd bf       	out	0x3d, r28	; 61
     57a:	de bf       	out	0x3e, r29	; 62
     57c:	df 91       	pop	r29
     57e:	cf 91       	pop	r28
     580:	08 95       	ret

00000582 <__vector_25>:
 *  as argument.
 */

ISR(USARTC0_RXC_vect, ISR_NAKED)
{
	portSTART_ISR();
     582:	ff 93       	push	r31
     584:	ff b7       	in	r31, 0x3f	; 63
     586:	ff 93       	push	r31
     588:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     58c:	ff 93       	push	r31
     58e:	f8 7f       	andi	r31, 0xF8	; 248
     590:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     594:	0f 92       	push	r0
     596:	1f 92       	push	r1
     598:	11 24       	eor	r1, r1
     59a:	2f 92       	push	r2
     59c:	3f 92       	push	r3
     59e:	4f 92       	push	r4
     5a0:	5f 92       	push	r5
     5a2:	6f 92       	push	r6
     5a4:	7f 92       	push	r7
     5a6:	8f 92       	push	r8
     5a8:	9f 92       	push	r9
     5aa:	af 92       	push	r10
     5ac:	bf 92       	push	r11
     5ae:	cf 92       	push	r12
     5b0:	df 92       	push	r13
     5b2:	ef 92       	push	r14
     5b4:	ff 92       	push	r15
     5b6:	0f 93       	push	r16
     5b8:	1f 93       	push	r17
     5ba:	2f 93       	push	r18
     5bc:	3f 93       	push	r19
     5be:	4f 93       	push	r20
     5c0:	5f 93       	push	r21
     5c2:	6f 93       	push	r22
     5c4:	7f 93       	push	r23
     5c6:	8f 93       	push	r24
     5c8:	9f 93       	push	r25
     5ca:	af 93       	push	r26
     5cc:	bf 93       	push	r27
     5ce:	cf 93       	push	r28
     5d0:	df 93       	push	r29
     5d2:	ef 93       	push	r30
     5d4:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
     5d8:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
     5dc:	0d b6       	in	r0, 0x3d	; 61
     5de:	0d 92       	st	X+, r0
     5e0:	0e b6       	in	r0, 0x3e	; 62
     5e2:	0d 92       	st	X+, r0

	portEND_SWITCHING_ISR( USART_RXComplete(&USARTC0_data) );
     5e4:	89 e4       	ldi	r24, 0x49	; 73
     5e6:	9c e2       	ldi	r25, 0x2C	; 44
     5e8:	0e 94 46 02 	call	0x48c	; 0x48c <USART_RXComplete>
     5ec:	0e 94 8c 09 	call	0x1318	; 0x1318 <portTaskSwitchContext>
     5f0:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
     5f4:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
     5f8:	0d 90       	ld	r0, X+
     5fa:	0d be       	out	0x3d, r0	; 61
     5fc:	0d 90       	ld	r0, X+
     5fe:	0e be       	out	0x3e, r0	; 62
     600:	ef 91       	pop	r30
     602:	df 91       	pop	r29
     604:	cf 91       	pop	r28
     606:	bf 91       	pop	r27
     608:	af 91       	pop	r26
     60a:	9f 91       	pop	r25
     60c:	8f 91       	pop	r24
     60e:	7f 91       	pop	r23
     610:	6f 91       	pop	r22
     612:	5f 91       	pop	r21
     614:	4f 91       	pop	r20
     616:	3f 91       	pop	r19
     618:	2f 91       	pop	r18
     61a:	1f 91       	pop	r17
     61c:	0f 91       	pop	r16
     61e:	ff 90       	pop	r15
     620:	ef 90       	pop	r14
     622:	df 90       	pop	r13
     624:	cf 90       	pop	r12
     626:	bf 90       	pop	r11
     628:	af 90       	pop	r10
     62a:	9f 90       	pop	r9
     62c:	8f 90       	pop	r8
     62e:	7f 90       	pop	r7
     630:	6f 90       	pop	r6
     632:	5f 90       	pop	r5
     634:	4f 90       	pop	r4
     636:	3f 90       	pop	r3
     638:	2f 90       	pop	r2
     63a:	1f 90       	pop	r1
     63c:	0f 90       	pop	r0
     63e:	ff 91       	pop	r31
     640:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     644:	ff 91       	pop	r31
     646:	ff bf       	out	0x3f, r31	; 63
     648:	ff 91       	pop	r31
     64a:	18 95       	reti
	...

0000064e <__vector_28>:
}

ISR(USARTC1_RXC_vect, ISR_NAKED)
{
	portSTART_ISR();
     64e:	ff 93       	push	r31
     650:	ff b7       	in	r31, 0x3f	; 63
     652:	ff 93       	push	r31
     654:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     658:	ff 93       	push	r31
     65a:	f8 7f       	andi	r31, 0xF8	; 248
     65c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     660:	0f 92       	push	r0
     662:	1f 92       	push	r1
     664:	11 24       	eor	r1, r1
     666:	2f 92       	push	r2
     668:	3f 92       	push	r3
     66a:	4f 92       	push	r4
     66c:	5f 92       	push	r5
     66e:	6f 92       	push	r6
     670:	7f 92       	push	r7
     672:	8f 92       	push	r8
     674:	9f 92       	push	r9
     676:	af 92       	push	r10
     678:	bf 92       	push	r11
     67a:	cf 92       	push	r12
     67c:	df 92       	push	r13
     67e:	ef 92       	push	r14
     680:	ff 92       	push	r15
     682:	0f 93       	push	r16
     684:	1f 93       	push	r17
     686:	2f 93       	push	r18
     688:	3f 93       	push	r19
     68a:	4f 93       	push	r20
     68c:	5f 93       	push	r21
     68e:	6f 93       	push	r22
     690:	7f 93       	push	r23
     692:	8f 93       	push	r24
     694:	9f 93       	push	r25
     696:	af 93       	push	r26
     698:	bf 93       	push	r27
     69a:	cf 93       	push	r28
     69c:	df 93       	push	r29
     69e:	ef 93       	push	r30
     6a0:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
     6a4:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
     6a8:	0d b6       	in	r0, 0x3d	; 61
     6aa:	0d 92       	st	X+, r0
     6ac:	0e b6       	in	r0, 0x3e	; 62
     6ae:	0d 92       	st	X+, r0

	portEND_SWITCHING_ISR( USART_RXComplete(&USARTC1_data) );
     6b0:	8d e3       	ldi	r24, 0x3D	; 61
     6b2:	9c e2       	ldi	r25, 0x2C	; 44
     6b4:	0e 94 46 02 	call	0x48c	; 0x48c <USART_RXComplete>
     6b8:	0e 94 8c 09 	call	0x1318	; 0x1318 <portTaskSwitchContext>
     6bc:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
     6c0:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
     6c4:	0d 90       	ld	r0, X+
     6c6:	0d be       	out	0x3d, r0	; 61
     6c8:	0d 90       	ld	r0, X+
     6ca:	0e be       	out	0x3e, r0	; 62
     6cc:	ef 91       	pop	r30
     6ce:	df 91       	pop	r29
     6d0:	cf 91       	pop	r28
     6d2:	bf 91       	pop	r27
     6d4:	af 91       	pop	r26
     6d6:	9f 91       	pop	r25
     6d8:	8f 91       	pop	r24
     6da:	7f 91       	pop	r23
     6dc:	6f 91       	pop	r22
     6de:	5f 91       	pop	r21
     6e0:	4f 91       	pop	r20
     6e2:	3f 91       	pop	r19
     6e4:	2f 91       	pop	r18
     6e6:	1f 91       	pop	r17
     6e8:	0f 91       	pop	r16
     6ea:	ff 90       	pop	r15
     6ec:	ef 90       	pop	r14
     6ee:	df 90       	pop	r13
     6f0:	cf 90       	pop	r12
     6f2:	bf 90       	pop	r11
     6f4:	af 90       	pop	r10
     6f6:	9f 90       	pop	r9
     6f8:	8f 90       	pop	r8
     6fa:	7f 90       	pop	r7
     6fc:	6f 90       	pop	r6
     6fe:	5f 90       	pop	r5
     700:	4f 90       	pop	r4
     702:	3f 90       	pop	r3
     704:	2f 90       	pop	r2
     706:	1f 90       	pop	r1
     708:	0f 90       	pop	r0
     70a:	ff 91       	pop	r31
     70c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     710:	ff 91       	pop	r31
     712:	ff bf       	out	0x3f, r31	; 63
     714:	ff 91       	pop	r31
     716:	18 95       	reti
	...

0000071a <__vector_58>:
}

ISR(USARTE0_RXC_vect, ISR_NAKED)
{
	portSTART_ISR();
     71a:	ff 93       	push	r31
     71c:	ff b7       	in	r31, 0x3f	; 63
     71e:	ff 93       	push	r31
     720:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     724:	ff 93       	push	r31
     726:	f8 7f       	andi	r31, 0xF8	; 248
     728:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     72c:	0f 92       	push	r0
     72e:	1f 92       	push	r1
     730:	11 24       	eor	r1, r1
     732:	2f 92       	push	r2
     734:	3f 92       	push	r3
     736:	4f 92       	push	r4
     738:	5f 92       	push	r5
     73a:	6f 92       	push	r6
     73c:	7f 92       	push	r7
     73e:	8f 92       	push	r8
     740:	9f 92       	push	r9
     742:	af 92       	push	r10
     744:	bf 92       	push	r11
     746:	cf 92       	push	r12
     748:	df 92       	push	r13
     74a:	ef 92       	push	r14
     74c:	ff 92       	push	r15
     74e:	0f 93       	push	r16
     750:	1f 93       	push	r17
     752:	2f 93       	push	r18
     754:	3f 93       	push	r19
     756:	4f 93       	push	r20
     758:	5f 93       	push	r21
     75a:	6f 93       	push	r22
     75c:	7f 93       	push	r23
     75e:	8f 93       	push	r24
     760:	9f 93       	push	r25
     762:	af 93       	push	r26
     764:	bf 93       	push	r27
     766:	cf 93       	push	r28
     768:	df 93       	push	r29
     76a:	ef 93       	push	r30
     76c:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
     770:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
     774:	0d b6       	in	r0, 0x3d	; 61
     776:	0d 92       	st	X+, r0
     778:	0e b6       	in	r0, 0x3e	; 62
     77a:	0d 92       	st	X+, r0

	portEND_SWITCHING_ISR( USART_RXComplete(&USARTE0_data) );
     77c:	85 e5       	ldi	r24, 0x55	; 85
     77e:	9c e2       	ldi	r25, 0x2C	; 44
     780:	0e 94 46 02 	call	0x48c	; 0x48c <USART_RXComplete>
     784:	0e 94 8c 09 	call	0x1318	; 0x1318 <portTaskSwitchContext>
     788:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
     78c:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
     790:	0d 90       	ld	r0, X+
     792:	0d be       	out	0x3d, r0	; 61
     794:	0d 90       	ld	r0, X+
     796:	0e be       	out	0x3e, r0	; 62
     798:	ef 91       	pop	r30
     79a:	df 91       	pop	r29
     79c:	cf 91       	pop	r28
     79e:	bf 91       	pop	r27
     7a0:	af 91       	pop	r26
     7a2:	9f 91       	pop	r25
     7a4:	8f 91       	pop	r24
     7a6:	7f 91       	pop	r23
     7a8:	6f 91       	pop	r22
     7aa:	5f 91       	pop	r21
     7ac:	4f 91       	pop	r20
     7ae:	3f 91       	pop	r19
     7b0:	2f 91       	pop	r18
     7b2:	1f 91       	pop	r17
     7b4:	0f 91       	pop	r16
     7b6:	ff 90       	pop	r15
     7b8:	ef 90       	pop	r14
     7ba:	df 90       	pop	r13
     7bc:	cf 90       	pop	r12
     7be:	bf 90       	pop	r11
     7c0:	af 90       	pop	r10
     7c2:	9f 90       	pop	r9
     7c4:	8f 90       	pop	r8
     7c6:	7f 90       	pop	r7
     7c8:	6f 90       	pop	r6
     7ca:	5f 90       	pop	r5
     7cc:	4f 90       	pop	r4
     7ce:	3f 90       	pop	r3
     7d0:	2f 90       	pop	r2
     7d2:	1f 90       	pop	r1
     7d4:	0f 90       	pop	r0
     7d6:	ff 91       	pop	r31
     7d8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     7dc:	ff 91       	pop	r31
     7de:	ff bf       	out	0x3f, r31	; 63
     7e0:	ff 91       	pop	r31
     7e2:	18 95       	reti
	...

000007e6 <__vector_26>:
 *  correct USART as argument.
 */

ISR(USARTC0_DRE_vect, ISR_NAKED)
{
	portSTART_ISR();
     7e6:	ff 93       	push	r31
     7e8:	ff b7       	in	r31, 0x3f	; 63
     7ea:	ff 93       	push	r31
     7ec:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     7f0:	ff 93       	push	r31
     7f2:	f8 7f       	andi	r31, 0xF8	; 248
     7f4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     7f8:	0f 92       	push	r0
     7fa:	1f 92       	push	r1
     7fc:	11 24       	eor	r1, r1
     7fe:	2f 92       	push	r2
     800:	3f 92       	push	r3
     802:	4f 92       	push	r4
     804:	5f 92       	push	r5
     806:	6f 92       	push	r6
     808:	7f 92       	push	r7
     80a:	8f 92       	push	r8
     80c:	9f 92       	push	r9
     80e:	af 92       	push	r10
     810:	bf 92       	push	r11
     812:	cf 92       	push	r12
     814:	df 92       	push	r13
     816:	ef 92       	push	r14
     818:	ff 92       	push	r15
     81a:	0f 93       	push	r16
     81c:	1f 93       	push	r17
     81e:	2f 93       	push	r18
     820:	3f 93       	push	r19
     822:	4f 93       	push	r20
     824:	5f 93       	push	r21
     826:	6f 93       	push	r22
     828:	7f 93       	push	r23
     82a:	8f 93       	push	r24
     82c:	9f 93       	push	r25
     82e:	af 93       	push	r26
     830:	bf 93       	push	r27
     832:	cf 93       	push	r28
     834:	df 93       	push	r29
     836:	ef 93       	push	r30
     838:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
     83c:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
     840:	0d b6       	in	r0, 0x3d	; 61
     842:	0d 92       	st	X+, r0
     844:	0e b6       	in	r0, 0x3e	; 62
     846:	0d 92       	st	X+, r0

	portEND_SWITCHING_ISR( USART_DataRegEmpty(&USARTC0_data) );
     848:	89 e4       	ldi	r24, 0x49	; 73
     84a:	9c e2       	ldi	r25, 0x2C	; 44
     84c:	0e 94 75 02 	call	0x4ea	; 0x4ea <USART_DataRegEmpty>
     850:	0e 94 8c 09 	call	0x1318	; 0x1318 <portTaskSwitchContext>
     854:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
     858:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
     85c:	0d 90       	ld	r0, X+
     85e:	0d be       	out	0x3d, r0	; 61
     860:	0d 90       	ld	r0, X+
     862:	0e be       	out	0x3e, r0	; 62
     864:	ef 91       	pop	r30
     866:	df 91       	pop	r29
     868:	cf 91       	pop	r28
     86a:	bf 91       	pop	r27
     86c:	af 91       	pop	r26
     86e:	9f 91       	pop	r25
     870:	8f 91       	pop	r24
     872:	7f 91       	pop	r23
     874:	6f 91       	pop	r22
     876:	5f 91       	pop	r21
     878:	4f 91       	pop	r20
     87a:	3f 91       	pop	r19
     87c:	2f 91       	pop	r18
     87e:	1f 91       	pop	r17
     880:	0f 91       	pop	r16
     882:	ff 90       	pop	r15
     884:	ef 90       	pop	r14
     886:	df 90       	pop	r13
     888:	cf 90       	pop	r12
     88a:	bf 90       	pop	r11
     88c:	af 90       	pop	r10
     88e:	9f 90       	pop	r9
     890:	8f 90       	pop	r8
     892:	7f 90       	pop	r7
     894:	6f 90       	pop	r6
     896:	5f 90       	pop	r5
     898:	4f 90       	pop	r4
     89a:	3f 90       	pop	r3
     89c:	2f 90       	pop	r2
     89e:	1f 90       	pop	r1
     8a0:	0f 90       	pop	r0
     8a2:	ff 91       	pop	r31
     8a4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     8a8:	ff 91       	pop	r31
     8aa:	ff bf       	out	0x3f, r31	; 63
     8ac:	ff 91       	pop	r31
     8ae:	18 95       	reti
	...

000008b2 <__vector_default>:
}


ISR(BADISR_vect)
{
     8b2:	1f 92       	push	r1
     8b4:	0f 92       	push	r0
     8b6:	00 90 3f 00 	lds	r0, 0x003F	; 0x80003f <__TEXT_REGION_LENGTH__+0x70003f>
     8ba:	0f 92       	push	r0
     8bc:	11 24       	eor	r1, r1
     8be:	00 90 3b 00 	lds	r0, 0x003B	; 0x80003b <__TEXT_REGION_LENGTH__+0x70003b>
     8c2:	0f 92       	push	r0
     8c4:	2f 93       	push	r18
     8c6:	3f 93       	push	r19
     8c8:	4f 93       	push	r20
     8ca:	5f 93       	push	r21
     8cc:	6f 93       	push	r22
     8ce:	7f 93       	push	r23
     8d0:	8f 93       	push	r24
     8d2:	9f 93       	push	r25
     8d4:	af 93       	push	r26
     8d6:	bf 93       	push	r27
     8d8:	ef 93       	push	r30
     8da:	ff 93       	push	r31
     8dc:	cf 93       	push	r28
     8de:	df 93       	push	r29
     8e0:	cd b7       	in	r28, 0x3d	; 61
     8e2:	de b7       	in	r29, 0x3e	; 62
    error(ERR_BAD_ISR);
     8e4:	80 e3       	ldi	r24, 0x30	; 48
     8e6:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
}
     8ea:	00 00       	nop
     8ec:	df 91       	pop	r29
     8ee:	cf 91       	pop	r28
     8f0:	ff 91       	pop	r31
     8f2:	ef 91       	pop	r30
     8f4:	bf 91       	pop	r27
     8f6:	af 91       	pop	r26
     8f8:	9f 91       	pop	r25
     8fa:	8f 91       	pop	r24
     8fc:	7f 91       	pop	r23
     8fe:	6f 91       	pop	r22
     900:	5f 91       	pop	r21
     902:	4f 91       	pop	r20
     904:	3f 91       	pop	r19
     906:	2f 91       	pop	r18
     908:	0f 90       	pop	r0
     90a:	00 92 3b 00 	sts	0x003B, r0	; 0x80003b <__TEXT_REGION_LENGTH__+0x70003b>
     90e:	0f 90       	pop	r0
     910:	00 92 3f 00 	sts	0x003F, r0	; 0x80003f <__TEXT_REGION_LENGTH__+0x70003f>
     914:	0f 90       	pop	r0
     916:	1f 90       	pop	r1
     918:	18 95       	reti

0000091a <PORT_ConfigureInterrupt0>:
                               PORT_INT1LVL_t intLevel,
                               uint8_t pinMask )
{
	port->INTCTRL = ( port->INTCTRL & ~PORT_INT1LVL_gm ) | intLevel;
	port->INT1MASK = pinMask;
}
     91a:	cf 93       	push	r28
     91c:	df 93       	push	r29
     91e:	00 d0       	rcall	.+0      	; 0x920 <PORT_ConfigureInterrupt0+0x6>
     920:	1f 92       	push	r1
     922:	cd b7       	in	r28, 0x3d	; 61
     924:	de b7       	in	r29, 0x3e	; 62
     926:	89 83       	std	Y+1, r24	; 0x01
     928:	9a 83       	std	Y+2, r25	; 0x02
     92a:	6b 83       	std	Y+3, r22	; 0x03
     92c:	4c 83       	std	Y+4, r20	; 0x04
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	9a 81       	ldd	r25, Y+2	; 0x02
     932:	fc 01       	movw	r30, r24
     934:	81 85       	ldd	r24, Z+9	; 0x09
     936:	98 2f       	mov	r25, r24
     938:	9c 7f       	andi	r25, 0xFC	; 252
     93a:	8b 81       	ldd	r24, Y+3	; 0x03
     93c:	89 2b       	or	r24, r25
     93e:	28 2f       	mov	r18, r24
     940:	89 81       	ldd	r24, Y+1	; 0x01
     942:	9a 81       	ldd	r25, Y+2	; 0x02
     944:	fc 01       	movw	r30, r24
     946:	21 87       	std	Z+9, r18	; 0x09
     948:	89 81       	ldd	r24, Y+1	; 0x01
     94a:	9a 81       	ldd	r25, Y+2	; 0x02
     94c:	2c 81       	ldd	r18, Y+4	; 0x04
     94e:	fc 01       	movw	r30, r24
     950:	22 87       	std	Z+10, r18	; 0x0a
     952:	00 00       	nop
     954:	24 96       	adiw	r28, 0x04	; 4
     956:	cd bf       	out	0x3d, r28	; 61
     958:	de bf       	out	0x3e, r29	; 62
     95a:	df 91       	pop	r29
     95c:	cf 91       	pop	r28
     95e:	08 95       	ret

00000960 <PORT_ConfigurePins>:
                         uint8_t pinMask,
                         uint8_t slewRateEnable,
                         uint8_t invertEnable,
                         PORT_OPC_t opc,
                         PORT_ISC_t isc)
{
     960:	ef 92       	push	r14
     962:	0f 93       	push	r16
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
     968:	cd b7       	in	r28, 0x3d	; 61
     96a:	de b7       	in	r29, 0x3e	; 62
     96c:	29 97       	sbiw	r28, 0x09	; 9
     96e:	cd bf       	out	0x3d, r28	; 61
     970:	de bf       	out	0x3e, r29	; 62
     972:	8b 83       	std	Y+3, r24	; 0x03
     974:	9c 83       	std	Y+4, r25	; 0x04
     976:	6d 83       	std	Y+5, r22	; 0x05
     978:	4e 83       	std	Y+6, r20	; 0x06
     97a:	2f 83       	std	Y+7, r18	; 0x07
     97c:	08 87       	std	Y+8, r16	; 0x08
     97e:	e9 86       	std	Y+9, r14	; 0x09
	/* Build pin control register value. */
	uint8_t temp = (uint8_t) opc |
     980:	98 85       	ldd	r25, Y+8	; 0x08
     982:	89 85       	ldd	r24, Y+9	; 0x09
     984:	89 2b       	or	r24, r25
     986:	98 2f       	mov	r25, r24
     988:	8e 81       	ldd	r24, Y+6	; 0x06
     98a:	88 23       	and	r24, r24
     98c:	11 f0       	breq	.+4      	; 0x992 <PORT_ConfigurePins+0x32>
     98e:	80 e8       	ldi	r24, 0x80	; 128
     990:	01 c0       	rjmp	.+2      	; 0x994 <PORT_ConfigurePins+0x34>
     992:	80 e0       	ldi	r24, 0x00	; 0
     994:	98 2b       	or	r25, r24
     996:	8f 81       	ldd	r24, Y+7	; 0x07
     998:	88 23       	and	r24, r24
     99a:	11 f0       	breq	.+4      	; 0x9a0 <PORT_ConfigurePins+0x40>
     99c:	80 e4       	ldi	r24, 0x40	; 64
     99e:	01 c0       	rjmp	.+2      	; 0x9a2 <PORT_ConfigurePins+0x42>
     9a0:	80 e0       	ldi	r24, 0x00	; 0
     9a2:	89 2b       	or	r24, r25
     9a4:	89 83       	std	Y+1, r24	; 0x01
	               (invertEnable ? PORT_INVEN_bm : 0);

	/* Configure the pins in one atomic operation. */

	/* Save status register. */
	uint8_t sreg = SREG;
     9a6:	8f e3       	ldi	r24, 0x3F	; 63
     9a8:	90 e0       	ldi	r25, 0x00	; 0
     9aa:	fc 01       	movw	r30, r24
     9ac:	80 81       	ld	r24, Z
     9ae:	8a 83       	std	Y+2, r24	; 0x02

	cli();
     9b0:	f8 94       	cli
	PORTCFG.MPCMASK = pinMask;
     9b2:	80 eb       	ldi	r24, 0xB0	; 176
     9b4:	90 e0       	ldi	r25, 0x00	; 0
     9b6:	2d 81       	ldd	r18, Y+5	; 0x05
     9b8:	fc 01       	movw	r30, r24
     9ba:	20 83       	st	Z, r18
	port->PIN0CTRL = temp;
     9bc:	8b 81       	ldd	r24, Y+3	; 0x03
     9be:	9c 81       	ldd	r25, Y+4	; 0x04
     9c0:	29 81       	ldd	r18, Y+1	; 0x01
     9c2:	fc 01       	movw	r30, r24
     9c4:	20 8b       	std	Z+16, r18	; 0x10

	/* Restore status register. */
	SREG = sreg;
     9c6:	8f e3       	ldi	r24, 0x3F	; 63
     9c8:	90 e0       	ldi	r25, 0x00	; 0
     9ca:	2a 81       	ldd	r18, Y+2	; 0x02
     9cc:	fc 01       	movw	r30, r24
     9ce:	20 83       	st	Z, r18
}
     9d0:	00 00       	nop
     9d2:	29 96       	adiw	r28, 0x09	; 9
     9d4:	cd bf       	out	0x3d, r28	; 61
     9d6:	de bf       	out	0x3e, r29	; 62
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	0f 91       	pop	r16
     9de:	ef 90       	pop	r14
     9e0:	08 95       	ret

000009e2 <TC0_ConfigClockSource>:
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
}
     9e2:	cf 93       	push	r28
     9e4:	df 93       	push	r29
     9e6:	00 d0       	rcall	.+0      	; 0x9e8 <TC0_ConfigClockSource+0x6>
     9e8:	cd b7       	in	r28, 0x3d	; 61
     9ea:	de b7       	in	r29, 0x3e	; 62
     9ec:	89 83       	std	Y+1, r24	; 0x01
     9ee:	9a 83       	std	Y+2, r25	; 0x02
     9f0:	6b 83       	std	Y+3, r22	; 0x03
     9f2:	89 81       	ldd	r24, Y+1	; 0x01
     9f4:	9a 81       	ldd	r25, Y+2	; 0x02
     9f6:	fc 01       	movw	r30, r24
     9f8:	80 81       	ld	r24, Z
     9fa:	98 2f       	mov	r25, r24
     9fc:	90 7f       	andi	r25, 0xF0	; 240
     9fe:	8b 81       	ldd	r24, Y+3	; 0x03
     a00:	89 2b       	or	r24, r25
     a02:	28 2f       	mov	r18, r24
     a04:	89 81       	ldd	r24, Y+1	; 0x01
     a06:	9a 81       	ldd	r25, Y+2	; 0x02
     a08:	fc 01       	movw	r30, r24
     a0a:	20 83       	st	Z, r18
     a0c:	00 00       	nop
     a0e:	23 96       	adiw	r28, 0x03	; 3
     a10:	cd bf       	out	0x3d, r28	; 61
     a12:	de bf       	out	0x3e, r29	; 62
     a14:	df 91       	pop	r29
     a16:	cf 91       	pop	r28
     a18:	08 95       	ret

00000a1a <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
     a1a:	cf 93       	push	r28
     a1c:	df 93       	push	r29
     a1e:	00 d0       	rcall	.+0      	; 0xa20 <TC0_SetOverflowIntLevel+0x6>
     a20:	cd b7       	in	r28, 0x3d	; 61
     a22:	de b7       	in	r29, 0x3e	; 62
     a24:	89 83       	std	Y+1, r24	; 0x01
     a26:	9a 83       	std	Y+2, r25	; 0x02
     a28:	6b 83       	std	Y+3, r22	; 0x03
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     a2a:	89 81       	ldd	r24, Y+1	; 0x01
     a2c:	9a 81       	ldd	r25, Y+2	; 0x02
     a2e:	fc 01       	movw	r30, r24
     a30:	86 81       	ldd	r24, Z+6	; 0x06
     a32:	98 2f       	mov	r25, r24
     a34:	9c 7f       	andi	r25, 0xFC	; 252
     a36:	8b 81       	ldd	r24, Y+3	; 0x03
     a38:	89 2b       	or	r24, r25
     a3a:	28 2f       	mov	r18, r24
     a3c:	89 81       	ldd	r24, Y+1	; 0x01
     a3e:	9a 81       	ldd	r25, Y+2	; 0x02
     a40:	fc 01       	movw	r30, r24
     a42:	26 83       	std	Z+6, r18	; 0x06
}
     a44:	00 00       	nop
     a46:	23 96       	adiw	r28, 0x03	; 3
     a48:	cd bf       	out	0x3d, r28	; 61
     a4a:	de bf       	out	0x3e, r29	; 62
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	08 95       	ret

00000a52 <pvPortMalloc>:

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
}
     a52:	cf 93       	push	r28
     a54:	df 93       	push	r29
     a56:	00 d0       	rcall	.+0      	; 0xa58 <pvPortMalloc+0x6>
     a58:	1f 92       	push	r1
     a5a:	cd b7       	in	r28, 0x3d	; 61
     a5c:	de b7       	in	r29, 0x3e	; 62
     a5e:	8b 83       	std	Y+3, r24	; 0x03
     a60:	9c 83       	std	Y+4, r25	; 0x04
     a62:	19 82       	std	Y+1, r1	; 0x01
     a64:	1a 82       	std	Y+2, r1	; 0x02
     a66:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <vTaskSuspendAll>
     a6a:	20 91 c6 2b 	lds	r18, 0x2BC6	; 0x802bc6 <xNextFreeByte>
     a6e:	30 91 c7 2b 	lds	r19, 0x2BC7	; 0x802bc7 <xNextFreeByte+0x1>
     a72:	8b 81       	ldd	r24, Y+3	; 0x03
     a74:	9c 81       	ldd	r25, Y+4	; 0x04
     a76:	82 0f       	add	r24, r18
     a78:	93 1f       	adc	r25, r19
     a7a:	88 3b       	cpi	r24, 0xB8	; 184
     a7c:	9b 40       	sbci	r25, 0x0B	; 11
     a7e:	18 f5       	brcc	.+70     	; 0xac6 <pvPortMalloc+0x74>
     a80:	20 91 c6 2b 	lds	r18, 0x2BC6	; 0x802bc6 <xNextFreeByte>
     a84:	30 91 c7 2b 	lds	r19, 0x2BC7	; 0x802bc7 <xNextFreeByte+0x1>
     a88:	8b 81       	ldd	r24, Y+3	; 0x03
     a8a:	9c 81       	ldd	r25, Y+4	; 0x04
     a8c:	28 0f       	add	r18, r24
     a8e:	39 1f       	adc	r19, r25
     a90:	80 91 c6 2b 	lds	r24, 0x2BC6	; 0x802bc6 <xNextFreeByte>
     a94:	90 91 c7 2b 	lds	r25, 0x2BC7	; 0x802bc7 <xNextFreeByte+0x1>
     a98:	82 17       	cp	r24, r18
     a9a:	93 07       	cpc	r25, r19
     a9c:	a0 f4       	brcc	.+40     	; 0xac6 <pvPortMalloc+0x74>
     a9e:	80 91 c6 2b 	lds	r24, 0x2BC6	; 0x802bc6 <xNextFreeByte>
     aa2:	90 91 c7 2b 	lds	r25, 0x2BC7	; 0x802bc7 <xNextFreeByte+0x1>
     aa6:	82 5f       	subi	r24, 0xF2	; 242
     aa8:	9f 4d       	sbci	r25, 0xDF	; 223
     aaa:	89 83       	std	Y+1, r24	; 0x01
     aac:	9a 83       	std	Y+2, r25	; 0x02
     aae:	20 91 c6 2b 	lds	r18, 0x2BC6	; 0x802bc6 <xNextFreeByte>
     ab2:	30 91 c7 2b 	lds	r19, 0x2BC7	; 0x802bc7 <xNextFreeByte+0x1>
     ab6:	8b 81       	ldd	r24, Y+3	; 0x03
     ab8:	9c 81       	ldd	r25, Y+4	; 0x04
     aba:	82 0f       	add	r24, r18
     abc:	93 1f       	adc	r25, r19
     abe:	80 93 c6 2b 	sts	0x2BC6, r24	; 0x802bc6 <xNextFreeByte>
     ac2:	90 93 c7 2b 	sts	0x2BC7, r25	; 0x802bc7 <xNextFreeByte+0x1>
     ac6:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xTaskResumeAll>
     aca:	89 81       	ldd	r24, Y+1	; 0x01
     acc:	9a 81       	ldd	r25, Y+2	; 0x02
     ace:	89 2b       	or	r24, r25
     ad0:	11 f4       	brne	.+4      	; 0xad6 <pvPortMalloc+0x84>
     ad2:	0e 94 6e 14 	call	0x28dc	; 0x28dc <vApplicationMallocFailedHook>
     ad6:	89 81       	ldd	r24, Y+1	; 0x01
     ad8:	9a 81       	ldd	r25, Y+2	; 0x02
     ada:	24 96       	adiw	r28, 0x04	; 4
     adc:	cd bf       	out	0x3d, r28	; 61
     ade:	de bf       	out	0x3e, r29	; 62
     ae0:	df 91       	pop	r29
     ae2:	cf 91       	pop	r28
     ae4:	08 95       	ret

00000ae6 <vPortFree>:
     ae6:	cf 93       	push	r28
     ae8:	df 93       	push	r29
     aea:	1f 92       	push	r1
     aec:	1f 92       	push	r1
     aee:	cd b7       	in	r28, 0x3d	; 61
     af0:	de b7       	in	r29, 0x3e	; 62
     af2:	89 83       	std	Y+1, r24	; 0x01
     af4:	9a 83       	std	Y+2, r25	; 0x02
     af6:	00 00       	nop
     af8:	0f 90       	pop	r0
     afa:	0f 90       	pop	r0
     afc:	df 91       	pop	r29
     afe:	cf 91       	pop	r28
     b00:	08 95       	ret

00000b02 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     b02:	cf 93       	push	r28
     b04:	df 93       	push	r29
     b06:	cd b7       	in	r28, 0x3d	; 61
     b08:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     b0a:	80 91 c6 2b 	lds	r24, 0x2BC6	; 0x802bc6 <xNextFreeByte>
     b0e:	90 91 c7 2b 	lds	r25, 0x2BC7	; 0x802bc7 <xNextFreeByte+0x1>
     b12:	28 eb       	ldi	r18, 0xB8	; 184
     b14:	3b e0       	ldi	r19, 0x0B	; 11
     b16:	a9 01       	movw	r20, r18
     b18:	48 1b       	sub	r20, r24
     b1a:	59 0b       	sbc	r21, r25
     b1c:	ca 01       	movw	r24, r20
}
     b1e:	df 91       	pop	r29
     b20:	cf 91       	pop	r28
     b22:	08 95       	ret

00000b24 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     b24:	cf 93       	push	r28
     b26:	df 93       	push	r29
     b28:	1f 92       	push	r1
     b2a:	1f 92       	push	r1
     b2c:	cd b7       	in	r28, 0x3d	; 61
     b2e:	de b7       	in	r29, 0x3e	; 62
     b30:	89 83       	std	Y+1, r24	; 0x01
     b32:	9a 83       	std	Y+2, r25	; 0x02
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b34:	89 81       	ldd	r24, Y+1	; 0x01
     b36:	9a 81       	ldd	r25, Y+2	; 0x02
     b38:	9c 01       	movw	r18, r24
     b3a:	2d 5f       	subi	r18, 0xFD	; 253
     b3c:	3f 4f       	sbci	r19, 0xFF	; 255
     b3e:	89 81       	ldd	r24, Y+1	; 0x01
     b40:	9a 81       	ldd	r25, Y+2	; 0x02
     b42:	fc 01       	movw	r30, r24
     b44:	21 83       	std	Z+1, r18	; 0x01
     b46:	32 83       	std	Z+2, r19	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     b48:	29 81       	ldd	r18, Y+1	; 0x01
     b4a:	3a 81       	ldd	r19, Y+2	; 0x02
     b4c:	8f ef       	ldi	r24, 0xFF	; 255
     b4e:	9f ef       	ldi	r25, 0xFF	; 255
     b50:	dc 01       	movw	r26, r24
     b52:	f9 01       	movw	r30, r18
     b54:	83 83       	std	Z+3, r24	; 0x03
     b56:	94 83       	std	Z+4, r25	; 0x04
     b58:	a5 83       	std	Z+5, r26	; 0x05
     b5a:	b6 83       	std	Z+6, r27	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b5c:	89 81       	ldd	r24, Y+1	; 0x01
     b5e:	9a 81       	ldd	r25, Y+2	; 0x02
     b60:	9c 01       	movw	r18, r24
     b62:	2d 5f       	subi	r18, 0xFD	; 253
     b64:	3f 4f       	sbci	r19, 0xFF	; 255
     b66:	89 81       	ldd	r24, Y+1	; 0x01
     b68:	9a 81       	ldd	r25, Y+2	; 0x02
     b6a:	fc 01       	movw	r30, r24
     b6c:	27 83       	std	Z+7, r18	; 0x07
     b6e:	30 87       	std	Z+8, r19	; 0x08
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b70:	89 81       	ldd	r24, Y+1	; 0x01
     b72:	9a 81       	ldd	r25, Y+2	; 0x02
     b74:	9c 01       	movw	r18, r24
     b76:	2d 5f       	subi	r18, 0xFD	; 253
     b78:	3f 4f       	sbci	r19, 0xFF	; 255
     b7a:	89 81       	ldd	r24, Y+1	; 0x01
     b7c:	9a 81       	ldd	r25, Y+2	; 0x02
     b7e:	fc 01       	movw	r30, r24
     b80:	21 87       	std	Z+9, r18	; 0x09
     b82:	32 87       	std	Z+10, r19	; 0x0a

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	9a 81       	ldd	r25, Y+2	; 0x02
     b88:	fc 01       	movw	r30, r24
     b8a:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     b8c:	00 00       	nop
     b8e:	0f 90       	pop	r0
     b90:	0f 90       	pop	r0
     b92:	df 91       	pop	r29
     b94:	cf 91       	pop	r28
     b96:	08 95       	ret

00000b98 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     b98:	cf 93       	push	r28
     b9a:	df 93       	push	r29
     b9c:	1f 92       	push	r1
     b9e:	1f 92       	push	r1
     ba0:	cd b7       	in	r28, 0x3d	; 61
     ba2:	de b7       	in	r29, 0x3e	; 62
     ba4:	89 83       	std	Y+1, r24	; 0x01
     ba6:	9a 83       	std	Y+2, r25	; 0x02
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     ba8:	89 81       	ldd	r24, Y+1	; 0x01
     baa:	9a 81       	ldd	r25, Y+2	; 0x02
     bac:	fc 01       	movw	r30, r24
     bae:	12 86       	std	Z+10, r1	; 0x0a
     bb0:	13 86       	std	Z+11, r1	; 0x0b

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     bb2:	00 00       	nop
     bb4:	0f 90       	pop	r0
     bb6:	0f 90       	pop	r0
     bb8:	df 91       	pop	r29
     bba:	cf 91       	pop	r28
     bbc:	08 95       	ret

00000bbe <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     bbe:	cf 93       	push	r28
     bc0:	df 93       	push	r29
     bc2:	00 d0       	rcall	.+0      	; 0xbc4 <vListInsertEnd+0x6>
     bc4:	00 d0       	rcall	.+0      	; 0xbc6 <vListInsertEnd+0x8>
     bc6:	cd b7       	in	r28, 0x3d	; 61
     bc8:	de b7       	in	r29, 0x3e	; 62
     bca:	8b 83       	std	Y+3, r24	; 0x03
     bcc:	9c 83       	std	Y+4, r25	; 0x04
     bce:	6d 83       	std	Y+5, r22	; 0x05
     bd0:	7e 83       	std	Y+6, r23	; 0x06
ListItem_t * const pxIndex = pxList->pxIndex;
     bd2:	8b 81       	ldd	r24, Y+3	; 0x03
     bd4:	9c 81       	ldd	r25, Y+4	; 0x04
     bd6:	fc 01       	movw	r30, r24
     bd8:	81 81       	ldd	r24, Z+1	; 0x01
     bda:	92 81       	ldd	r25, Z+2	; 0x02
     bdc:	89 83       	std	Y+1, r24	; 0x01
     bde:	9a 83       	std	Y+2, r25	; 0x02
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     be0:	8d 81       	ldd	r24, Y+5	; 0x05
     be2:	9e 81       	ldd	r25, Y+6	; 0x06
     be4:	29 81       	ldd	r18, Y+1	; 0x01
     be6:	3a 81       	ldd	r19, Y+2	; 0x02
     be8:	fc 01       	movw	r30, r24
     bea:	24 83       	std	Z+4, r18	; 0x04
     bec:	35 83       	std	Z+5, r19	; 0x05
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	9a 81       	ldd	r25, Y+2	; 0x02
     bf2:	fc 01       	movw	r30, r24
     bf4:	26 81       	ldd	r18, Z+6	; 0x06
     bf6:	37 81       	ldd	r19, Z+7	; 0x07
     bf8:	8d 81       	ldd	r24, Y+5	; 0x05
     bfa:	9e 81       	ldd	r25, Y+6	; 0x06
     bfc:	fc 01       	movw	r30, r24
     bfe:	26 83       	std	Z+6, r18	; 0x06
     c00:	37 83       	std	Z+7, r19	; 0x07

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     c02:	89 81       	ldd	r24, Y+1	; 0x01
     c04:	9a 81       	ldd	r25, Y+2	; 0x02
     c06:	fc 01       	movw	r30, r24
     c08:	86 81       	ldd	r24, Z+6	; 0x06
     c0a:	97 81       	ldd	r25, Z+7	; 0x07
     c0c:	2d 81       	ldd	r18, Y+5	; 0x05
     c0e:	3e 81       	ldd	r19, Y+6	; 0x06
     c10:	fc 01       	movw	r30, r24
     c12:	24 83       	std	Z+4, r18	; 0x04
     c14:	35 83       	std	Z+5, r19	; 0x05
	pxIndex->pxPrevious = pxNewListItem;
     c16:	89 81       	ldd	r24, Y+1	; 0x01
     c18:	9a 81       	ldd	r25, Y+2	; 0x02
     c1a:	2d 81       	ldd	r18, Y+5	; 0x05
     c1c:	3e 81       	ldd	r19, Y+6	; 0x06
     c1e:	fc 01       	movw	r30, r24
     c20:	26 83       	std	Z+6, r18	; 0x06
     c22:	37 83       	std	Z+7, r19	; 0x07

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     c24:	8d 81       	ldd	r24, Y+5	; 0x05
     c26:	9e 81       	ldd	r25, Y+6	; 0x06
     c28:	2b 81       	ldd	r18, Y+3	; 0x03
     c2a:	3c 81       	ldd	r19, Y+4	; 0x04
     c2c:	fc 01       	movw	r30, r24
     c2e:	22 87       	std	Z+10, r18	; 0x0a
     c30:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     c32:	8b 81       	ldd	r24, Y+3	; 0x03
     c34:	9c 81       	ldd	r25, Y+4	; 0x04
     c36:	fc 01       	movw	r30, r24
     c38:	80 81       	ld	r24, Z
     c3a:	21 e0       	ldi	r18, 0x01	; 1
     c3c:	28 0f       	add	r18, r24
     c3e:	8b 81       	ldd	r24, Y+3	; 0x03
     c40:	9c 81       	ldd	r25, Y+4	; 0x04
     c42:	fc 01       	movw	r30, r24
     c44:	20 83       	st	Z, r18
}
     c46:	00 00       	nop
     c48:	26 96       	adiw	r28, 0x06	; 6
     c4a:	cd bf       	out	0x3d, r28	; 61
     c4c:	de bf       	out	0x3e, r29	; 62
     c4e:	df 91       	pop	r29
     c50:	cf 91       	pop	r28
     c52:	08 95       	ret

00000c54 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     c54:	cf 93       	push	r28
     c56:	df 93       	push	r29
     c58:	cd b7       	in	r28, 0x3d	; 61
     c5a:	de b7       	in	r29, 0x3e	; 62
     c5c:	2a 97       	sbiw	r28, 0x0a	; 10
     c5e:	cd bf       	out	0x3d, r28	; 61
     c60:	de bf       	out	0x3e, r29	; 62
     c62:	8f 83       	std	Y+7, r24	; 0x07
     c64:	98 87       	std	Y+8, r25	; 0x08
     c66:	69 87       	std	Y+9, r22	; 0x09
     c68:	7a 87       	std	Y+10, r23	; 0x0a
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     c6a:	89 85       	ldd	r24, Y+9	; 0x09
     c6c:	9a 85       	ldd	r25, Y+10	; 0x0a
     c6e:	fc 01       	movw	r30, r24
     c70:	80 81       	ld	r24, Z
     c72:	91 81       	ldd	r25, Z+1	; 0x01
     c74:	a2 81       	ldd	r26, Z+2	; 0x02
     c76:	b3 81       	ldd	r27, Z+3	; 0x03
     c78:	8b 83       	std	Y+3, r24	; 0x03
     c7a:	9c 83       	std	Y+4, r25	; 0x04
     c7c:	ad 83       	std	Y+5, r26	; 0x05
     c7e:	be 83       	std	Y+6, r27	; 0x06
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     c80:	8b 81       	ldd	r24, Y+3	; 0x03
     c82:	9c 81       	ldd	r25, Y+4	; 0x04
     c84:	ad 81       	ldd	r26, Y+5	; 0x05
     c86:	be 81       	ldd	r27, Y+6	; 0x06
     c88:	8f 3f       	cpi	r24, 0xFF	; 255
     c8a:	9f 4f       	sbci	r25, 0xFF	; 255
     c8c:	af 4f       	sbci	r26, 0xFF	; 255
     c8e:	bf 4f       	sbci	r27, 0xFF	; 255
     c90:	41 f4       	brne	.+16     	; 0xca2 <vListInsert+0x4e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     c92:	8f 81       	ldd	r24, Y+7	; 0x07
     c94:	98 85       	ldd	r25, Y+8	; 0x08
     c96:	fc 01       	movw	r30, r24
     c98:	81 85       	ldd	r24, Z+9	; 0x09
     c9a:	92 85       	ldd	r25, Z+10	; 0x0a
     c9c:	89 83       	std	Y+1, r24	; 0x01
     c9e:	9a 83       	std	Y+2, r25	; 0x02
     ca0:	20 c0       	rjmp	.+64     	; 0xce2 <vListInsert+0x8e>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ca2:	8f 81       	ldd	r24, Y+7	; 0x07
     ca4:	98 85       	ldd	r25, Y+8	; 0x08
     ca6:	03 96       	adiw	r24, 0x03	; 3
     ca8:	89 83       	std	Y+1, r24	; 0x01
     caa:	9a 83       	std	Y+2, r25	; 0x02
     cac:	07 c0       	rjmp	.+14     	; 0xcbc <vListInsert+0x68>
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	9a 81       	ldd	r25, Y+2	; 0x02
     cb2:	fc 01       	movw	r30, r24
     cb4:	84 81       	ldd	r24, Z+4	; 0x04
     cb6:	95 81       	ldd	r25, Z+5	; 0x05
     cb8:	89 83       	std	Y+1, r24	; 0x01
     cba:	9a 83       	std	Y+2, r25	; 0x02
     cbc:	89 81       	ldd	r24, Y+1	; 0x01
     cbe:	9a 81       	ldd	r25, Y+2	; 0x02
     cc0:	fc 01       	movw	r30, r24
     cc2:	84 81       	ldd	r24, Z+4	; 0x04
     cc4:	95 81       	ldd	r25, Z+5	; 0x05
     cc6:	fc 01       	movw	r30, r24
     cc8:	20 81       	ld	r18, Z
     cca:	31 81       	ldd	r19, Z+1	; 0x01
     ccc:	42 81       	ldd	r20, Z+2	; 0x02
     cce:	53 81       	ldd	r21, Z+3	; 0x03
     cd0:	8b 81       	ldd	r24, Y+3	; 0x03
     cd2:	9c 81       	ldd	r25, Y+4	; 0x04
     cd4:	ad 81       	ldd	r26, Y+5	; 0x05
     cd6:	be 81       	ldd	r27, Y+6	; 0x06
     cd8:	82 17       	cp	r24, r18
     cda:	93 07       	cpc	r25, r19
     cdc:	a4 07       	cpc	r26, r20
     cde:	b5 07       	cpc	r27, r21
     ce0:	30 f7       	brcc	.-52     	; 0xcae <vListInsert+0x5a>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     ce2:	89 81       	ldd	r24, Y+1	; 0x01
     ce4:	9a 81       	ldd	r25, Y+2	; 0x02
     ce6:	fc 01       	movw	r30, r24
     ce8:	24 81       	ldd	r18, Z+4	; 0x04
     cea:	35 81       	ldd	r19, Z+5	; 0x05
     cec:	89 85       	ldd	r24, Y+9	; 0x09
     cee:	9a 85       	ldd	r25, Y+10	; 0x0a
     cf0:	fc 01       	movw	r30, r24
     cf2:	24 83       	std	Z+4, r18	; 0x04
     cf4:	35 83       	std	Z+5, r19	; 0x05
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     cf6:	89 85       	ldd	r24, Y+9	; 0x09
     cf8:	9a 85       	ldd	r25, Y+10	; 0x0a
     cfa:	fc 01       	movw	r30, r24
     cfc:	84 81       	ldd	r24, Z+4	; 0x04
     cfe:	95 81       	ldd	r25, Z+5	; 0x05
     d00:	29 85       	ldd	r18, Y+9	; 0x09
     d02:	3a 85       	ldd	r19, Y+10	; 0x0a
     d04:	fc 01       	movw	r30, r24
     d06:	26 83       	std	Z+6, r18	; 0x06
     d08:	37 83       	std	Z+7, r19	; 0x07
	pxNewListItem->pxPrevious = pxIterator;
     d0a:	89 85       	ldd	r24, Y+9	; 0x09
     d0c:	9a 85       	ldd	r25, Y+10	; 0x0a
     d0e:	29 81       	ldd	r18, Y+1	; 0x01
     d10:	3a 81       	ldd	r19, Y+2	; 0x02
     d12:	fc 01       	movw	r30, r24
     d14:	26 83       	std	Z+6, r18	; 0x06
     d16:	37 83       	std	Z+7, r19	; 0x07
	pxIterator->pxNext = pxNewListItem;
     d18:	89 81       	ldd	r24, Y+1	; 0x01
     d1a:	9a 81       	ldd	r25, Y+2	; 0x02
     d1c:	29 85       	ldd	r18, Y+9	; 0x09
     d1e:	3a 85       	ldd	r19, Y+10	; 0x0a
     d20:	fc 01       	movw	r30, r24
     d22:	24 83       	std	Z+4, r18	; 0x04
     d24:	35 83       	std	Z+5, r19	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d26:	89 85       	ldd	r24, Y+9	; 0x09
     d28:	9a 85       	ldd	r25, Y+10	; 0x0a
     d2a:	2f 81       	ldd	r18, Y+7	; 0x07
     d2c:	38 85       	ldd	r19, Y+8	; 0x08
     d2e:	fc 01       	movw	r30, r24
     d30:	22 87       	std	Z+10, r18	; 0x0a
     d32:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     d34:	8f 81       	ldd	r24, Y+7	; 0x07
     d36:	98 85       	ldd	r25, Y+8	; 0x08
     d38:	fc 01       	movw	r30, r24
     d3a:	80 81       	ld	r24, Z
     d3c:	21 e0       	ldi	r18, 0x01	; 1
     d3e:	28 0f       	add	r18, r24
     d40:	8f 81       	ldd	r24, Y+7	; 0x07
     d42:	98 85       	ldd	r25, Y+8	; 0x08
     d44:	fc 01       	movw	r30, r24
     d46:	20 83       	st	Z, r18
}
     d48:	00 00       	nop
     d4a:	2a 96       	adiw	r28, 0x0a	; 10
     d4c:	cd bf       	out	0x3d, r28	; 61
     d4e:	de bf       	out	0x3e, r29	; 62
     d50:	df 91       	pop	r29
     d52:	cf 91       	pop	r28
     d54:	08 95       	ret

00000d56 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     d56:	cf 93       	push	r28
     d58:	df 93       	push	r29
     d5a:	00 d0       	rcall	.+0      	; 0xd5c <uxListRemove+0x6>
     d5c:	1f 92       	push	r1
     d5e:	cd b7       	in	r28, 0x3d	; 61
     d60:	de b7       	in	r29, 0x3e	; 62
     d62:	8b 83       	std	Y+3, r24	; 0x03
     d64:	9c 83       	std	Y+4, r25	; 0x04
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     d66:	8b 81       	ldd	r24, Y+3	; 0x03
     d68:	9c 81       	ldd	r25, Y+4	; 0x04
     d6a:	fc 01       	movw	r30, r24
     d6c:	82 85       	ldd	r24, Z+10	; 0x0a
     d6e:	93 85       	ldd	r25, Z+11	; 0x0b
     d70:	89 83       	std	Y+1, r24	; 0x01
     d72:	9a 83       	std	Y+2, r25	; 0x02

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     d74:	8b 81       	ldd	r24, Y+3	; 0x03
     d76:	9c 81       	ldd	r25, Y+4	; 0x04
     d78:	fc 01       	movw	r30, r24
     d7a:	84 81       	ldd	r24, Z+4	; 0x04
     d7c:	95 81       	ldd	r25, Z+5	; 0x05
     d7e:	2b 81       	ldd	r18, Y+3	; 0x03
     d80:	3c 81       	ldd	r19, Y+4	; 0x04
     d82:	f9 01       	movw	r30, r18
     d84:	26 81       	ldd	r18, Z+6	; 0x06
     d86:	37 81       	ldd	r19, Z+7	; 0x07
     d88:	fc 01       	movw	r30, r24
     d8a:	26 83       	std	Z+6, r18	; 0x06
     d8c:	37 83       	std	Z+7, r19	; 0x07
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     d8e:	8b 81       	ldd	r24, Y+3	; 0x03
     d90:	9c 81       	ldd	r25, Y+4	; 0x04
     d92:	fc 01       	movw	r30, r24
     d94:	86 81       	ldd	r24, Z+6	; 0x06
     d96:	97 81       	ldd	r25, Z+7	; 0x07
     d98:	2b 81       	ldd	r18, Y+3	; 0x03
     d9a:	3c 81       	ldd	r19, Y+4	; 0x04
     d9c:	f9 01       	movw	r30, r18
     d9e:	24 81       	ldd	r18, Z+4	; 0x04
     da0:	35 81       	ldd	r19, Z+5	; 0x05
     da2:	fc 01       	movw	r30, r24
     da4:	24 83       	std	Z+4, r18	; 0x04
     da6:	35 83       	std	Z+5, r19	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     da8:	89 81       	ldd	r24, Y+1	; 0x01
     daa:	9a 81       	ldd	r25, Y+2	; 0x02
     dac:	fc 01       	movw	r30, r24
     dae:	21 81       	ldd	r18, Z+1	; 0x01
     db0:	32 81       	ldd	r19, Z+2	; 0x02
     db2:	8b 81       	ldd	r24, Y+3	; 0x03
     db4:	9c 81       	ldd	r25, Y+4	; 0x04
     db6:	28 17       	cp	r18, r24
     db8:	39 07       	cpc	r19, r25
     dba:	51 f4       	brne	.+20     	; 0xdd0 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     dbc:	8b 81       	ldd	r24, Y+3	; 0x03
     dbe:	9c 81       	ldd	r25, Y+4	; 0x04
     dc0:	fc 01       	movw	r30, r24
     dc2:	26 81       	ldd	r18, Z+6	; 0x06
     dc4:	37 81       	ldd	r19, Z+7	; 0x07
     dc6:	89 81       	ldd	r24, Y+1	; 0x01
     dc8:	9a 81       	ldd	r25, Y+2	; 0x02
     dca:	fc 01       	movw	r30, r24
     dcc:	21 83       	std	Z+1, r18	; 0x01
     dce:	32 83       	std	Z+2, r19	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     dd0:	8b 81       	ldd	r24, Y+3	; 0x03
     dd2:	9c 81       	ldd	r25, Y+4	; 0x04
     dd4:	fc 01       	movw	r30, r24
     dd6:	12 86       	std	Z+10, r1	; 0x0a
     dd8:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     dda:	89 81       	ldd	r24, Y+1	; 0x01
     ddc:	9a 81       	ldd	r25, Y+2	; 0x02
     dde:	fc 01       	movw	r30, r24
     de0:	80 81       	ld	r24, Z
     de2:	2f ef       	ldi	r18, 0xFF	; 255
     de4:	28 0f       	add	r18, r24
     de6:	89 81       	ldd	r24, Y+1	; 0x01
     de8:	9a 81       	ldd	r25, Y+2	; 0x02
     dea:	fc 01       	movw	r30, r24
     dec:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
     dee:	89 81       	ldd	r24, Y+1	; 0x01
     df0:	9a 81       	ldd	r25, Y+2	; 0x02
     df2:	fc 01       	movw	r30, r24
     df4:	80 81       	ld	r24, Z
}
     df6:	24 96       	adiw	r28, 0x04	; 4
     df8:	cd bf       	out	0x3d, r28	; 61
     dfa:	de bf       	out	0x3e, r29	; 62
     dfc:	df 91       	pop	r29
     dfe:	cf 91       	pop	r28
     e00:	08 95       	ret

00000e02 <_portSetInterruptMaskFromIsr>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     e02:	1f 93       	push	r17
     e04:	cf 93       	push	r28
     e06:	df 93       	push	r29
     e08:	cd b7       	in	r28, 0x3d	; 61
     e0a:	de b7       	in	r29, 0x3e	; 62
     e0c:	80 ea       	ldi	r24, 0xA0	; 160
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	fc 01       	movw	r30, r24
     e12:	82 81       	ldd	r24, Z+2	; 0x02
     e14:	18 2f       	mov	r17, r24
     e16:	80 ea       	ldi	r24, 0xA0	; 160
     e18:	90 e0       	ldi	r25, 0x00	; 0
     e1a:	20 ea       	ldi	r18, 0xA0	; 160
     e1c:	30 e0       	ldi	r19, 0x00	; 0
     e1e:	f9 01       	movw	r30, r18
     e20:	22 81       	ldd	r18, Z+2	; 0x02
     e22:	28 7f       	andi	r18, 0xF8	; 248
     e24:	fc 01       	movw	r30, r24
     e26:	22 83       	std	Z+2, r18	; 0x02
     e28:	81 2f       	mov	r24, r17
     e2a:	df 91       	pop	r29
     e2c:	cf 91       	pop	r28
     e2e:	1f 91       	pop	r17
     e30:	08 95       	ret

00000e32 <pxPortInitialiseStack>:
     e32:	cf 93       	push	r28
     e34:	df 93       	push	r29
     e36:	cd b7       	in	r28, 0x3d	; 61
     e38:	de b7       	in	r29, 0x3e	; 62
     e3a:	2a 97       	sbiw	r28, 0x0a	; 10
     e3c:	cd bf       	out	0x3d, r28	; 61
     e3e:	de bf       	out	0x3e, r29	; 62
     e40:	8d 83       	std	Y+5, r24	; 0x05
     e42:	9e 83       	std	Y+6, r25	; 0x06
     e44:	6f 83       	std	Y+7, r22	; 0x07
     e46:	78 87       	std	Y+8, r23	; 0x08
     e48:	49 87       	std	Y+9, r20	; 0x09
     e4a:	5a 87       	std	Y+10, r21	; 0x0a
     e4c:	8d 81       	ldd	r24, Y+5	; 0x05
     e4e:	9e 81       	ldd	r25, Y+6	; 0x06
     e50:	21 e1       	ldi	r18, 0x11	; 17
     e52:	fc 01       	movw	r30, r24
     e54:	20 83       	st	Z, r18
     e56:	8d 81       	ldd	r24, Y+5	; 0x05
     e58:	9e 81       	ldd	r25, Y+6	; 0x06
     e5a:	01 97       	sbiw	r24, 0x01	; 1
     e5c:	8d 83       	std	Y+5, r24	; 0x05
     e5e:	9e 83       	std	Y+6, r25	; 0x06
     e60:	8d 81       	ldd	r24, Y+5	; 0x05
     e62:	9e 81       	ldd	r25, Y+6	; 0x06
     e64:	22 e2       	ldi	r18, 0x22	; 34
     e66:	fc 01       	movw	r30, r24
     e68:	20 83       	st	Z, r18
     e6a:	8d 81       	ldd	r24, Y+5	; 0x05
     e6c:	9e 81       	ldd	r25, Y+6	; 0x06
     e6e:	01 97       	sbiw	r24, 0x01	; 1
     e70:	8d 83       	std	Y+5, r24	; 0x05
     e72:	9e 83       	std	Y+6, r25	; 0x06
     e74:	8d 81       	ldd	r24, Y+5	; 0x05
     e76:	9e 81       	ldd	r25, Y+6	; 0x06
     e78:	23 e3       	ldi	r18, 0x33	; 51
     e7a:	fc 01       	movw	r30, r24
     e7c:	20 83       	st	Z, r18
     e7e:	8d 81       	ldd	r24, Y+5	; 0x05
     e80:	9e 81       	ldd	r25, Y+6	; 0x06
     e82:	01 97       	sbiw	r24, 0x01	; 1
     e84:	8d 83       	std	Y+5, r24	; 0x05
     e86:	9e 83       	std	Y+6, r25	; 0x06
     e88:	8f 81       	ldd	r24, Y+7	; 0x07
     e8a:	98 85       	ldd	r25, Y+8	; 0x08
     e8c:	cc 01       	movw	r24, r24
     e8e:	a0 e0       	ldi	r26, 0x00	; 0
     e90:	b0 e0       	ldi	r27, 0x00	; 0
     e92:	89 83       	std	Y+1, r24	; 0x01
     e94:	9a 83       	std	Y+2, r25	; 0x02
     e96:	ab 83       	std	Y+3, r26	; 0x03
     e98:	bc 83       	std	Y+4, r27	; 0x04
     e9a:	29 81       	ldd	r18, Y+1	; 0x01
     e9c:	8d 81       	ldd	r24, Y+5	; 0x05
     e9e:	9e 81       	ldd	r25, Y+6	; 0x06
     ea0:	fc 01       	movw	r30, r24
     ea2:	20 83       	st	Z, r18
     ea4:	8d 81       	ldd	r24, Y+5	; 0x05
     ea6:	9e 81       	ldd	r25, Y+6	; 0x06
     ea8:	01 97       	sbiw	r24, 0x01	; 1
     eaa:	8d 83       	std	Y+5, r24	; 0x05
     eac:	9e 83       	std	Y+6, r25	; 0x06
     eae:	89 81       	ldd	r24, Y+1	; 0x01
     eb0:	9a 81       	ldd	r25, Y+2	; 0x02
     eb2:	ab 81       	ldd	r26, Y+3	; 0x03
     eb4:	bc 81       	ldd	r27, Y+4	; 0x04
     eb6:	89 2f       	mov	r24, r25
     eb8:	9a 2f       	mov	r25, r26
     eba:	ab 2f       	mov	r26, r27
     ebc:	bb 27       	eor	r27, r27
     ebe:	89 83       	std	Y+1, r24	; 0x01
     ec0:	9a 83       	std	Y+2, r25	; 0x02
     ec2:	ab 83       	std	Y+3, r26	; 0x03
     ec4:	bc 83       	std	Y+4, r27	; 0x04
     ec6:	29 81       	ldd	r18, Y+1	; 0x01
     ec8:	8d 81       	ldd	r24, Y+5	; 0x05
     eca:	9e 81       	ldd	r25, Y+6	; 0x06
     ecc:	fc 01       	movw	r30, r24
     ece:	20 83       	st	Z, r18
     ed0:	8d 81       	ldd	r24, Y+5	; 0x05
     ed2:	9e 81       	ldd	r25, Y+6	; 0x06
     ed4:	01 97       	sbiw	r24, 0x01	; 1
     ed6:	8d 83       	std	Y+5, r24	; 0x05
     ed8:	9e 83       	std	Y+6, r25	; 0x06
     eda:	89 81       	ldd	r24, Y+1	; 0x01
     edc:	9a 81       	ldd	r25, Y+2	; 0x02
     ede:	ab 81       	ldd	r26, Y+3	; 0x03
     ee0:	bc 81       	ldd	r27, Y+4	; 0x04
     ee2:	89 2f       	mov	r24, r25
     ee4:	9a 2f       	mov	r25, r26
     ee6:	ab 2f       	mov	r26, r27
     ee8:	bb 27       	eor	r27, r27
     eea:	89 83       	std	Y+1, r24	; 0x01
     eec:	9a 83       	std	Y+2, r25	; 0x02
     eee:	ab 83       	std	Y+3, r26	; 0x03
     ef0:	bc 83       	std	Y+4, r27	; 0x04
     ef2:	29 81       	ldd	r18, Y+1	; 0x01
     ef4:	8d 81       	ldd	r24, Y+5	; 0x05
     ef6:	9e 81       	ldd	r25, Y+6	; 0x06
     ef8:	fc 01       	movw	r30, r24
     efa:	20 83       	st	Z, r18
     efc:	8d 81       	ldd	r24, Y+5	; 0x05
     efe:	9e 81       	ldd	r25, Y+6	; 0x06
     f00:	01 97       	sbiw	r24, 0x01	; 1
     f02:	8d 83       	std	Y+5, r24	; 0x05
     f04:	9e 83       	std	Y+6, r25	; 0x06
     f06:	8d 81       	ldd	r24, Y+5	; 0x05
     f08:	9e 81       	ldd	r25, Y+6	; 0x06
     f0a:	21 e3       	ldi	r18, 0x31	; 49
     f0c:	fc 01       	movw	r30, r24
     f0e:	20 83       	st	Z, r18
     f10:	8d 81       	ldd	r24, Y+5	; 0x05
     f12:	9e 81       	ldd	r25, Y+6	; 0x06
     f14:	01 97       	sbiw	r24, 0x01	; 1
     f16:	8d 83       	std	Y+5, r24	; 0x05
     f18:	9e 83       	std	Y+6, r25	; 0x06
     f1a:	8d 81       	ldd	r24, Y+5	; 0x05
     f1c:	9e 81       	ldd	r25, Y+6	; 0x06
     f1e:	20 e8       	ldi	r18, 0x80	; 128
     f20:	fc 01       	movw	r30, r24
     f22:	20 83       	st	Z, r18
     f24:	8d 81       	ldd	r24, Y+5	; 0x05
     f26:	9e 81       	ldd	r25, Y+6	; 0x06
     f28:	01 97       	sbiw	r24, 0x01	; 1
     f2a:	8d 83       	std	Y+5, r24	; 0x05
     f2c:	9e 83       	std	Y+6, r25	; 0x06
     f2e:	8d 81       	ldd	r24, Y+5	; 0x05
     f30:	9e 81       	ldd	r25, Y+6	; 0x06
     f32:	27 e8       	ldi	r18, 0x87	; 135
     f34:	fc 01       	movw	r30, r24
     f36:	20 83       	st	Z, r18
     f38:	8d 81       	ldd	r24, Y+5	; 0x05
     f3a:	9e 81       	ldd	r25, Y+6	; 0x06
     f3c:	01 97       	sbiw	r24, 0x01	; 1
     f3e:	8d 83       	std	Y+5, r24	; 0x05
     f40:	9e 83       	std	Y+6, r25	; 0x06
     f42:	8d 81       	ldd	r24, Y+5	; 0x05
     f44:	9e 81       	ldd	r25, Y+6	; 0x06
     f46:	fc 01       	movw	r30, r24
     f48:	10 82       	st	Z, r1
     f4a:	8d 81       	ldd	r24, Y+5	; 0x05
     f4c:	9e 81       	ldd	r25, Y+6	; 0x06
     f4e:	01 97       	sbiw	r24, 0x01	; 1
     f50:	8d 83       	std	Y+5, r24	; 0x05
     f52:	9e 83       	std	Y+6, r25	; 0x06
     f54:	8d 81       	ldd	r24, Y+5	; 0x05
     f56:	9e 81       	ldd	r25, Y+6	; 0x06
     f58:	fc 01       	movw	r30, r24
     f5a:	10 82       	st	Z, r1
     f5c:	8d 81       	ldd	r24, Y+5	; 0x05
     f5e:	9e 81       	ldd	r25, Y+6	; 0x06
     f60:	01 97       	sbiw	r24, 0x01	; 1
     f62:	8d 83       	std	Y+5, r24	; 0x05
     f64:	9e 83       	std	Y+6, r25	; 0x06
     f66:	8d 81       	ldd	r24, Y+5	; 0x05
     f68:	9e 81       	ldd	r25, Y+6	; 0x06
     f6a:	22 e0       	ldi	r18, 0x02	; 2
     f6c:	fc 01       	movw	r30, r24
     f6e:	20 83       	st	Z, r18
     f70:	8d 81       	ldd	r24, Y+5	; 0x05
     f72:	9e 81       	ldd	r25, Y+6	; 0x06
     f74:	01 97       	sbiw	r24, 0x01	; 1
     f76:	8d 83       	std	Y+5, r24	; 0x05
     f78:	9e 83       	std	Y+6, r25	; 0x06
     f7a:	8d 81       	ldd	r24, Y+5	; 0x05
     f7c:	9e 81       	ldd	r25, Y+6	; 0x06
     f7e:	23 e0       	ldi	r18, 0x03	; 3
     f80:	fc 01       	movw	r30, r24
     f82:	20 83       	st	Z, r18
     f84:	8d 81       	ldd	r24, Y+5	; 0x05
     f86:	9e 81       	ldd	r25, Y+6	; 0x06
     f88:	01 97       	sbiw	r24, 0x01	; 1
     f8a:	8d 83       	std	Y+5, r24	; 0x05
     f8c:	9e 83       	std	Y+6, r25	; 0x06
     f8e:	8d 81       	ldd	r24, Y+5	; 0x05
     f90:	9e 81       	ldd	r25, Y+6	; 0x06
     f92:	24 e0       	ldi	r18, 0x04	; 4
     f94:	fc 01       	movw	r30, r24
     f96:	20 83       	st	Z, r18
     f98:	8d 81       	ldd	r24, Y+5	; 0x05
     f9a:	9e 81       	ldd	r25, Y+6	; 0x06
     f9c:	01 97       	sbiw	r24, 0x01	; 1
     f9e:	8d 83       	std	Y+5, r24	; 0x05
     fa0:	9e 83       	std	Y+6, r25	; 0x06
     fa2:	8d 81       	ldd	r24, Y+5	; 0x05
     fa4:	9e 81       	ldd	r25, Y+6	; 0x06
     fa6:	25 e0       	ldi	r18, 0x05	; 5
     fa8:	fc 01       	movw	r30, r24
     faa:	20 83       	st	Z, r18
     fac:	8d 81       	ldd	r24, Y+5	; 0x05
     fae:	9e 81       	ldd	r25, Y+6	; 0x06
     fb0:	01 97       	sbiw	r24, 0x01	; 1
     fb2:	8d 83       	std	Y+5, r24	; 0x05
     fb4:	9e 83       	std	Y+6, r25	; 0x06
     fb6:	8d 81       	ldd	r24, Y+5	; 0x05
     fb8:	9e 81       	ldd	r25, Y+6	; 0x06
     fba:	26 e0       	ldi	r18, 0x06	; 6
     fbc:	fc 01       	movw	r30, r24
     fbe:	20 83       	st	Z, r18
     fc0:	8d 81       	ldd	r24, Y+5	; 0x05
     fc2:	9e 81       	ldd	r25, Y+6	; 0x06
     fc4:	01 97       	sbiw	r24, 0x01	; 1
     fc6:	8d 83       	std	Y+5, r24	; 0x05
     fc8:	9e 83       	std	Y+6, r25	; 0x06
     fca:	8d 81       	ldd	r24, Y+5	; 0x05
     fcc:	9e 81       	ldd	r25, Y+6	; 0x06
     fce:	27 e0       	ldi	r18, 0x07	; 7
     fd0:	fc 01       	movw	r30, r24
     fd2:	20 83       	st	Z, r18
     fd4:	8d 81       	ldd	r24, Y+5	; 0x05
     fd6:	9e 81       	ldd	r25, Y+6	; 0x06
     fd8:	01 97       	sbiw	r24, 0x01	; 1
     fda:	8d 83       	std	Y+5, r24	; 0x05
     fdc:	9e 83       	std	Y+6, r25	; 0x06
     fde:	8d 81       	ldd	r24, Y+5	; 0x05
     fe0:	9e 81       	ldd	r25, Y+6	; 0x06
     fe2:	28 e0       	ldi	r18, 0x08	; 8
     fe4:	fc 01       	movw	r30, r24
     fe6:	20 83       	st	Z, r18
     fe8:	8d 81       	ldd	r24, Y+5	; 0x05
     fea:	9e 81       	ldd	r25, Y+6	; 0x06
     fec:	01 97       	sbiw	r24, 0x01	; 1
     fee:	8d 83       	std	Y+5, r24	; 0x05
     ff0:	9e 83       	std	Y+6, r25	; 0x06
     ff2:	8d 81       	ldd	r24, Y+5	; 0x05
     ff4:	9e 81       	ldd	r25, Y+6	; 0x06
     ff6:	29 e0       	ldi	r18, 0x09	; 9
     ff8:	fc 01       	movw	r30, r24
     ffa:	20 83       	st	Z, r18
     ffc:	8d 81       	ldd	r24, Y+5	; 0x05
     ffe:	9e 81       	ldd	r25, Y+6	; 0x06
    1000:	01 97       	sbiw	r24, 0x01	; 1
    1002:	8d 83       	std	Y+5, r24	; 0x05
    1004:	9e 83       	std	Y+6, r25	; 0x06
    1006:	8d 81       	ldd	r24, Y+5	; 0x05
    1008:	9e 81       	ldd	r25, Y+6	; 0x06
    100a:	20 e1       	ldi	r18, 0x10	; 16
    100c:	fc 01       	movw	r30, r24
    100e:	20 83       	st	Z, r18
    1010:	8d 81       	ldd	r24, Y+5	; 0x05
    1012:	9e 81       	ldd	r25, Y+6	; 0x06
    1014:	01 97       	sbiw	r24, 0x01	; 1
    1016:	8d 83       	std	Y+5, r24	; 0x05
    1018:	9e 83       	std	Y+6, r25	; 0x06
    101a:	8d 81       	ldd	r24, Y+5	; 0x05
    101c:	9e 81       	ldd	r25, Y+6	; 0x06
    101e:	21 e1       	ldi	r18, 0x11	; 17
    1020:	fc 01       	movw	r30, r24
    1022:	20 83       	st	Z, r18
    1024:	8d 81       	ldd	r24, Y+5	; 0x05
    1026:	9e 81       	ldd	r25, Y+6	; 0x06
    1028:	01 97       	sbiw	r24, 0x01	; 1
    102a:	8d 83       	std	Y+5, r24	; 0x05
    102c:	9e 83       	std	Y+6, r25	; 0x06
    102e:	8d 81       	ldd	r24, Y+5	; 0x05
    1030:	9e 81       	ldd	r25, Y+6	; 0x06
    1032:	22 e1       	ldi	r18, 0x12	; 18
    1034:	fc 01       	movw	r30, r24
    1036:	20 83       	st	Z, r18
    1038:	8d 81       	ldd	r24, Y+5	; 0x05
    103a:	9e 81       	ldd	r25, Y+6	; 0x06
    103c:	01 97       	sbiw	r24, 0x01	; 1
    103e:	8d 83       	std	Y+5, r24	; 0x05
    1040:	9e 83       	std	Y+6, r25	; 0x06
    1042:	8d 81       	ldd	r24, Y+5	; 0x05
    1044:	9e 81       	ldd	r25, Y+6	; 0x06
    1046:	23 e1       	ldi	r18, 0x13	; 19
    1048:	fc 01       	movw	r30, r24
    104a:	20 83       	st	Z, r18
    104c:	8d 81       	ldd	r24, Y+5	; 0x05
    104e:	9e 81       	ldd	r25, Y+6	; 0x06
    1050:	01 97       	sbiw	r24, 0x01	; 1
    1052:	8d 83       	std	Y+5, r24	; 0x05
    1054:	9e 83       	std	Y+6, r25	; 0x06
    1056:	8d 81       	ldd	r24, Y+5	; 0x05
    1058:	9e 81       	ldd	r25, Y+6	; 0x06
    105a:	24 e1       	ldi	r18, 0x14	; 20
    105c:	fc 01       	movw	r30, r24
    105e:	20 83       	st	Z, r18
    1060:	8d 81       	ldd	r24, Y+5	; 0x05
    1062:	9e 81       	ldd	r25, Y+6	; 0x06
    1064:	01 97       	sbiw	r24, 0x01	; 1
    1066:	8d 83       	std	Y+5, r24	; 0x05
    1068:	9e 83       	std	Y+6, r25	; 0x06
    106a:	8d 81       	ldd	r24, Y+5	; 0x05
    106c:	9e 81       	ldd	r25, Y+6	; 0x06
    106e:	25 e1       	ldi	r18, 0x15	; 21
    1070:	fc 01       	movw	r30, r24
    1072:	20 83       	st	Z, r18
    1074:	8d 81       	ldd	r24, Y+5	; 0x05
    1076:	9e 81       	ldd	r25, Y+6	; 0x06
    1078:	01 97       	sbiw	r24, 0x01	; 1
    107a:	8d 83       	std	Y+5, r24	; 0x05
    107c:	9e 83       	std	Y+6, r25	; 0x06
    107e:	8d 81       	ldd	r24, Y+5	; 0x05
    1080:	9e 81       	ldd	r25, Y+6	; 0x06
    1082:	26 e1       	ldi	r18, 0x16	; 22
    1084:	fc 01       	movw	r30, r24
    1086:	20 83       	st	Z, r18
    1088:	8d 81       	ldd	r24, Y+5	; 0x05
    108a:	9e 81       	ldd	r25, Y+6	; 0x06
    108c:	01 97       	sbiw	r24, 0x01	; 1
    108e:	8d 83       	std	Y+5, r24	; 0x05
    1090:	9e 83       	std	Y+6, r25	; 0x06
    1092:	8d 81       	ldd	r24, Y+5	; 0x05
    1094:	9e 81       	ldd	r25, Y+6	; 0x06
    1096:	27 e1       	ldi	r18, 0x17	; 23
    1098:	fc 01       	movw	r30, r24
    109a:	20 83       	st	Z, r18
    109c:	8d 81       	ldd	r24, Y+5	; 0x05
    109e:	9e 81       	ldd	r25, Y+6	; 0x06
    10a0:	01 97       	sbiw	r24, 0x01	; 1
    10a2:	8d 83       	std	Y+5, r24	; 0x05
    10a4:	9e 83       	std	Y+6, r25	; 0x06
    10a6:	8d 81       	ldd	r24, Y+5	; 0x05
    10a8:	9e 81       	ldd	r25, Y+6	; 0x06
    10aa:	28 e1       	ldi	r18, 0x18	; 24
    10ac:	fc 01       	movw	r30, r24
    10ae:	20 83       	st	Z, r18
    10b0:	8d 81       	ldd	r24, Y+5	; 0x05
    10b2:	9e 81       	ldd	r25, Y+6	; 0x06
    10b4:	01 97       	sbiw	r24, 0x01	; 1
    10b6:	8d 83       	std	Y+5, r24	; 0x05
    10b8:	9e 83       	std	Y+6, r25	; 0x06
    10ba:	8d 81       	ldd	r24, Y+5	; 0x05
    10bc:	9e 81       	ldd	r25, Y+6	; 0x06
    10be:	29 e1       	ldi	r18, 0x19	; 25
    10c0:	fc 01       	movw	r30, r24
    10c2:	20 83       	st	Z, r18
    10c4:	8d 81       	ldd	r24, Y+5	; 0x05
    10c6:	9e 81       	ldd	r25, Y+6	; 0x06
    10c8:	01 97       	sbiw	r24, 0x01	; 1
    10ca:	8d 83       	std	Y+5, r24	; 0x05
    10cc:	9e 83       	std	Y+6, r25	; 0x06
    10ce:	8d 81       	ldd	r24, Y+5	; 0x05
    10d0:	9e 81       	ldd	r25, Y+6	; 0x06
    10d2:	20 e2       	ldi	r18, 0x20	; 32
    10d4:	fc 01       	movw	r30, r24
    10d6:	20 83       	st	Z, r18
    10d8:	8d 81       	ldd	r24, Y+5	; 0x05
    10da:	9e 81       	ldd	r25, Y+6	; 0x06
    10dc:	01 97       	sbiw	r24, 0x01	; 1
    10de:	8d 83       	std	Y+5, r24	; 0x05
    10e0:	9e 83       	std	Y+6, r25	; 0x06
    10e2:	8d 81       	ldd	r24, Y+5	; 0x05
    10e4:	9e 81       	ldd	r25, Y+6	; 0x06
    10e6:	21 e2       	ldi	r18, 0x21	; 33
    10e8:	fc 01       	movw	r30, r24
    10ea:	20 83       	st	Z, r18
    10ec:	8d 81       	ldd	r24, Y+5	; 0x05
    10ee:	9e 81       	ldd	r25, Y+6	; 0x06
    10f0:	01 97       	sbiw	r24, 0x01	; 1
    10f2:	8d 83       	std	Y+5, r24	; 0x05
    10f4:	9e 83       	std	Y+6, r25	; 0x06
    10f6:	8d 81       	ldd	r24, Y+5	; 0x05
    10f8:	9e 81       	ldd	r25, Y+6	; 0x06
    10fa:	22 e2       	ldi	r18, 0x22	; 34
    10fc:	fc 01       	movw	r30, r24
    10fe:	20 83       	st	Z, r18
    1100:	8d 81       	ldd	r24, Y+5	; 0x05
    1102:	9e 81       	ldd	r25, Y+6	; 0x06
    1104:	01 97       	sbiw	r24, 0x01	; 1
    1106:	8d 83       	std	Y+5, r24	; 0x05
    1108:	9e 83       	std	Y+6, r25	; 0x06
    110a:	8d 81       	ldd	r24, Y+5	; 0x05
    110c:	9e 81       	ldd	r25, Y+6	; 0x06
    110e:	23 e2       	ldi	r18, 0x23	; 35
    1110:	fc 01       	movw	r30, r24
    1112:	20 83       	st	Z, r18
    1114:	8d 81       	ldd	r24, Y+5	; 0x05
    1116:	9e 81       	ldd	r25, Y+6	; 0x06
    1118:	01 97       	sbiw	r24, 0x01	; 1
    111a:	8d 83       	std	Y+5, r24	; 0x05
    111c:	9e 83       	std	Y+6, r25	; 0x06
    111e:	89 85       	ldd	r24, Y+9	; 0x09
    1120:	9a 85       	ldd	r25, Y+10	; 0x0a
    1122:	cc 01       	movw	r24, r24
    1124:	a0 e0       	ldi	r26, 0x00	; 0
    1126:	b0 e0       	ldi	r27, 0x00	; 0
    1128:	89 83       	std	Y+1, r24	; 0x01
    112a:	9a 83       	std	Y+2, r25	; 0x02
    112c:	ab 83       	std	Y+3, r26	; 0x03
    112e:	bc 83       	std	Y+4, r27	; 0x04
    1130:	29 81       	ldd	r18, Y+1	; 0x01
    1132:	8d 81       	ldd	r24, Y+5	; 0x05
    1134:	9e 81       	ldd	r25, Y+6	; 0x06
    1136:	fc 01       	movw	r30, r24
    1138:	20 83       	st	Z, r18
    113a:	8d 81       	ldd	r24, Y+5	; 0x05
    113c:	9e 81       	ldd	r25, Y+6	; 0x06
    113e:	01 97       	sbiw	r24, 0x01	; 1
    1140:	8d 83       	std	Y+5, r24	; 0x05
    1142:	9e 83       	std	Y+6, r25	; 0x06
    1144:	89 81       	ldd	r24, Y+1	; 0x01
    1146:	9a 81       	ldd	r25, Y+2	; 0x02
    1148:	ab 81       	ldd	r26, Y+3	; 0x03
    114a:	bc 81       	ldd	r27, Y+4	; 0x04
    114c:	89 2f       	mov	r24, r25
    114e:	9a 2f       	mov	r25, r26
    1150:	ab 2f       	mov	r26, r27
    1152:	bb 27       	eor	r27, r27
    1154:	89 83       	std	Y+1, r24	; 0x01
    1156:	9a 83       	std	Y+2, r25	; 0x02
    1158:	ab 83       	std	Y+3, r26	; 0x03
    115a:	bc 83       	std	Y+4, r27	; 0x04
    115c:	29 81       	ldd	r18, Y+1	; 0x01
    115e:	8d 81       	ldd	r24, Y+5	; 0x05
    1160:	9e 81       	ldd	r25, Y+6	; 0x06
    1162:	fc 01       	movw	r30, r24
    1164:	20 83       	st	Z, r18
    1166:	8d 81       	ldd	r24, Y+5	; 0x05
    1168:	9e 81       	ldd	r25, Y+6	; 0x06
    116a:	01 97       	sbiw	r24, 0x01	; 1
    116c:	8d 83       	std	Y+5, r24	; 0x05
    116e:	9e 83       	std	Y+6, r25	; 0x06
    1170:	8d 81       	ldd	r24, Y+5	; 0x05
    1172:	9e 81       	ldd	r25, Y+6	; 0x06
    1174:	26 e2       	ldi	r18, 0x26	; 38
    1176:	fc 01       	movw	r30, r24
    1178:	20 83       	st	Z, r18
    117a:	8d 81       	ldd	r24, Y+5	; 0x05
    117c:	9e 81       	ldd	r25, Y+6	; 0x06
    117e:	01 97       	sbiw	r24, 0x01	; 1
    1180:	8d 83       	std	Y+5, r24	; 0x05
    1182:	9e 83       	std	Y+6, r25	; 0x06
    1184:	8d 81       	ldd	r24, Y+5	; 0x05
    1186:	9e 81       	ldd	r25, Y+6	; 0x06
    1188:	27 e2       	ldi	r18, 0x27	; 39
    118a:	fc 01       	movw	r30, r24
    118c:	20 83       	st	Z, r18
    118e:	8d 81       	ldd	r24, Y+5	; 0x05
    1190:	9e 81       	ldd	r25, Y+6	; 0x06
    1192:	01 97       	sbiw	r24, 0x01	; 1
    1194:	8d 83       	std	Y+5, r24	; 0x05
    1196:	9e 83       	std	Y+6, r25	; 0x06
    1198:	8d 81       	ldd	r24, Y+5	; 0x05
    119a:	9e 81       	ldd	r25, Y+6	; 0x06
    119c:	28 e2       	ldi	r18, 0x28	; 40
    119e:	fc 01       	movw	r30, r24
    11a0:	20 83       	st	Z, r18
    11a2:	8d 81       	ldd	r24, Y+5	; 0x05
    11a4:	9e 81       	ldd	r25, Y+6	; 0x06
    11a6:	01 97       	sbiw	r24, 0x01	; 1
    11a8:	8d 83       	std	Y+5, r24	; 0x05
    11aa:	9e 83       	std	Y+6, r25	; 0x06
    11ac:	8d 81       	ldd	r24, Y+5	; 0x05
    11ae:	9e 81       	ldd	r25, Y+6	; 0x06
    11b0:	29 e2       	ldi	r18, 0x29	; 41
    11b2:	fc 01       	movw	r30, r24
    11b4:	20 83       	st	Z, r18
    11b6:	8d 81       	ldd	r24, Y+5	; 0x05
    11b8:	9e 81       	ldd	r25, Y+6	; 0x06
    11ba:	01 97       	sbiw	r24, 0x01	; 1
    11bc:	8d 83       	std	Y+5, r24	; 0x05
    11be:	9e 83       	std	Y+6, r25	; 0x06
    11c0:	8d 81       	ldd	r24, Y+5	; 0x05
    11c2:	9e 81       	ldd	r25, Y+6	; 0x06
    11c4:	20 e3       	ldi	r18, 0x30	; 48
    11c6:	fc 01       	movw	r30, r24
    11c8:	20 83       	st	Z, r18
    11ca:	8d 81       	ldd	r24, Y+5	; 0x05
    11cc:	9e 81       	ldd	r25, Y+6	; 0x06
    11ce:	01 97       	sbiw	r24, 0x01	; 1
    11d0:	8d 83       	std	Y+5, r24	; 0x05
    11d2:	9e 83       	std	Y+6, r25	; 0x06
    11d4:	8d 81       	ldd	r24, Y+5	; 0x05
    11d6:	9e 81       	ldd	r25, Y+6	; 0x06
    11d8:	2a 96       	adiw	r28, 0x0a	; 10
    11da:	cd bf       	out	0x3d, r28	; 61
    11dc:	de bf       	out	0x3e, r29	; 62
    11de:	df 91       	pop	r29
    11e0:	cf 91       	pop	r28
    11e2:	08 95       	ret

000011e4 <xPortStartScheduler>:
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	cd b7       	in	r28, 0x3d	; 61
    11ea:	de b7       	in	r29, 0x3e	; 62
    11ec:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <prvSetupTimerInterrupt>
    11f0:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    11f4:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    11f8:	0d 90       	ld	r0, X+
    11fa:	0d be       	out	0x3d, r0	; 61
    11fc:	0d 90       	ld	r0, X+
    11fe:	0e be       	out	0x3e, r0	; 62
    1200:	ef 91       	pop	r30
    1202:	df 91       	pop	r29
    1204:	cf 91       	pop	r28
    1206:	bf 91       	pop	r27
    1208:	af 91       	pop	r26
    120a:	9f 91       	pop	r25
    120c:	8f 91       	pop	r24
    120e:	7f 91       	pop	r23
    1210:	6f 91       	pop	r22
    1212:	5f 91       	pop	r21
    1214:	4f 91       	pop	r20
    1216:	3f 91       	pop	r19
    1218:	2f 91       	pop	r18
    121a:	1f 91       	pop	r17
    121c:	0f 91       	pop	r16
    121e:	ff 90       	pop	r15
    1220:	ef 90       	pop	r14
    1222:	df 90       	pop	r13
    1224:	cf 90       	pop	r12
    1226:	bf 90       	pop	r11
    1228:	af 90       	pop	r10
    122a:	9f 90       	pop	r9
    122c:	8f 90       	pop	r8
    122e:	7f 90       	pop	r7
    1230:	6f 90       	pop	r6
    1232:	5f 90       	pop	r5
    1234:	4f 90       	pop	r4
    1236:	3f 90       	pop	r3
    1238:	2f 90       	pop	r2
    123a:	1f 90       	pop	r1
    123c:	0f 90       	pop	r0
    123e:	ff 91       	pop	r31
    1240:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1244:	ff 91       	pop	r31
    1246:	ff bf       	out	0x3f, r31	; 63
    1248:	ff 91       	pop	r31
    124a:	08 95       	ret
    124c:	81 e0       	ldi	r24, 0x01	; 1
    124e:	df 91       	pop	r29
    1250:	cf 91       	pop	r28
    1252:	08 95       	ret

00001254 <vPortYield>:
// 
//
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1254:	ff 93       	push	r31
    1256:	ff b7       	in	r31, 0x3f	; 63
    1258:	ff 93       	push	r31
    125a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    125e:	ff 93       	push	r31
    1260:	f8 7f       	andi	r31, 0xF8	; 248
    1262:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1266:	0f 92       	push	r0
    1268:	1f 92       	push	r1
    126a:	11 24       	eor	r1, r1
    126c:	2f 92       	push	r2
    126e:	3f 92       	push	r3
    1270:	4f 92       	push	r4
    1272:	5f 92       	push	r5
    1274:	6f 92       	push	r6
    1276:	7f 92       	push	r7
    1278:	8f 92       	push	r8
    127a:	9f 92       	push	r9
    127c:	af 92       	push	r10
    127e:	bf 92       	push	r11
    1280:	cf 92       	push	r12
    1282:	df 92       	push	r13
    1284:	ef 92       	push	r14
    1286:	ff 92       	push	r15
    1288:	0f 93       	push	r16
    128a:	1f 93       	push	r17
    128c:	2f 93       	push	r18
    128e:	3f 93       	push	r19
    1290:	4f 93       	push	r20
    1292:	5f 93       	push	r21
    1294:	6f 93       	push	r22
    1296:	7f 93       	push	r23
    1298:	8f 93       	push	r24
    129a:	9f 93       	push	r25
    129c:	af 93       	push	r26
    129e:	bf 93       	push	r27
    12a0:	cf 93       	push	r28
    12a2:	df 93       	push	r29
    12a4:	ef 93       	push	r30
    12a6:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    12aa:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    12ae:	0d b6       	in	r0, 0x3d	; 61
    12b0:	0d 92       	st	X+, r0
    12b2:	0e b6       	in	r0, 0x3e	; 62
    12b4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    12b6:	0e 94 6f 11 	call	0x22de	; 0x22de <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    12ba:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    12be:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    12c2:	0d 90       	ld	r0, X+
    12c4:	0d be       	out	0x3d, r0	; 61
    12c6:	0d 90       	ld	r0, X+
    12c8:	0e be       	out	0x3e, r0	; 62
    12ca:	ef 91       	pop	r30
    12cc:	df 91       	pop	r29
    12ce:	cf 91       	pop	r28
    12d0:	bf 91       	pop	r27
    12d2:	af 91       	pop	r26
    12d4:	9f 91       	pop	r25
    12d6:	8f 91       	pop	r24
    12d8:	7f 91       	pop	r23
    12da:	6f 91       	pop	r22
    12dc:	5f 91       	pop	r21
    12de:	4f 91       	pop	r20
    12e0:	3f 91       	pop	r19
    12e2:	2f 91       	pop	r18
    12e4:	1f 91       	pop	r17
    12e6:	0f 91       	pop	r16
    12e8:	ff 90       	pop	r15
    12ea:	ef 90       	pop	r14
    12ec:	df 90       	pop	r13
    12ee:	cf 90       	pop	r12
    12f0:	bf 90       	pop	r11
    12f2:	af 90       	pop	r10
    12f4:	9f 90       	pop	r9
    12f6:	8f 90       	pop	r8
    12f8:	7f 90       	pop	r7
    12fa:	6f 90       	pop	r6
    12fc:	5f 90       	pop	r5
    12fe:	4f 90       	pop	r4
    1300:	3f 90       	pop	r3
    1302:	2f 90       	pop	r2
    1304:	1f 90       	pop	r1
    1306:	0f 90       	pop	r0
    1308:	ff 91       	pop	r31
    130a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    130e:	ff 91       	pop	r31
    1310:	ff bf       	out	0x3f, r31	; 63
    1312:	ff 91       	pop	r31
	asm volatile ( "ret" );
    1314:	08 95       	ret
	...

00001318 <portTaskSwitchContext>:
	//-----------------------------------------------------------
	//
	// The task switch is deferred until there is no more nesting.
	//
	void portTaskSwitchContext(signed portBASE_TYPE xSwitchRequired)
	{
    1318:	1f 93       	push	r17
    131a:	cf 93       	push	r28
    131c:	df 93       	push	r29
    131e:	1f 92       	push	r1
    1320:	cd b7       	in	r28, 0x3d	; 61
    1322:	de b7       	in	r29, 0x3e	; 62
    1324:	89 83       	std	Y+1, r24	; 0x01
		intTaskSwitchPending |= xSwitchRequired;					
    1326:	80 91 38 2c 	lds	r24, 0x2C38	; 0x802c38 <intTaskSwitchPending>
    132a:	98 2f       	mov	r25, r24
    132c:	89 81       	ldd	r24, Y+1	; 0x01
    132e:	89 2b       	or	r24, r25
    1330:	80 93 38 2c 	sts	0x2C38, r24	; 0x802c38 <intTaskSwitchPending>
																
		if(NOT_NESTING() && intTaskSwitchPending)					
    1334:	80 ea       	ldi	r24, 0xA0	; 160
    1336:	90 e0       	ldi	r25, 0x00	; 0
    1338:	fc 01       	movw	r30, r24
    133a:	80 81       	ld	r24, Z
    133c:	81 30       	cpi	r24, 0x01	; 1
    133e:	61 f0       	breq	.+24     	; 0x1358 <portTaskSwitchContext+0x40>
    1340:	80 ea       	ldi	r24, 0xA0	; 160
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	fc 01       	movw	r30, r24
    1346:	80 81       	ld	r24, Z
    1348:	82 30       	cpi	r24, 0x02	; 2
    134a:	31 f0       	breq	.+12     	; 0x1358 <portTaskSwitchContext+0x40>
    134c:	80 ea       	ldi	r24, 0xA0	; 160
    134e:	90 e0       	ldi	r25, 0x00	; 0
    1350:	fc 01       	movw	r30, r24
    1352:	80 81       	ld	r24, Z
    1354:	84 30       	cpi	r24, 0x04	; 4
    1356:	e1 f4       	brne	.+56     	; 0x1390 <portTaskSwitchContext+0x78>
    1358:	80 91 38 2c 	lds	r24, 0x2C38	; 0x802c38 <intTaskSwitchPending>
    135c:	88 23       	and	r24, r24
    135e:	c1 f0       	breq	.+48     	; 0x1390 <portTaskSwitchContext+0x78>
// Higher interrupts are still active and not locked out.
//
portBASE_TYPE _portSetInterruptMaskFromIsr(void) __attribute__((always_inline));
portBASE_TYPE _portSetInterruptMaskFromIsr(void)
{
	register portBASE_TYPE r = PMIC.CTRL;
    1360:	80 ea       	ldi	r24, 0xA0	; 160
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	fc 01       	movw	r30, r24
    1366:	82 81       	ldd	r24, Z+2	; 0x02
    1368:	18 2f       	mov	r17, r24
	PMIC.CTRL &= ~PMIC_BITS;
    136a:	80 ea       	ldi	r24, 0xA0	; 160
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	20 ea       	ldi	r18, 0xA0	; 160
    1370:	30 e0       	ldi	r19, 0x00	; 0
    1372:	f9 01       	movw	r30, r18
    1374:	22 81       	ldd	r18, Z+2	; 0x02
    1376:	28 7f       	andi	r18, 0xF8	; 248
    1378:	fc 01       	movw	r30, r24
    137a:	22 83       	std	Z+2, r18	; 0x02
	return r;
    137c:	81 2f       	mov	r24, r17
		{															
			register unsigned portBASE_TYPE uxSavedPmicCtrlReg; 				
			extern void vTaskSwitchContext(void);   				
																
			// Critical section used, because vTaskSwitchContext handles FreeRTOS internal data structures.
 			uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR(); 
    137e:	18 2f       	mov	r17, r24
			intTaskSwitchPending = 0;								
    1380:	10 92 38 2c 	sts	0x2C38, r1	; 0x802c38 <intTaskSwitchPending>
			vTaskSwitchContext();                   				
    1384:	0e 94 6f 11 	call	0x22de	; 0x22de <vTaskSwitchContext>
			portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedPmicCtrlReg);
    1388:	80 ea       	ldi	r24, 0xA0	; 160
    138a:	90 e0       	ldi	r25, 0x00	; 0
    138c:	fc 01       	movw	r30, r24
    138e:	12 83       	std	Z+2, r17	; 0x02
		}                                          					
	}
    1390:	00 00       	nop
    1392:	0f 90       	pop	r0
    1394:	df 91       	pop	r29
    1396:	cf 91       	pop	r28
    1398:	1f 91       	pop	r17
    139a:	08 95       	ret

0000139c <portTaskIncrementTick>:
	// This routine is only an indirect call to vTaskIncrementTick because
	// a local variable is necessary. Local variables cannot be used directly
	// in a naked isr because of the lack of the frame pointer.
	//
	static void portTaskIncrementTick( void )
	{
    139c:	1f 93       	push	r17
    139e:	cf 93       	push	r28
    13a0:	df 93       	push	r29
    13a2:	cd b7       	in	r28, 0x3d	; 61
    13a4:	de b7       	in	r29, 0x3e	; 62
// Higher interrupts are still active and not locked out.
//
portBASE_TYPE _portSetInterruptMaskFromIsr(void) __attribute__((always_inline));
portBASE_TYPE _portSetInterruptMaskFromIsr(void)
{
	register portBASE_TYPE r = PMIC.CTRL;
    13a6:	80 ea       	ldi	r24, 0xA0	; 160
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	fc 01       	movw	r30, r24
    13ac:	82 81       	ldd	r24, Z+2	; 0x02
    13ae:	18 2f       	mov	r17, r24
	PMIC.CTRL &= ~PMIC_BITS;
    13b0:	80 ea       	ldi	r24, 0xA0	; 160
    13b2:	90 e0       	ldi	r25, 0x00	; 0
    13b4:	20 ea       	ldi	r18, 0xA0	; 160
    13b6:	30 e0       	ldi	r19, 0x00	; 0
    13b8:	f9 01       	movw	r30, r18
    13ba:	22 81       	ldd	r18, Z+2	; 0x02
    13bc:	28 7f       	andi	r18, 0xF8	; 248
    13be:	fc 01       	movw	r30, r24
    13c0:	22 83       	std	Z+2, r18	; 0x02
	return r;
    13c2:	81 2f       	mov	r24, r17
	//
	static void portTaskIncrementTick( void )
	{
		register unsigned portBASE_TYPE uxSavedPmicCtrlReg;

 		uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR();
    13c4:	18 2f       	mov	r17, r24
		xTaskIncrementTick();
    13c6:	0e 94 5f 10 	call	0x20be	; 0x20be <xTaskIncrementTick>
 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedPmicCtrlReg );
    13ca:	80 ea       	ldi	r24, 0xA0	; 160
    13cc:	90 e0       	ldi	r25, 0x00	; 0
    13ce:	fc 01       	movw	r30, r24
    13d0:	12 83       	std	Z+2, r17	; 0x02
	}
    13d2:	00 00       	nop
    13d4:	df 91       	pop	r29
    13d6:	cf 91       	pop	r28
    13d8:	1f 91       	pop	r17
    13da:	08 95       	ret

000013dc <__vector_14>:
	// the context is saved at the start of vPortYieldFromTick().  The tick
	// count is incremented after the context is saved.
	//
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
    13dc:	ff 93       	push	r31
    13de:	ff b7       	in	r31, 0x3f	; 63
    13e0:	ff 93       	push	r31
    13e2:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13e6:	ff 93       	push	r31
    13e8:	f8 7f       	andi	r31, 0xF8	; 248
    13ea:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13ee:	0f 92       	push	r0
    13f0:	1f 92       	push	r1
    13f2:	11 24       	eor	r1, r1
    13f4:	2f 92       	push	r2
    13f6:	3f 92       	push	r3
    13f8:	4f 92       	push	r4
    13fa:	5f 92       	push	r5
    13fc:	6f 92       	push	r6
    13fe:	7f 92       	push	r7
    1400:	8f 92       	push	r8
    1402:	9f 92       	push	r9
    1404:	af 92       	push	r10
    1406:	bf 92       	push	r11
    1408:	cf 92       	push	r12
    140a:	df 92       	push	r13
    140c:	ef 92       	push	r14
    140e:	ff 92       	push	r15
    1410:	0f 93       	push	r16
    1412:	1f 93       	push	r17
    1414:	2f 93       	push	r18
    1416:	3f 93       	push	r19
    1418:	4f 93       	push	r20
    141a:	5f 93       	push	r21
    141c:	6f 93       	push	r22
    141e:	7f 93       	push	r23
    1420:	8f 93       	push	r24
    1422:	9f 93       	push	r25
    1424:	af 93       	push	r26
    1426:	bf 93       	push	r27
    1428:	cf 93       	push	r28
    142a:	df 93       	push	r29
    142c:	ef 93       	push	r30
    142e:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    1432:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    1436:	0d b6       	in	r0, 0x3d	; 61
    1438:	0d 92       	st	X+, r0
    143a:	0e b6       	in	r0, 0x3e	; 62
    143c:	0d 92       	st	X+, r0
		portTaskIncrementTick();
    143e:	0e 94 ce 09 	call	0x139c	; 0x139c <portTaskIncrementTick>
		//always try a task switch, but only if on kernel interrupt level
		portEND_SWITCHING_ISR(pdTRUE); 
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	0e 94 8c 09 	call	0x1318	; 0x1318 <portTaskSwitchContext>
    1448:	a0 91 c8 2b 	lds	r26, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    144c:	b0 91 c9 2b 	lds	r27, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    1450:	0d 90       	ld	r0, X+
    1452:	0d be       	out	0x3d, r0	; 61
    1454:	0d 90       	ld	r0, X+
    1456:	0e be       	out	0x3e, r0	; 62
    1458:	ef 91       	pop	r30
    145a:	df 91       	pop	r29
    145c:	cf 91       	pop	r28
    145e:	bf 91       	pop	r27
    1460:	af 91       	pop	r26
    1462:	9f 91       	pop	r25
    1464:	8f 91       	pop	r24
    1466:	7f 91       	pop	r23
    1468:	6f 91       	pop	r22
    146a:	5f 91       	pop	r21
    146c:	4f 91       	pop	r20
    146e:	3f 91       	pop	r19
    1470:	2f 91       	pop	r18
    1472:	1f 91       	pop	r17
    1474:	0f 91       	pop	r16
    1476:	ff 90       	pop	r15
    1478:	ef 90       	pop	r14
    147a:	df 90       	pop	r13
    147c:	cf 90       	pop	r12
    147e:	bf 90       	pop	r11
    1480:	af 90       	pop	r10
    1482:	9f 90       	pop	r9
    1484:	8f 90       	pop	r8
    1486:	7f 90       	pop	r7
    1488:	6f 90       	pop	r6
    148a:	5f 90       	pop	r5
    148c:	4f 90       	pop	r4
    148e:	3f 90       	pop	r3
    1490:	2f 90       	pop	r2
    1492:	1f 90       	pop	r1
    1494:	0f 90       	pop	r0
    1496:	ff 91       	pop	r31
    1498:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    149c:	ff 91       	pop	r31
    149e:	ff bf       	out	0x3f, r31	; 63
    14a0:	ff 91       	pop	r31
    14a2:	18 95       	reti
	...

000014a6 <prvSetupTimerInterrupt>:
//-----------------------------------------------------------
//
// Setup of 16bit timer C0 to generate a tick interrupt in case of overflow.
//
static void prvSetupTimerInterrupt( void )
{
    14a6:	cf 93       	push	r28
    14a8:	df 93       	push	r29
    14aa:	00 d0       	rcall	.+0      	; 0x14ac <prvSetupTimerInterrupt+0x6>
    14ac:	1f 92       	push	r1
    14ae:	cd b7       	in	r28, 0x3d	; 61
    14b0:	de b7       	in	r29, 0x3e	; 62

	unsigned portLONG ulOvfMatch;

	ulOvfMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    14b2:	80 e0       	ldi	r24, 0x00	; 0
    14b4:	9d e7       	ldi	r25, 0x7D	; 125
    14b6:	a0 e0       	ldi	r26, 0x00	; 0
    14b8:	b0 e0       	ldi	r27, 0x00	; 0
    14ba:	89 83       	std	Y+1, r24	; 0x01
    14bc:	9a 83       	std	Y+2, r25	; 0x02
    14be:	ab 83       	std	Y+3, r26	; 0x03
    14c0:	bc 83       	std	Y+4, r27	; 0x04

	// We only have 16bits so have to scale to get our required tick rate.
	ulOvfMatch /= portCLOCK_PRESCALER_TIMER0;
    14c2:	89 81       	ldd	r24, Y+1	; 0x01
    14c4:	9a 81       	ldd	r25, Y+2	; 0x02
    14c6:	ab 81       	ldd	r26, Y+3	; 0x03
    14c8:	bc 81       	ldd	r27, Y+4	; 0x04
    14ca:	68 94       	set
    14cc:	15 f8       	bld	r1, 5
    14ce:	b6 95       	lsr	r27
    14d0:	a7 95       	ror	r26
    14d2:	97 95       	ror	r25
    14d4:	87 95       	ror	r24
    14d6:	16 94       	lsr	r1
    14d8:	d1 f7       	brne	.-12     	; 0x14ce <prvSetupTimerInterrupt+0x28>
    14da:	89 83       	std	Y+1, r24	; 0x01
    14dc:	9a 83       	std	Y+2, r25	; 0x02
    14de:	ab 83       	std	Y+3, r26	; 0x03
    14e0:	bc 83       	std	Y+4, r27	; 0x04

	// Adjust for correct value. (because overflow clear if CNT > PER)
	ulOvfMatch -= ( unsigned portLONG ) 1;
    14e2:	89 81       	ldd	r24, Y+1	; 0x01
    14e4:	9a 81       	ldd	r25, Y+2	; 0x02
    14e6:	ab 81       	ldd	r26, Y+3	; 0x03
    14e8:	bc 81       	ldd	r27, Y+4	; 0x04
    14ea:	01 97       	sbiw	r24, 0x01	; 1
    14ec:	a1 09       	sbc	r26, r1
    14ee:	b1 09       	sbc	r27, r1
    14f0:	89 83       	std	Y+1, r24	; 0x01
    14f2:	9a 83       	std	Y+2, r25	; 0x02
    14f4:	ab 83       	std	Y+3, r26	; 0x03
    14f6:	bc 83       	std	Y+4, r27	; 0x04

	// Setup overflow value
	TC_SetPeriod( &TCC0, ulOvfMatch);
    14f8:	80 e0       	ldi	r24, 0x00	; 0
    14fa:	98 e0       	ldi	r25, 0x08	; 8
    14fc:	29 81       	ldd	r18, Y+1	; 0x01
    14fe:	3a 81       	ldd	r19, Y+2	; 0x02
    1500:	fc 01       	movw	r30, r24
    1502:	26 a3       	std	Z+38, r18	; 0x26
    1504:	37 a3       	std	Z+39, r19	; 0x27
		
	// Setup clock source and compare match behaviour.
	TC0_ConfigClockSource( &TCC0, TC_CLKSEL_DIV64_gc);
    1506:	65 e0       	ldi	r22, 0x05	; 5
    1508:	80 e0       	ldi	r24, 0x00	; 0
    150a:	98 e0       	ldi	r25, 0x08	; 8
    150c:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <TC0_ConfigClockSource>

	// Enable the interrupt - this is okay as interrupts are currently globally disabled.
	// The tick interrupt may run in one of the three levels.
#if   configKERNEL_INTERRUPT_PRIORITY == 0
	TC0_SetOverflowIntLevel( &TCC0, TC_OVFINTLVL_LO_gc);	//low interrupt priority
    1510:	61 e0       	ldi	r22, 0x01	; 1
    1512:	80 e0       	ldi	r24, 0x00	; 0
    1514:	98 e0       	ldi	r25, 0x08	; 8
    1516:	0e 94 0d 05 	call	0xa1a	; 0xa1a <TC0_SetOverflowIntLevel>
#elif configKERNEL_INTERRUPT_PRIORITY == 1
	TC0_SetOverflowIntLevel( &TCC0, TC_OVFINTLVL_MED_gc);	//medium interrupt priority
#elif configKERNEL_INTERRUPT_PRIORITY == 2
	TC0_SetOverflowIntLevel( &TCC0, TC_OVFINTLVL_HI_gc);	//high interrupt priority
#endif
}
    151a:	00 00       	nop
    151c:	24 96       	adiw	r28, 0x04	; 4
    151e:	cd bf       	out	0x3d, r28	; 61
    1520:	de bf       	out	0x3e, r29	; 62
    1522:	df 91       	pop	r29
    1524:	cf 91       	pop	r28
    1526:	08 95       	ret

00001528 <xQueueGenericReset>:
#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
		return ( ( Queue_t * ) xQueue )->ucQueueType;
	}
    1528:	cf 93       	push	r28
    152a:	df 93       	push	r29
    152c:	cd b7       	in	r28, 0x3d	; 61
    152e:	de b7       	in	r29, 0x3e	; 62
    1530:	25 97       	sbiw	r28, 0x05	; 5
    1532:	cd bf       	out	0x3d, r28	; 61
    1534:	de bf       	out	0x3e, r29	; 62
    1536:	8b 83       	std	Y+3, r24	; 0x03
    1538:	9c 83       	std	Y+4, r25	; 0x04
    153a:	6d 83       	std	Y+5, r22	; 0x05
    153c:	8b 81       	ldd	r24, Y+3	; 0x03
    153e:	9c 81       	ldd	r25, Y+4	; 0x04
    1540:	89 83       	std	Y+1, r24	; 0x01
    1542:	9a 83       	std	Y+2, r25	; 0x02
    1544:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1548:	ff 93       	push	r31
    154a:	f8 7f       	andi	r31, 0xF8	; 248
    154c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1550:	89 81       	ldd	r24, Y+1	; 0x01
    1552:	9a 81       	ldd	r25, Y+2	; 0x02
    1554:	fc 01       	movw	r30, r24
    1556:	80 81       	ld	r24, Z
    1558:	91 81       	ldd	r25, Z+1	; 0x01
    155a:	29 81       	ldd	r18, Y+1	; 0x01
    155c:	3a 81       	ldd	r19, Y+2	; 0x02
    155e:	f9 01       	movw	r30, r18
    1560:	27 8d       	ldd	r18, Z+31	; 0x1f
    1562:	42 2f       	mov	r20, r18
    1564:	50 e0       	ldi	r21, 0x00	; 0
    1566:	29 81       	ldd	r18, Y+1	; 0x01
    1568:	3a 81       	ldd	r19, Y+2	; 0x02
    156a:	f9 01       	movw	r30, r18
    156c:	20 a1       	ldd	r18, Z+32	; 0x20
    156e:	22 2f       	mov	r18, r18
    1570:	30 e0       	ldi	r19, 0x00	; 0
    1572:	42 9f       	mul	r20, r18
    1574:	b0 01       	movw	r22, r0
    1576:	43 9f       	mul	r20, r19
    1578:	70 0d       	add	r23, r0
    157a:	52 9f       	mul	r21, r18
    157c:	70 0d       	add	r23, r0
    157e:	11 24       	eor	r1, r1
    1580:	9b 01       	movw	r18, r22
    1582:	28 0f       	add	r18, r24
    1584:	39 1f       	adc	r19, r25
    1586:	89 81       	ldd	r24, Y+1	; 0x01
    1588:	9a 81       	ldd	r25, Y+2	; 0x02
    158a:	fc 01       	movw	r30, r24
    158c:	22 83       	std	Z+2, r18	; 0x02
    158e:	33 83       	std	Z+3, r19	; 0x03
    1590:	89 81       	ldd	r24, Y+1	; 0x01
    1592:	9a 81       	ldd	r25, Y+2	; 0x02
    1594:	fc 01       	movw	r30, r24
    1596:	16 8e       	std	Z+30, r1	; 0x1e
    1598:	89 81       	ldd	r24, Y+1	; 0x01
    159a:	9a 81       	ldd	r25, Y+2	; 0x02
    159c:	fc 01       	movw	r30, r24
    159e:	20 81       	ld	r18, Z
    15a0:	31 81       	ldd	r19, Z+1	; 0x01
    15a2:	89 81       	ldd	r24, Y+1	; 0x01
    15a4:	9a 81       	ldd	r25, Y+2	; 0x02
    15a6:	fc 01       	movw	r30, r24
    15a8:	24 83       	std	Z+4, r18	; 0x04
    15aa:	35 83       	std	Z+5, r19	; 0x05
    15ac:	89 81       	ldd	r24, Y+1	; 0x01
    15ae:	9a 81       	ldd	r25, Y+2	; 0x02
    15b0:	fc 01       	movw	r30, r24
    15b2:	80 81       	ld	r24, Z
    15b4:	91 81       	ldd	r25, Z+1	; 0x01
    15b6:	29 81       	ldd	r18, Y+1	; 0x01
    15b8:	3a 81       	ldd	r19, Y+2	; 0x02
    15ba:	f9 01       	movw	r30, r18
    15bc:	27 8d       	ldd	r18, Z+31	; 0x1f
    15be:	22 2f       	mov	r18, r18
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	a9 01       	movw	r20, r18
    15c4:	41 50       	subi	r20, 0x01	; 1
    15c6:	51 09       	sbc	r21, r1
    15c8:	29 81       	ldd	r18, Y+1	; 0x01
    15ca:	3a 81       	ldd	r19, Y+2	; 0x02
    15cc:	f9 01       	movw	r30, r18
    15ce:	20 a1       	ldd	r18, Z+32	; 0x20
    15d0:	22 2f       	mov	r18, r18
    15d2:	30 e0       	ldi	r19, 0x00	; 0
    15d4:	42 9f       	mul	r20, r18
    15d6:	b0 01       	movw	r22, r0
    15d8:	43 9f       	mul	r20, r19
    15da:	70 0d       	add	r23, r0
    15dc:	52 9f       	mul	r21, r18
    15de:	70 0d       	add	r23, r0
    15e0:	11 24       	eor	r1, r1
    15e2:	9b 01       	movw	r18, r22
    15e4:	28 0f       	add	r18, r24
    15e6:	39 1f       	adc	r19, r25
    15e8:	89 81       	ldd	r24, Y+1	; 0x01
    15ea:	9a 81       	ldd	r25, Y+2	; 0x02
    15ec:	fc 01       	movw	r30, r24
    15ee:	26 83       	std	Z+6, r18	; 0x06
    15f0:	37 83       	std	Z+7, r19	; 0x07
    15f2:	89 81       	ldd	r24, Y+1	; 0x01
    15f4:	9a 81       	ldd	r25, Y+2	; 0x02
    15f6:	2f ef       	ldi	r18, 0xFF	; 255
    15f8:	fc 01       	movw	r30, r24
    15fa:	21 a3       	std	Z+33, r18	; 0x21
    15fc:	89 81       	ldd	r24, Y+1	; 0x01
    15fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1600:	2f ef       	ldi	r18, 0xFF	; 255
    1602:	fc 01       	movw	r30, r24
    1604:	22 a3       	std	Z+34, r18	; 0x22
    1606:	8d 81       	ldd	r24, Y+5	; 0x05
    1608:	88 23       	and	r24, r24
    160a:	81 f4       	brne	.+32     	; 0x162c <xQueueGenericReset+0x104>
    160c:	89 81       	ldd	r24, Y+1	; 0x01
    160e:	9a 81       	ldd	r25, Y+2	; 0x02
    1610:	fc 01       	movw	r30, r24
    1612:	80 85       	ldd	r24, Z+8	; 0x08
    1614:	88 23       	and	r24, r24
    1616:	a1 f0       	breq	.+40     	; 0x1640 <xQueueGenericReset+0x118>
    1618:	89 81       	ldd	r24, Y+1	; 0x01
    161a:	9a 81       	ldd	r25, Y+2	; 0x02
    161c:	08 96       	adiw	r24, 0x08	; 8
    161e:	0e 94 3f 12 	call	0x247e	; 0x247e <xTaskRemoveFromEventList>
    1622:	88 23       	and	r24, r24
    1624:	69 f0       	breq	.+26     	; 0x1640 <xQueueGenericReset+0x118>
    1626:	0e 94 2a 09 	call	0x1254	; 0x1254 <vPortYield>
    162a:	0a c0       	rjmp	.+20     	; 0x1640 <xQueueGenericReset+0x118>
    162c:	89 81       	ldd	r24, Y+1	; 0x01
    162e:	9a 81       	ldd	r25, Y+2	; 0x02
    1630:	08 96       	adiw	r24, 0x08	; 8
    1632:	0e 94 92 05 	call	0xb24	; 0xb24 <vListInitialise>
    1636:	89 81       	ldd	r24, Y+1	; 0x01
    1638:	9a 81       	ldd	r25, Y+2	; 0x02
    163a:	43 96       	adiw	r24, 0x13	; 19
    163c:	0e 94 92 05 	call	0xb24	; 0xb24 <vListInitialise>
    1640:	ff 91       	pop	r31
    1642:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1646:	81 e0       	ldi	r24, 0x01	; 1
    1648:	25 96       	adiw	r28, 0x05	; 5
    164a:	cd bf       	out	0x3d, r28	; 61
    164c:	de bf       	out	0x3e, r29	; 62
    164e:	df 91       	pop	r29
    1650:	cf 91       	pop	r28
    1652:	08 95       	ret

00001654 <xQueueGenericCreate>:
    1654:	0f 93       	push	r16
    1656:	1f 93       	push	r17
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	cd b7       	in	r28, 0x3d	; 61
    165e:	de b7       	in	r29, 0x3e	; 62
    1660:	29 97       	sbiw	r28, 0x09	; 9
    1662:	cd bf       	out	0x3d, r28	; 61
    1664:	de bf       	out	0x3e, r29	; 62
    1666:	8f 83       	std	Y+7, r24	; 0x07
    1668:	68 87       	std	Y+8, r22	; 0x08
    166a:	49 87       	std	Y+9, r20	; 0x09
    166c:	88 85       	ldd	r24, Y+8	; 0x08
    166e:	88 23       	and	r24, r24
    1670:	19 f4       	brne	.+6      	; 0x1678 <xQueueGenericCreate+0x24>
    1672:	19 82       	std	Y+1, r1	; 0x01
    1674:	1a 82       	std	Y+2, r1	; 0x02
    1676:	0f c0       	rjmp	.+30     	; 0x1696 <xQueueGenericCreate+0x42>
    1678:	8f 81       	ldd	r24, Y+7	; 0x07
    167a:	48 2f       	mov	r20, r24
    167c:	50 e0       	ldi	r21, 0x00	; 0
    167e:	88 85       	ldd	r24, Y+8	; 0x08
    1680:	28 2f       	mov	r18, r24
    1682:	30 e0       	ldi	r19, 0x00	; 0
    1684:	42 9f       	mul	r20, r18
    1686:	c0 01       	movw	r24, r0
    1688:	43 9f       	mul	r20, r19
    168a:	90 0d       	add	r25, r0
    168c:	52 9f       	mul	r21, r18
    168e:	90 0d       	add	r25, r0
    1690:	11 24       	eor	r1, r1
    1692:	89 83       	std	Y+1, r24	; 0x01
    1694:	9a 83       	std	Y+2, r25	; 0x02
    1696:	89 81       	ldd	r24, Y+1	; 0x01
    1698:	9a 81       	ldd	r25, Y+2	; 0x02
    169a:	85 96       	adiw	r24, 0x25	; 37
    169c:	0e 94 29 05 	call	0xa52	; 0xa52 <pvPortMalloc>
    16a0:	8b 83       	std	Y+3, r24	; 0x03
    16a2:	9c 83       	std	Y+4, r25	; 0x04
    16a4:	8b 81       	ldd	r24, Y+3	; 0x03
    16a6:	9c 81       	ldd	r25, Y+4	; 0x04
    16a8:	89 2b       	or	r24, r25
    16aa:	81 f0       	breq	.+32     	; 0x16cc <xQueueGenericCreate+0x78>
    16ac:	8b 81       	ldd	r24, Y+3	; 0x03
    16ae:	9c 81       	ldd	r25, Y+4	; 0x04
    16b0:	85 96       	adiw	r24, 0x25	; 37
    16b2:	8d 83       	std	Y+5, r24	; 0x05
    16b4:	9e 83       	std	Y+6, r25	; 0x06
    16b6:	2b 81       	ldd	r18, Y+3	; 0x03
    16b8:	3c 81       	ldd	r19, Y+4	; 0x04
    16ba:	8d 81       	ldd	r24, Y+5	; 0x05
    16bc:	9e 81       	ldd	r25, Y+6	; 0x06
    16be:	89 01       	movw	r16, r18
    16c0:	29 85       	ldd	r18, Y+9	; 0x09
    16c2:	ac 01       	movw	r20, r24
    16c4:	68 85       	ldd	r22, Y+8	; 0x08
    16c6:	8f 81       	ldd	r24, Y+7	; 0x07
    16c8:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <prvInitialiseNewQueue>
    16cc:	8b 81       	ldd	r24, Y+3	; 0x03
    16ce:	9c 81       	ldd	r25, Y+4	; 0x04
    16d0:	29 96       	adiw	r28, 0x09	; 9
    16d2:	cd bf       	out	0x3d, r28	; 61
    16d4:	de bf       	out	0x3e, r29	; 62
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	1f 91       	pop	r17
    16dc:	0f 91       	pop	r16
    16de:	08 95       	ret

000016e0 <prvInitialiseNewQueue>:
    16e0:	0f 93       	push	r16
    16e2:	1f 93       	push	r17
    16e4:	cf 93       	push	r28
    16e6:	df 93       	push	r29
    16e8:	cd b7       	in	r28, 0x3d	; 61
    16ea:	de b7       	in	r29, 0x3e	; 62
    16ec:	27 97       	sbiw	r28, 0x07	; 7
    16ee:	cd bf       	out	0x3d, r28	; 61
    16f0:	de bf       	out	0x3e, r29	; 62
    16f2:	89 83       	std	Y+1, r24	; 0x01
    16f4:	6a 83       	std	Y+2, r22	; 0x02
    16f6:	4b 83       	std	Y+3, r20	; 0x03
    16f8:	5c 83       	std	Y+4, r21	; 0x04
    16fa:	2d 83       	std	Y+5, r18	; 0x05
    16fc:	0e 83       	std	Y+6, r16	; 0x06
    16fe:	1f 83       	std	Y+7, r17	; 0x07
    1700:	8a 81       	ldd	r24, Y+2	; 0x02
    1702:	88 23       	and	r24, r24
    1704:	41 f4       	brne	.+16     	; 0x1716 <prvInitialiseNewQueue+0x36>
    1706:	8e 81       	ldd	r24, Y+6	; 0x06
    1708:	9f 81       	ldd	r25, Y+7	; 0x07
    170a:	2e 81       	ldd	r18, Y+6	; 0x06
    170c:	3f 81       	ldd	r19, Y+7	; 0x07
    170e:	fc 01       	movw	r30, r24
    1710:	20 83       	st	Z, r18
    1712:	31 83       	std	Z+1, r19	; 0x01
    1714:	07 c0       	rjmp	.+14     	; 0x1724 <prvInitialiseNewQueue+0x44>
    1716:	8e 81       	ldd	r24, Y+6	; 0x06
    1718:	9f 81       	ldd	r25, Y+7	; 0x07
    171a:	2b 81       	ldd	r18, Y+3	; 0x03
    171c:	3c 81       	ldd	r19, Y+4	; 0x04
    171e:	fc 01       	movw	r30, r24
    1720:	20 83       	st	Z, r18
    1722:	31 83       	std	Z+1, r19	; 0x01
    1724:	8e 81       	ldd	r24, Y+6	; 0x06
    1726:	9f 81       	ldd	r25, Y+7	; 0x07
    1728:	29 81       	ldd	r18, Y+1	; 0x01
    172a:	fc 01       	movw	r30, r24
    172c:	27 8f       	std	Z+31, r18	; 0x1f
    172e:	8e 81       	ldd	r24, Y+6	; 0x06
    1730:	9f 81       	ldd	r25, Y+7	; 0x07
    1732:	2a 81       	ldd	r18, Y+2	; 0x02
    1734:	fc 01       	movw	r30, r24
    1736:	20 a3       	std	Z+32, r18	; 0x20
    1738:	8e 81       	ldd	r24, Y+6	; 0x06
    173a:	9f 81       	ldd	r25, Y+7	; 0x07
    173c:	61 e0       	ldi	r22, 0x01	; 1
    173e:	0e 94 94 0a 	call	0x1528	; 0x1528 <xQueueGenericReset>
    1742:	8e 81       	ldd	r24, Y+6	; 0x06
    1744:	9f 81       	ldd	r25, Y+7	; 0x07
    1746:	2d 81       	ldd	r18, Y+5	; 0x05
    1748:	fc 01       	movw	r30, r24
    174a:	24 a3       	std	Z+36, r18	; 0x24
    174c:	00 00       	nop
    174e:	27 96       	adiw	r28, 0x07	; 7
    1750:	cd bf       	out	0x3d, r28	; 61
    1752:	de bf       	out	0x3e, r29	; 62
    1754:	df 91       	pop	r29
    1756:	cf 91       	pop	r28
    1758:	1f 91       	pop	r17
    175a:	0f 91       	pop	r16
    175c:	08 95       	ret

0000175e <xQueueGenericSendFromISR>:
    175e:	cf 93       	push	r28
    1760:	df 93       	push	r29
    1762:	cd b7       	in	r28, 0x3d	; 61
    1764:	de b7       	in	r29, 0x3e	; 62
    1766:	2c 97       	sbiw	r28, 0x0c	; 12
    1768:	cd bf       	out	0x3d, r28	; 61
    176a:	de bf       	out	0x3e, r29	; 62
    176c:	8e 83       	std	Y+6, r24	; 0x06
    176e:	9f 83       	std	Y+7, r25	; 0x07
    1770:	68 87       	std	Y+8, r22	; 0x08
    1772:	79 87       	std	Y+9, r23	; 0x09
    1774:	4a 87       	std	Y+10, r20	; 0x0a
    1776:	5b 87       	std	Y+11, r21	; 0x0b
    1778:	2c 87       	std	Y+12, r18	; 0x0c
    177a:	8e 81       	ldd	r24, Y+6	; 0x06
    177c:	9f 81       	ldd	r25, Y+7	; 0x07
    177e:	8a 83       	std	Y+2, r24	; 0x02
    1780:	9b 83       	std	Y+3, r25	; 0x03
    1782:	0e 94 01 07 	call	0xe02	; 0xe02 <_portSetInterruptMaskFromIsr>
    1786:	8c 83       	std	Y+4, r24	; 0x04
    1788:	8a 81       	ldd	r24, Y+2	; 0x02
    178a:	9b 81       	ldd	r25, Y+3	; 0x03
    178c:	fc 01       	movw	r30, r24
    178e:	26 8d       	ldd	r18, Z+30	; 0x1e
    1790:	8a 81       	ldd	r24, Y+2	; 0x02
    1792:	9b 81       	ldd	r25, Y+3	; 0x03
    1794:	fc 01       	movw	r30, r24
    1796:	87 8d       	ldd	r24, Z+31	; 0x1f
    1798:	28 17       	cp	r18, r24
    179a:	18 f0       	brcs	.+6      	; 0x17a2 <xQueueGenericSendFromISR+0x44>
    179c:	8c 85       	ldd	r24, Y+12	; 0x0c
    179e:	82 30       	cpi	r24, 0x02	; 2
    17a0:	89 f5       	brne	.+98     	; 0x1804 <xQueueGenericSendFromISR+0xa6>
    17a2:	8a 81       	ldd	r24, Y+2	; 0x02
    17a4:	9b 81       	ldd	r25, Y+3	; 0x03
    17a6:	fc 01       	movw	r30, r24
    17a8:	82 a1       	ldd	r24, Z+34	; 0x22
    17aa:	8d 83       	std	Y+5, r24	; 0x05
    17ac:	28 85       	ldd	r18, Y+8	; 0x08
    17ae:	39 85       	ldd	r19, Y+9	; 0x09
    17b0:	8a 81       	ldd	r24, Y+2	; 0x02
    17b2:	9b 81       	ldd	r25, Y+3	; 0x03
    17b4:	4c 85       	ldd	r20, Y+12	; 0x0c
    17b6:	b9 01       	movw	r22, r18
    17b8:	0e 94 6f 0c 	call	0x18de	; 0x18de <prvCopyDataToQueue>
    17bc:	8d 81       	ldd	r24, Y+5	; 0x05
    17be:	8f 3f       	cpi	r24, 0xFF	; 255
    17c0:	b9 f4       	brne	.+46     	; 0x17f0 <xQueueGenericSendFromISR+0x92>
    17c2:	8a 81       	ldd	r24, Y+2	; 0x02
    17c4:	9b 81       	ldd	r25, Y+3	; 0x03
    17c6:	fc 01       	movw	r30, r24
    17c8:	83 89       	ldd	r24, Z+19	; 0x13
    17ca:	88 23       	and	r24, r24
    17cc:	c1 f0       	breq	.+48     	; 0x17fe <xQueueGenericSendFromISR+0xa0>
    17ce:	8a 81       	ldd	r24, Y+2	; 0x02
    17d0:	9b 81       	ldd	r25, Y+3	; 0x03
    17d2:	43 96       	adiw	r24, 0x13	; 19
    17d4:	0e 94 3f 12 	call	0x247e	; 0x247e <xTaskRemoveFromEventList>
    17d8:	88 23       	and	r24, r24
    17da:	89 f0       	breq	.+34     	; 0x17fe <xQueueGenericSendFromISR+0xa0>
    17dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    17de:	9b 85       	ldd	r25, Y+11	; 0x0b
    17e0:	89 2b       	or	r24, r25
    17e2:	69 f0       	breq	.+26     	; 0x17fe <xQueueGenericSendFromISR+0xa0>
    17e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    17e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    17e8:	21 e0       	ldi	r18, 0x01	; 1
    17ea:	fc 01       	movw	r30, r24
    17ec:	20 83       	st	Z, r18
    17ee:	07 c0       	rjmp	.+14     	; 0x17fe <xQueueGenericSendFromISR+0xa0>
    17f0:	8d 81       	ldd	r24, Y+5	; 0x05
    17f2:	8f 5f       	subi	r24, 0xFF	; 255
    17f4:	28 2f       	mov	r18, r24
    17f6:	8a 81       	ldd	r24, Y+2	; 0x02
    17f8:	9b 81       	ldd	r25, Y+3	; 0x03
    17fa:	fc 01       	movw	r30, r24
    17fc:	22 a3       	std	Z+34, r18	; 0x22
    17fe:	81 e0       	ldi	r24, 0x01	; 1
    1800:	89 83       	std	Y+1, r24	; 0x01
    1802:	01 c0       	rjmp	.+2      	; 0x1806 <xQueueGenericSendFromISR+0xa8>
    1804:	19 82       	std	Y+1, r1	; 0x01
    1806:	80 ea       	ldi	r24, 0xA0	; 160
    1808:	90 e0       	ldi	r25, 0x00	; 0
    180a:	2c 81       	ldd	r18, Y+4	; 0x04
    180c:	fc 01       	movw	r30, r24
    180e:	22 83       	std	Z+2, r18	; 0x02
    1810:	89 81       	ldd	r24, Y+1	; 0x01
    1812:	2c 96       	adiw	r28, 0x0c	; 12
    1814:	cd bf       	out	0x3d, r28	; 61
    1816:	de bf       	out	0x3e, r29	; 62
    1818:	df 91       	pop	r29
    181a:	cf 91       	pop	r28
    181c:	08 95       	ret

0000181e <xQueueReceiveFromISR>:
    181e:	cf 93       	push	r28
    1820:	df 93       	push	r29
    1822:	cd b7       	in	r28, 0x3d	; 61
    1824:	de b7       	in	r29, 0x3e	; 62
    1826:	2c 97       	sbiw	r28, 0x0c	; 12
    1828:	cd bf       	out	0x3d, r28	; 61
    182a:	de bf       	out	0x3e, r29	; 62
    182c:	8f 83       	std	Y+7, r24	; 0x07
    182e:	98 87       	std	Y+8, r25	; 0x08
    1830:	69 87       	std	Y+9, r22	; 0x09
    1832:	7a 87       	std	Y+10, r23	; 0x0a
    1834:	4b 87       	std	Y+11, r20	; 0x0b
    1836:	5c 87       	std	Y+12, r21	; 0x0c
    1838:	8f 81       	ldd	r24, Y+7	; 0x07
    183a:	98 85       	ldd	r25, Y+8	; 0x08
    183c:	8a 83       	std	Y+2, r24	; 0x02
    183e:	9b 83       	std	Y+3, r25	; 0x03
    1840:	0e 94 01 07 	call	0xe02	; 0xe02 <_portSetInterruptMaskFromIsr>
    1844:	8c 83       	std	Y+4, r24	; 0x04
    1846:	8a 81       	ldd	r24, Y+2	; 0x02
    1848:	9b 81       	ldd	r25, Y+3	; 0x03
    184a:	fc 01       	movw	r30, r24
    184c:	86 8d       	ldd	r24, Z+30	; 0x1e
    184e:	8d 83       	std	Y+5, r24	; 0x05
    1850:	8d 81       	ldd	r24, Y+5	; 0x05
    1852:	88 23       	and	r24, r24
    1854:	b9 f1       	breq	.+110    	; 0x18c4 <xQueueReceiveFromISR+0xa6>
    1856:	8a 81       	ldd	r24, Y+2	; 0x02
    1858:	9b 81       	ldd	r25, Y+3	; 0x03
    185a:	fc 01       	movw	r30, r24
    185c:	81 a1       	ldd	r24, Z+33	; 0x21
    185e:	8e 83       	std	Y+6, r24	; 0x06
    1860:	29 85       	ldd	r18, Y+9	; 0x09
    1862:	3a 85       	ldd	r19, Y+10	; 0x0a
    1864:	8a 81       	ldd	r24, Y+2	; 0x02
    1866:	9b 81       	ldd	r25, Y+3	; 0x03
    1868:	b9 01       	movw	r22, r18
    186a:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <prvCopyDataFromQueue>
    186e:	8d 81       	ldd	r24, Y+5	; 0x05
    1870:	2f ef       	ldi	r18, 0xFF	; 255
    1872:	28 0f       	add	r18, r24
    1874:	8a 81       	ldd	r24, Y+2	; 0x02
    1876:	9b 81       	ldd	r25, Y+3	; 0x03
    1878:	fc 01       	movw	r30, r24
    187a:	26 8f       	std	Z+30, r18	; 0x1e
    187c:	8e 81       	ldd	r24, Y+6	; 0x06
    187e:	8f 3f       	cpi	r24, 0xFF	; 255
    1880:	b9 f4       	brne	.+46     	; 0x18b0 <xQueueReceiveFromISR+0x92>
    1882:	8a 81       	ldd	r24, Y+2	; 0x02
    1884:	9b 81       	ldd	r25, Y+3	; 0x03
    1886:	fc 01       	movw	r30, r24
    1888:	80 85       	ldd	r24, Z+8	; 0x08
    188a:	88 23       	and	r24, r24
    188c:	c1 f0       	breq	.+48     	; 0x18be <xQueueReceiveFromISR+0xa0>
    188e:	8a 81       	ldd	r24, Y+2	; 0x02
    1890:	9b 81       	ldd	r25, Y+3	; 0x03
    1892:	08 96       	adiw	r24, 0x08	; 8
    1894:	0e 94 3f 12 	call	0x247e	; 0x247e <xTaskRemoveFromEventList>
    1898:	88 23       	and	r24, r24
    189a:	89 f0       	breq	.+34     	; 0x18be <xQueueReceiveFromISR+0xa0>
    189c:	8b 85       	ldd	r24, Y+11	; 0x0b
    189e:	9c 85       	ldd	r25, Y+12	; 0x0c
    18a0:	89 2b       	or	r24, r25
    18a2:	69 f0       	breq	.+26     	; 0x18be <xQueueReceiveFromISR+0xa0>
    18a4:	8b 85       	ldd	r24, Y+11	; 0x0b
    18a6:	9c 85       	ldd	r25, Y+12	; 0x0c
    18a8:	21 e0       	ldi	r18, 0x01	; 1
    18aa:	fc 01       	movw	r30, r24
    18ac:	20 83       	st	Z, r18
    18ae:	07 c0       	rjmp	.+14     	; 0x18be <xQueueReceiveFromISR+0xa0>
    18b0:	8e 81       	ldd	r24, Y+6	; 0x06
    18b2:	8f 5f       	subi	r24, 0xFF	; 255
    18b4:	28 2f       	mov	r18, r24
    18b6:	8a 81       	ldd	r24, Y+2	; 0x02
    18b8:	9b 81       	ldd	r25, Y+3	; 0x03
    18ba:	fc 01       	movw	r30, r24
    18bc:	21 a3       	std	Z+33, r18	; 0x21
    18be:	81 e0       	ldi	r24, 0x01	; 1
    18c0:	89 83       	std	Y+1, r24	; 0x01
    18c2:	01 c0       	rjmp	.+2      	; 0x18c6 <xQueueReceiveFromISR+0xa8>
    18c4:	19 82       	std	Y+1, r1	; 0x01
    18c6:	80 ea       	ldi	r24, 0xA0	; 160
    18c8:	90 e0       	ldi	r25, 0x00	; 0
    18ca:	2c 81       	ldd	r18, Y+4	; 0x04
    18cc:	fc 01       	movw	r30, r24
    18ce:	22 83       	std	Z+2, r18	; 0x02
    18d0:	89 81       	ldd	r24, Y+1	; 0x01
    18d2:	2c 96       	adiw	r28, 0x0c	; 12
    18d4:	cd bf       	out	0x3d, r28	; 61
    18d6:	de bf       	out	0x3e, r29	; 62
    18d8:	df 91       	pop	r29
    18da:	cf 91       	pop	r28
    18dc:	08 95       	ret

000018de <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    18de:	cf 93       	push	r28
    18e0:	df 93       	push	r29
    18e2:	cd b7       	in	r28, 0x3d	; 61
    18e4:	de b7       	in	r29, 0x3e	; 62
    18e6:	27 97       	sbiw	r28, 0x07	; 7
    18e8:	cd bf       	out	0x3d, r28	; 61
    18ea:	de bf       	out	0x3e, r29	; 62
    18ec:	8b 83       	std	Y+3, r24	; 0x03
    18ee:	9c 83       	std	Y+4, r25	; 0x04
    18f0:	6d 83       	std	Y+5, r22	; 0x05
    18f2:	7e 83       	std	Y+6, r23	; 0x06
    18f4:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    18f6:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18f8:	8b 81       	ldd	r24, Y+3	; 0x03
    18fa:	9c 81       	ldd	r25, Y+4	; 0x04
    18fc:	fc 01       	movw	r30, r24
    18fe:	86 8d       	ldd	r24, Z+30	; 0x1e
    1900:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1902:	8b 81       	ldd	r24, Y+3	; 0x03
    1904:	9c 81       	ldd	r25, Y+4	; 0x04
    1906:	fc 01       	movw	r30, r24
    1908:	80 a1       	ldd	r24, Z+32	; 0x20
    190a:	88 23       	and	r24, r24
    190c:	09 f4       	brne	.+2      	; 0x1910 <prvCopyDataToQueue+0x32>
    190e:	8e c0       	rjmp	.+284    	; 0x1a2c <prvCopyDataToQueue+0x14e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1910:	8f 81       	ldd	r24, Y+7	; 0x07
    1912:	88 23       	and	r24, r24
    1914:	d9 f5       	brne	.+118    	; 0x198c <prvCopyDataToQueue+0xae>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1916:	8b 81       	ldd	r24, Y+3	; 0x03
    1918:	9c 81       	ldd	r25, Y+4	; 0x04
    191a:	fc 01       	movw	r30, r24
    191c:	80 a1       	ldd	r24, Z+32	; 0x20
    191e:	48 2f       	mov	r20, r24
    1920:	50 e0       	ldi	r21, 0x00	; 0
    1922:	8b 81       	ldd	r24, Y+3	; 0x03
    1924:	9c 81       	ldd	r25, Y+4	; 0x04
    1926:	fc 01       	movw	r30, r24
    1928:	84 81       	ldd	r24, Z+4	; 0x04
    192a:	95 81       	ldd	r25, Z+5	; 0x05
    192c:	2d 81       	ldd	r18, Y+5	; 0x05
    192e:	3e 81       	ldd	r19, Y+6	; 0x06
    1930:	b9 01       	movw	r22, r18
    1932:	0e 94 76 1b 	call	0x36ec	; 0x36ec <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1936:	8b 81       	ldd	r24, Y+3	; 0x03
    1938:	9c 81       	ldd	r25, Y+4	; 0x04
    193a:	fc 01       	movw	r30, r24
    193c:	24 81       	ldd	r18, Z+4	; 0x04
    193e:	35 81       	ldd	r19, Z+5	; 0x05
    1940:	8b 81       	ldd	r24, Y+3	; 0x03
    1942:	9c 81       	ldd	r25, Y+4	; 0x04
    1944:	fc 01       	movw	r30, r24
    1946:	80 a1       	ldd	r24, Z+32	; 0x20
    1948:	88 2f       	mov	r24, r24
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	28 0f       	add	r18, r24
    194e:	39 1f       	adc	r19, r25
    1950:	8b 81       	ldd	r24, Y+3	; 0x03
    1952:	9c 81       	ldd	r25, Y+4	; 0x04
    1954:	fc 01       	movw	r30, r24
    1956:	24 83       	std	Z+4, r18	; 0x04
    1958:	35 83       	std	Z+5, r19	; 0x05
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    195a:	8b 81       	ldd	r24, Y+3	; 0x03
    195c:	9c 81       	ldd	r25, Y+4	; 0x04
    195e:	fc 01       	movw	r30, r24
    1960:	24 81       	ldd	r18, Z+4	; 0x04
    1962:	35 81       	ldd	r19, Z+5	; 0x05
    1964:	8b 81       	ldd	r24, Y+3	; 0x03
    1966:	9c 81       	ldd	r25, Y+4	; 0x04
    1968:	fc 01       	movw	r30, r24
    196a:	82 81       	ldd	r24, Z+2	; 0x02
    196c:	93 81       	ldd	r25, Z+3	; 0x03
    196e:	28 17       	cp	r18, r24
    1970:	39 07       	cpc	r19, r25
    1972:	08 f4       	brcc	.+2      	; 0x1976 <prvCopyDataToQueue+0x98>
    1974:	5b c0       	rjmp	.+182    	; 0x1a2c <prvCopyDataToQueue+0x14e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1976:	8b 81       	ldd	r24, Y+3	; 0x03
    1978:	9c 81       	ldd	r25, Y+4	; 0x04
    197a:	fc 01       	movw	r30, r24
    197c:	20 81       	ld	r18, Z
    197e:	31 81       	ldd	r19, Z+1	; 0x01
    1980:	8b 81       	ldd	r24, Y+3	; 0x03
    1982:	9c 81       	ldd	r25, Y+4	; 0x04
    1984:	fc 01       	movw	r30, r24
    1986:	24 83       	std	Z+4, r18	; 0x04
    1988:	35 83       	std	Z+5, r19	; 0x05
    198a:	50 c0       	rjmp	.+160    	; 0x1a2c <prvCopyDataToQueue+0x14e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    198c:	8b 81       	ldd	r24, Y+3	; 0x03
    198e:	9c 81       	ldd	r25, Y+4	; 0x04
    1990:	fc 01       	movw	r30, r24
    1992:	80 a1       	ldd	r24, Z+32	; 0x20
    1994:	48 2f       	mov	r20, r24
    1996:	50 e0       	ldi	r21, 0x00	; 0
    1998:	8b 81       	ldd	r24, Y+3	; 0x03
    199a:	9c 81       	ldd	r25, Y+4	; 0x04
    199c:	fc 01       	movw	r30, r24
    199e:	86 81       	ldd	r24, Z+6	; 0x06
    19a0:	97 81       	ldd	r25, Z+7	; 0x07
    19a2:	2d 81       	ldd	r18, Y+5	; 0x05
    19a4:	3e 81       	ldd	r19, Y+6	; 0x06
    19a6:	b9 01       	movw	r22, r18
    19a8:	0e 94 76 1b 	call	0x36ec	; 0x36ec <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    19ac:	8b 81       	ldd	r24, Y+3	; 0x03
    19ae:	9c 81       	ldd	r25, Y+4	; 0x04
    19b0:	fc 01       	movw	r30, r24
    19b2:	26 81       	ldd	r18, Z+6	; 0x06
    19b4:	37 81       	ldd	r19, Z+7	; 0x07
    19b6:	8b 81       	ldd	r24, Y+3	; 0x03
    19b8:	9c 81       	ldd	r25, Y+4	; 0x04
    19ba:	fc 01       	movw	r30, r24
    19bc:	80 a1       	ldd	r24, Z+32	; 0x20
    19be:	88 2f       	mov	r24, r24
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	91 95       	neg	r25
    19c4:	81 95       	neg	r24
    19c6:	91 09       	sbc	r25, r1
    19c8:	28 0f       	add	r18, r24
    19ca:	39 1f       	adc	r19, r25
    19cc:	8b 81       	ldd	r24, Y+3	; 0x03
    19ce:	9c 81       	ldd	r25, Y+4	; 0x04
    19d0:	fc 01       	movw	r30, r24
    19d2:	26 83       	std	Z+6, r18	; 0x06
    19d4:	37 83       	std	Z+7, r19	; 0x07
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    19d6:	8b 81       	ldd	r24, Y+3	; 0x03
    19d8:	9c 81       	ldd	r25, Y+4	; 0x04
    19da:	fc 01       	movw	r30, r24
    19dc:	26 81       	ldd	r18, Z+6	; 0x06
    19de:	37 81       	ldd	r19, Z+7	; 0x07
    19e0:	8b 81       	ldd	r24, Y+3	; 0x03
    19e2:	9c 81       	ldd	r25, Y+4	; 0x04
    19e4:	fc 01       	movw	r30, r24
    19e6:	80 81       	ld	r24, Z
    19e8:	91 81       	ldd	r25, Z+1	; 0x01
    19ea:	28 17       	cp	r18, r24
    19ec:	39 07       	cpc	r19, r25
    19ee:	a8 f4       	brcc	.+42     	; 0x1a1a <prvCopyDataToQueue+0x13c>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    19f0:	8b 81       	ldd	r24, Y+3	; 0x03
    19f2:	9c 81       	ldd	r25, Y+4	; 0x04
    19f4:	fc 01       	movw	r30, r24
    19f6:	22 81       	ldd	r18, Z+2	; 0x02
    19f8:	33 81       	ldd	r19, Z+3	; 0x03
    19fa:	8b 81       	ldd	r24, Y+3	; 0x03
    19fc:	9c 81       	ldd	r25, Y+4	; 0x04
    19fe:	fc 01       	movw	r30, r24
    1a00:	80 a1       	ldd	r24, Z+32	; 0x20
    1a02:	88 2f       	mov	r24, r24
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	91 95       	neg	r25
    1a08:	81 95       	neg	r24
    1a0a:	91 09       	sbc	r25, r1
    1a0c:	28 0f       	add	r18, r24
    1a0e:	39 1f       	adc	r19, r25
    1a10:	8b 81       	ldd	r24, Y+3	; 0x03
    1a12:	9c 81       	ldd	r25, Y+4	; 0x04
    1a14:	fc 01       	movw	r30, r24
    1a16:	26 83       	std	Z+6, r18	; 0x06
    1a18:	37 83       	std	Z+7, r19	; 0x07
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1a1a:	8f 81       	ldd	r24, Y+7	; 0x07
    1a1c:	82 30       	cpi	r24, 0x02	; 2
    1a1e:	31 f4       	brne	.+12     	; 0x1a2c <prvCopyDataToQueue+0x14e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a20:	89 81       	ldd	r24, Y+1	; 0x01
    1a22:	88 23       	and	r24, r24
    1a24:	19 f0       	breq	.+6      	; 0x1a2c <prvCopyDataToQueue+0x14e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1a26:	89 81       	ldd	r24, Y+1	; 0x01
    1a28:	81 50       	subi	r24, 0x01	; 1
    1a2a:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1a2c:	89 81       	ldd	r24, Y+1	; 0x01
    1a2e:	21 e0       	ldi	r18, 0x01	; 1
    1a30:	28 0f       	add	r18, r24
    1a32:	8b 81       	ldd	r24, Y+3	; 0x03
    1a34:	9c 81       	ldd	r25, Y+4	; 0x04
    1a36:	fc 01       	movw	r30, r24
    1a38:	26 8f       	std	Z+30, r18	; 0x1e

	return xReturn;
    1a3a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1a3c:	27 96       	adiw	r28, 0x07	; 7
    1a3e:	cd bf       	out	0x3d, r28	; 61
    1a40:	de bf       	out	0x3e, r29	; 62
    1a42:	df 91       	pop	r29
    1a44:	cf 91       	pop	r28
    1a46:	08 95       	ret

00001a48 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1a48:	cf 93       	push	r28
    1a4a:	df 93       	push	r29
    1a4c:	00 d0       	rcall	.+0      	; 0x1a4e <prvCopyDataFromQueue+0x6>
    1a4e:	1f 92       	push	r1
    1a50:	cd b7       	in	r28, 0x3d	; 61
    1a52:	de b7       	in	r29, 0x3e	; 62
    1a54:	89 83       	std	Y+1, r24	; 0x01
    1a56:	9a 83       	std	Y+2, r25	; 0x02
    1a58:	6b 83       	std	Y+3, r22	; 0x03
    1a5a:	7c 83       	std	Y+4, r23	; 0x04
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1a5c:	89 81       	ldd	r24, Y+1	; 0x01
    1a5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a60:	fc 01       	movw	r30, r24
    1a62:	80 a1       	ldd	r24, Z+32	; 0x20
    1a64:	88 23       	and	r24, r24
    1a66:	c9 f1       	breq	.+114    	; 0x1ada <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1a68:	89 81       	ldd	r24, Y+1	; 0x01
    1a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a6c:	fc 01       	movw	r30, r24
    1a6e:	26 81       	ldd	r18, Z+6	; 0x06
    1a70:	37 81       	ldd	r19, Z+7	; 0x07
    1a72:	89 81       	ldd	r24, Y+1	; 0x01
    1a74:	9a 81       	ldd	r25, Y+2	; 0x02
    1a76:	fc 01       	movw	r30, r24
    1a78:	80 a1       	ldd	r24, Z+32	; 0x20
    1a7a:	88 2f       	mov	r24, r24
    1a7c:	90 e0       	ldi	r25, 0x00	; 0
    1a7e:	28 0f       	add	r18, r24
    1a80:	39 1f       	adc	r19, r25
    1a82:	89 81       	ldd	r24, Y+1	; 0x01
    1a84:	9a 81       	ldd	r25, Y+2	; 0x02
    1a86:	fc 01       	movw	r30, r24
    1a88:	26 83       	std	Z+6, r18	; 0x06
    1a8a:	37 83       	std	Z+7, r19	; 0x07
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1a8c:	89 81       	ldd	r24, Y+1	; 0x01
    1a8e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a90:	fc 01       	movw	r30, r24
    1a92:	26 81       	ldd	r18, Z+6	; 0x06
    1a94:	37 81       	ldd	r19, Z+7	; 0x07
    1a96:	89 81       	ldd	r24, Y+1	; 0x01
    1a98:	9a 81       	ldd	r25, Y+2	; 0x02
    1a9a:	fc 01       	movw	r30, r24
    1a9c:	82 81       	ldd	r24, Z+2	; 0x02
    1a9e:	93 81       	ldd	r25, Z+3	; 0x03
    1aa0:	28 17       	cp	r18, r24
    1aa2:	39 07       	cpc	r19, r25
    1aa4:	50 f0       	brcs	.+20     	; 0x1aba <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1aa6:	89 81       	ldd	r24, Y+1	; 0x01
    1aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    1aaa:	fc 01       	movw	r30, r24
    1aac:	20 81       	ld	r18, Z
    1aae:	31 81       	ldd	r19, Z+1	; 0x01
    1ab0:	89 81       	ldd	r24, Y+1	; 0x01
    1ab2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ab4:	fc 01       	movw	r30, r24
    1ab6:	26 83       	std	Z+6, r18	; 0x06
    1ab8:	37 83       	std	Z+7, r19	; 0x07
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1aba:	89 81       	ldd	r24, Y+1	; 0x01
    1abc:	9a 81       	ldd	r25, Y+2	; 0x02
    1abe:	fc 01       	movw	r30, r24
    1ac0:	80 a1       	ldd	r24, Z+32	; 0x20
    1ac2:	48 2f       	mov	r20, r24
    1ac4:	50 e0       	ldi	r21, 0x00	; 0
    1ac6:	89 81       	ldd	r24, Y+1	; 0x01
    1ac8:	9a 81       	ldd	r25, Y+2	; 0x02
    1aca:	fc 01       	movw	r30, r24
    1acc:	26 81       	ldd	r18, Z+6	; 0x06
    1ace:	37 81       	ldd	r19, Z+7	; 0x07
    1ad0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad4:	b9 01       	movw	r22, r18
    1ad6:	0e 94 76 1b 	call	0x36ec	; 0x36ec <memcpy>
	}
}
    1ada:	00 00       	nop
    1adc:	24 96       	adiw	r28, 0x04	; 4
    1ade:	cd bf       	out	0x3d, r28	; 61
    1ae0:	de bf       	out	0x3e, r29	; 62
    1ae2:	df 91       	pop	r29
    1ae4:	cf 91       	pop	r28
    1ae6:	08 95       	ret

00001ae8 <xTaskCreate>:
			}
		}
		taskEXIT_CRITICAL();

		return xReturn;
	}
    1ae8:	8f 92       	push	r8
    1aea:	9f 92       	push	r9
    1aec:	af 92       	push	r10
    1aee:	bf 92       	push	r11
    1af0:	cf 92       	push	r12
    1af2:	df 92       	push	r13
    1af4:	ef 92       	push	r14
    1af6:	ff 92       	push	r15
    1af8:	0f 93       	push	r16
    1afa:	1f 93       	push	r17
    1afc:	cf 93       	push	r28
    1afe:	df 93       	push	r29
    1b00:	cd b7       	in	r28, 0x3d	; 61
    1b02:	de b7       	in	r29, 0x3e	; 62
    1b04:	60 97       	sbiw	r28, 0x10	; 16
    1b06:	cd bf       	out	0x3d, r28	; 61
    1b08:	de bf       	out	0x3e, r29	; 62
    1b0a:	8e 83       	std	Y+6, r24	; 0x06
    1b0c:	9f 83       	std	Y+7, r25	; 0x07
    1b0e:	68 87       	std	Y+8, r22	; 0x08
    1b10:	79 87       	std	Y+9, r23	; 0x09
    1b12:	4a 87       	std	Y+10, r20	; 0x0a
    1b14:	5b 87       	std	Y+11, r21	; 0x0b
    1b16:	2c 87       	std	Y+12, r18	; 0x0c
    1b18:	3d 87       	std	Y+13, r19	; 0x0d
    1b1a:	0e 87       	std	Y+14, r16	; 0x0e
    1b1c:	ef 86       	std	Y+15, r14	; 0x0f
    1b1e:	f8 8a       	std	Y+16, r15	; 0x10
    1b20:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b22:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b24:	0e 94 29 05 	call	0xa52	; 0xa52 <pvPortMalloc>
    1b28:	8c 83       	std	Y+4, r24	; 0x04
    1b2a:	9d 83       	std	Y+5, r25	; 0x05
    1b2c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b2e:	9d 81       	ldd	r25, Y+5	; 0x05
    1b30:	89 2b       	or	r24, r25
    1b32:	b9 f0       	breq	.+46     	; 0x1b62 <xTaskCreate+0x7a>
    1b34:	8c e2       	ldi	r24, 0x2C	; 44
    1b36:	90 e0       	ldi	r25, 0x00	; 0
    1b38:	0e 94 29 05 	call	0xa52	; 0xa52 <pvPortMalloc>
    1b3c:	89 83       	std	Y+1, r24	; 0x01
    1b3e:	9a 83       	std	Y+2, r25	; 0x02
    1b40:	89 81       	ldd	r24, Y+1	; 0x01
    1b42:	9a 81       	ldd	r25, Y+2	; 0x02
    1b44:	89 2b       	or	r24, r25
    1b46:	41 f0       	breq	.+16     	; 0x1b58 <xTaskCreate+0x70>
    1b48:	89 81       	ldd	r24, Y+1	; 0x01
    1b4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b4c:	2c 81       	ldd	r18, Y+4	; 0x04
    1b4e:	3d 81       	ldd	r19, Y+5	; 0x05
    1b50:	fc 01       	movw	r30, r24
    1b52:	23 8f       	std	Z+27, r18	; 0x1b
    1b54:	34 8f       	std	Z+28, r19	; 0x1c
    1b56:	07 c0       	rjmp	.+14     	; 0x1b66 <xTaskCreate+0x7e>
    1b58:	8c 81       	ldd	r24, Y+4	; 0x04
    1b5a:	9d 81       	ldd	r25, Y+5	; 0x05
    1b5c:	0e 94 73 05 	call	0xae6	; 0xae6 <vPortFree>
    1b60:	02 c0       	rjmp	.+4      	; 0x1b66 <xTaskCreate+0x7e>
    1b62:	19 82       	std	Y+1, r1	; 0x01
    1b64:	1a 82       	std	Y+2, r1	; 0x02
    1b66:	89 81       	ldd	r24, Y+1	; 0x01
    1b68:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6a:	89 2b       	or	r24, r25
    1b6c:	09 f1       	breq	.+66     	; 0x1bb0 <xTaskCreate+0xc8>
    1b6e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b70:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b72:	cc 01       	movw	r24, r24
    1b74:	a0 e0       	ldi	r26, 0x00	; 0
    1b76:	b0 e0       	ldi	r27, 0x00	; 0
    1b78:	09 81       	ldd	r16, Y+1	; 0x01
    1b7a:	1a 81       	ldd	r17, Y+2	; 0x02
    1b7c:	4f 85       	ldd	r20, Y+15	; 0x0f
    1b7e:	58 89       	ldd	r21, Y+16	; 0x10
    1b80:	2c 85       	ldd	r18, Y+12	; 0x0c
    1b82:	3d 85       	ldd	r19, Y+13	; 0x0d
    1b84:	68 85       	ldd	r22, Y+8	; 0x08
    1b86:	79 85       	ldd	r23, Y+9	; 0x09
    1b88:	ee 81       	ldd	r30, Y+6	; 0x06
    1b8a:	ff 81       	ldd	r31, Y+7	; 0x07
    1b8c:	81 2c       	mov	r8, r1
    1b8e:	91 2c       	mov	r9, r1
    1b90:	58 01       	movw	r10, r16
    1b92:	6a 01       	movw	r12, r20
    1b94:	ee 84       	ldd	r14, Y+14	; 0x0e
    1b96:	89 01       	movw	r16, r18
    1b98:	9c 01       	movw	r18, r24
    1b9a:	ad 01       	movw	r20, r26
    1b9c:	cf 01       	movw	r24, r30
    1b9e:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <prvInitialiseNewTask>
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
    1ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba6:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <prvAddNewTaskToReadyList>
    1baa:	81 e0       	ldi	r24, 0x01	; 1
    1bac:	8b 83       	std	Y+3, r24	; 0x03
    1bae:	02 c0       	rjmp	.+4      	; 0x1bb4 <xTaskCreate+0xcc>
    1bb0:	8f ef       	ldi	r24, 0xFF	; 255
    1bb2:	8b 83       	std	Y+3, r24	; 0x03
    1bb4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb6:	60 96       	adiw	r28, 0x10	; 16
    1bb8:	cd bf       	out	0x3d, r28	; 61
    1bba:	de bf       	out	0x3e, r29	; 62
    1bbc:	df 91       	pop	r29
    1bbe:	cf 91       	pop	r28
    1bc0:	1f 91       	pop	r17
    1bc2:	0f 91       	pop	r16
    1bc4:	ff 90       	pop	r15
    1bc6:	ef 90       	pop	r14
    1bc8:	df 90       	pop	r13
    1bca:	cf 90       	pop	r12
    1bcc:	bf 90       	pop	r11
    1bce:	af 90       	pop	r10
    1bd0:	9f 90       	pop	r9
    1bd2:	8f 90       	pop	r8
    1bd4:	08 95       	ret

00001bd6 <prvInitialiseNewTask>:
    1bd6:	8f 92       	push	r8
    1bd8:	9f 92       	push	r9
    1bda:	af 92       	push	r10
    1bdc:	bf 92       	push	r11
    1bde:	cf 92       	push	r12
    1be0:	df 92       	push	r13
    1be2:	ef 92       	push	r14
    1be4:	ff 92       	push	r15
    1be6:	0f 93       	push	r16
    1be8:	1f 93       	push	r17
    1bea:	cf 93       	push	r28
    1bec:	df 93       	push	r29
    1bee:	cd b7       	in	r28, 0x3d	; 61
    1bf0:	de b7       	in	r29, 0x3e	; 62
    1bf2:	64 97       	sbiw	r28, 0x14	; 20
    1bf4:	cd bf       	out	0x3d, r28	; 61
    1bf6:	de bf       	out	0x3e, r29	; 62
    1bf8:	8c 83       	std	Y+4, r24	; 0x04
    1bfa:	9d 83       	std	Y+5, r25	; 0x05
    1bfc:	6e 83       	std	Y+6, r22	; 0x06
    1bfe:	7f 83       	std	Y+7, r23	; 0x07
    1c00:	28 87       	std	Y+8, r18	; 0x08
    1c02:	39 87       	std	Y+9, r19	; 0x09
    1c04:	4a 87       	std	Y+10, r20	; 0x0a
    1c06:	5b 87       	std	Y+11, r21	; 0x0b
    1c08:	0c 87       	std	Y+12, r16	; 0x0c
    1c0a:	1d 87       	std	Y+13, r17	; 0x0d
    1c0c:	ee 86       	std	Y+14, r14	; 0x0e
    1c0e:	cf 86       	std	Y+15, r12	; 0x0f
    1c10:	d8 8a       	std	Y+16, r13	; 0x10
    1c12:	a9 8a       	std	Y+17, r10	; 0x11
    1c14:	ba 8a       	std	Y+18, r11	; 0x12
    1c16:	8b 8a       	std	Y+19, r8	; 0x13
    1c18:	9c 8a       	std	Y+20, r9	; 0x14
    1c1a:	28 85       	ldd	r18, Y+8	; 0x08
    1c1c:	39 85       	ldd	r19, Y+9	; 0x09
    1c1e:	89 89       	ldd	r24, Y+17	; 0x11
    1c20:	9a 89       	ldd	r25, Y+18	; 0x12
    1c22:	fc 01       	movw	r30, r24
    1c24:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c26:	94 8d       	ldd	r25, Z+28	; 0x1c
    1c28:	a9 01       	movw	r20, r18
    1c2a:	65 ea       	ldi	r22, 0xA5	; 165
    1c2c:	70 e0       	ldi	r23, 0x00	; 0
    1c2e:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <memset>
    1c32:	89 89       	ldd	r24, Y+17	; 0x11
    1c34:	9a 89       	ldd	r25, Y+18	; 0x12
    1c36:	fc 01       	movw	r30, r24
    1c38:	23 8d       	ldd	r18, Z+27	; 0x1b
    1c3a:	34 8d       	ldd	r19, Z+28	; 0x1c
    1c3c:	88 85       	ldd	r24, Y+8	; 0x08
    1c3e:	99 85       	ldd	r25, Y+9	; 0x09
    1c40:	01 97       	sbiw	r24, 0x01	; 1
    1c42:	82 0f       	add	r24, r18
    1c44:	93 1f       	adc	r25, r19
    1c46:	8a 83       	std	Y+2, r24	; 0x02
    1c48:	9b 83       	std	Y+3, r25	; 0x03
    1c4a:	19 82       	std	Y+1, r1	; 0x01
    1c4c:	21 c0       	rjmp	.+66     	; 0x1c90 <prvInitialiseNewTask+0xba>
    1c4e:	89 81       	ldd	r24, Y+1	; 0x01
    1c50:	88 2f       	mov	r24, r24
    1c52:	90 e0       	ldi	r25, 0x00	; 0
    1c54:	29 81       	ldd	r18, Y+1	; 0x01
    1c56:	22 2f       	mov	r18, r18
    1c58:	30 e0       	ldi	r19, 0x00	; 0
    1c5a:	4e 81       	ldd	r20, Y+6	; 0x06
    1c5c:	5f 81       	ldd	r21, Y+7	; 0x07
    1c5e:	24 0f       	add	r18, r20
    1c60:	35 1f       	adc	r19, r21
    1c62:	f9 01       	movw	r30, r18
    1c64:	40 81       	ld	r20, Z
    1c66:	29 89       	ldd	r18, Y+17	; 0x11
    1c68:	3a 89       	ldd	r19, Y+18	; 0x12
    1c6a:	82 0f       	add	r24, r18
    1c6c:	93 1f       	adc	r25, r19
    1c6e:	4d 96       	adiw	r24, 0x1d	; 29
    1c70:	fc 01       	movw	r30, r24
    1c72:	40 83       	st	Z, r20
    1c74:	89 81       	ldd	r24, Y+1	; 0x01
    1c76:	88 2f       	mov	r24, r24
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	2e 81       	ldd	r18, Y+6	; 0x06
    1c7c:	3f 81       	ldd	r19, Y+7	; 0x07
    1c7e:	82 0f       	add	r24, r18
    1c80:	93 1f       	adc	r25, r19
    1c82:	fc 01       	movw	r30, r24
    1c84:	80 81       	ld	r24, Z
    1c86:	88 23       	and	r24, r24
    1c88:	39 f0       	breq	.+14     	; 0x1c98 <prvInitialiseNewTask+0xc2>
    1c8a:	89 81       	ldd	r24, Y+1	; 0x01
    1c8c:	8f 5f       	subi	r24, 0xFF	; 255
    1c8e:	89 83       	std	Y+1, r24	; 0x01
    1c90:	89 81       	ldd	r24, Y+1	; 0x01
    1c92:	88 30       	cpi	r24, 0x08	; 8
    1c94:	e0 f2       	brcs	.-72     	; 0x1c4e <prvInitialiseNewTask+0x78>
    1c96:	01 c0       	rjmp	.+2      	; 0x1c9a <prvInitialiseNewTask+0xc4>
    1c98:	00 00       	nop
    1c9a:	89 89       	ldd	r24, Y+17	; 0x11
    1c9c:	9a 89       	ldd	r25, Y+18	; 0x12
    1c9e:	fc 01       	movw	r30, r24
    1ca0:	14 a2       	std	Z+36, r1	; 0x24
    1ca2:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ca4:	84 30       	cpi	r24, 0x04	; 4
    1ca6:	10 f0       	brcs	.+4      	; 0x1cac <prvInitialiseNewTask+0xd6>
    1ca8:	83 e0       	ldi	r24, 0x03	; 3
    1caa:	8e 87       	std	Y+14, r24	; 0x0e
    1cac:	89 89       	ldd	r24, Y+17	; 0x11
    1cae:	9a 89       	ldd	r25, Y+18	; 0x12
    1cb0:	2e 85       	ldd	r18, Y+14	; 0x0e
    1cb2:	fc 01       	movw	r30, r24
    1cb4:	22 8f       	std	Z+26, r18	; 0x1a
    1cb6:	89 89       	ldd	r24, Y+17	; 0x11
    1cb8:	9a 89       	ldd	r25, Y+18	; 0x12
    1cba:	02 96       	adiw	r24, 0x02	; 2
    1cbc:	0e 94 cc 05 	call	0xb98	; 0xb98 <vListInitialiseItem>
    1cc0:	89 89       	ldd	r24, Y+17	; 0x11
    1cc2:	9a 89       	ldd	r25, Y+18	; 0x12
    1cc4:	0e 96       	adiw	r24, 0x0e	; 14
    1cc6:	0e 94 cc 05 	call	0xb98	; 0xb98 <vListInitialiseItem>
    1cca:	89 89       	ldd	r24, Y+17	; 0x11
    1ccc:	9a 89       	ldd	r25, Y+18	; 0x12
    1cce:	29 89       	ldd	r18, Y+17	; 0x11
    1cd0:	3a 89       	ldd	r19, Y+18	; 0x12
    1cd2:	fc 01       	movw	r30, r24
    1cd4:	22 87       	std	Z+10, r18	; 0x0a
    1cd6:	33 87       	std	Z+11, r19	; 0x0b
    1cd8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1cda:	88 2f       	mov	r24, r24
    1cdc:	90 e0       	ldi	r25, 0x00	; 0
    1cde:	a0 e0       	ldi	r26, 0x00	; 0
    1ce0:	b0 e0       	ldi	r27, 0x00	; 0
    1ce2:	24 e0       	ldi	r18, 0x04	; 4
    1ce4:	30 e0       	ldi	r19, 0x00	; 0
    1ce6:	40 e0       	ldi	r20, 0x00	; 0
    1ce8:	50 e0       	ldi	r21, 0x00	; 0
    1cea:	79 01       	movw	r14, r18
    1cec:	8a 01       	movw	r16, r20
    1cee:	e8 1a       	sub	r14, r24
    1cf0:	f9 0a       	sbc	r15, r25
    1cf2:	0a 0b       	sbc	r16, r26
    1cf4:	1b 0b       	sbc	r17, r27
    1cf6:	d8 01       	movw	r26, r16
    1cf8:	c7 01       	movw	r24, r14
    1cfa:	29 89       	ldd	r18, Y+17	; 0x11
    1cfc:	3a 89       	ldd	r19, Y+18	; 0x12
    1cfe:	f9 01       	movw	r30, r18
    1d00:	86 87       	std	Z+14, r24	; 0x0e
    1d02:	97 87       	std	Z+15, r25	; 0x0f
    1d04:	a0 8b       	std	Z+16, r26	; 0x10
    1d06:	b1 8b       	std	Z+17, r27	; 0x11
    1d08:	89 89       	ldd	r24, Y+17	; 0x11
    1d0a:	9a 89       	ldd	r25, Y+18	; 0x12
    1d0c:	29 89       	ldd	r18, Y+17	; 0x11
    1d0e:	3a 89       	ldd	r19, Y+18	; 0x12
    1d10:	fc 01       	movw	r30, r24
    1d12:	26 8b       	std	Z+22, r18	; 0x16
    1d14:	37 8b       	std	Z+23, r19	; 0x17
    1d16:	89 89       	ldd	r24, Y+17	; 0x11
    1d18:	9a 89       	ldd	r25, Y+18	; 0x12
    1d1a:	fc 01       	movw	r30, r24
    1d1c:	17 a2       	std	Z+39, r1	; 0x27
    1d1e:	10 a6       	std	Z+40, r1	; 0x28
    1d20:	11 a6       	std	Z+41, r1	; 0x29
    1d22:	12 a6       	std	Z+42, r1	; 0x2a
    1d24:	89 89       	ldd	r24, Y+17	; 0x11
    1d26:	9a 89       	ldd	r25, Y+18	; 0x12
    1d28:	fc 01       	movw	r30, r24
    1d2a:	13 a6       	std	Z+43, r1	; 0x2b
    1d2c:	4c 85       	ldd	r20, Y+12	; 0x0c
    1d2e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1d30:	2c 81       	ldd	r18, Y+4	; 0x04
    1d32:	3d 81       	ldd	r19, Y+5	; 0x05
    1d34:	8a 81       	ldd	r24, Y+2	; 0x02
    1d36:	9b 81       	ldd	r25, Y+3	; 0x03
    1d38:	b9 01       	movw	r22, r18
    1d3a:	0e 94 19 07 	call	0xe32	; 0xe32 <pxPortInitialiseStack>
    1d3e:	9c 01       	movw	r18, r24
    1d40:	89 89       	ldd	r24, Y+17	; 0x11
    1d42:	9a 89       	ldd	r25, Y+18	; 0x12
    1d44:	fc 01       	movw	r30, r24
    1d46:	20 83       	st	Z, r18
    1d48:	31 83       	std	Z+1, r19	; 0x01
    1d4a:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d4c:	98 89       	ldd	r25, Y+16	; 0x10
    1d4e:	89 2b       	or	r24, r25
    1d50:	39 f0       	breq	.+14     	; 0x1d60 <prvInitialiseNewTask+0x18a>
    1d52:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d54:	98 89       	ldd	r25, Y+16	; 0x10
    1d56:	29 89       	ldd	r18, Y+17	; 0x11
    1d58:	3a 89       	ldd	r19, Y+18	; 0x12
    1d5a:	fc 01       	movw	r30, r24
    1d5c:	20 83       	st	Z, r18
    1d5e:	31 83       	std	Z+1, r19	; 0x01
    1d60:	00 00       	nop
    1d62:	64 96       	adiw	r28, 0x14	; 20
    1d64:	cd bf       	out	0x3d, r28	; 61
    1d66:	de bf       	out	0x3e, r29	; 62
    1d68:	df 91       	pop	r29
    1d6a:	cf 91       	pop	r28
    1d6c:	1f 91       	pop	r17
    1d6e:	0f 91       	pop	r16
    1d70:	ff 90       	pop	r15
    1d72:	ef 90       	pop	r14
    1d74:	df 90       	pop	r13
    1d76:	cf 90       	pop	r12
    1d78:	bf 90       	pop	r11
    1d7a:	af 90       	pop	r10
    1d7c:	9f 90       	pop	r9
    1d7e:	8f 90       	pop	r8
    1d80:	08 95       	ret

00001d82 <prvAddNewTaskToReadyList>:
    1d82:	cf 93       	push	r28
    1d84:	df 93       	push	r29
    1d86:	1f 92       	push	r1
    1d88:	1f 92       	push	r1
    1d8a:	cd b7       	in	r28, 0x3d	; 61
    1d8c:	de b7       	in	r29, 0x3e	; 62
    1d8e:	89 83       	std	Y+1, r24	; 0x01
    1d90:	9a 83       	std	Y+2, r25	; 0x02
    1d92:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d96:	ff 93       	push	r31
    1d98:	f8 7f       	andi	r31, 0xF8	; 248
    1d9a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d9e:	80 91 26 2c 	lds	r24, 0x2C26	; 0x802c26 <uxCurrentNumberOfTasks>
    1da2:	8f 5f       	subi	r24, 0xFF	; 255
    1da4:	80 93 26 2c 	sts	0x2C26, r24	; 0x802c26 <uxCurrentNumberOfTasks>
    1da8:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    1dac:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    1db0:	89 2b       	or	r24, r25
    1db2:	69 f4       	brne	.+26     	; 0x1dce <prvAddNewTaskToReadyList+0x4c>
    1db4:	89 81       	ldd	r24, Y+1	; 0x01
    1db6:	9a 81       	ldd	r25, Y+2	; 0x02
    1db8:	80 93 c8 2b 	sts	0x2BC8, r24	; 0x802bc8 <pxCurrentTCB>
    1dbc:	90 93 c9 2b 	sts	0x2BC9, r25	; 0x802bc9 <pxCurrentTCB+0x1>
    1dc0:	80 91 26 2c 	lds	r24, 0x2C26	; 0x802c26 <uxCurrentNumberOfTasks>
    1dc4:	81 30       	cpi	r24, 0x01	; 1
    1dc6:	c9 f4       	brne	.+50     	; 0x1dfa <prvAddNewTaskToReadyList+0x78>
    1dc8:	0e 94 ba 12 	call	0x2574	; 0x2574 <prvInitialiseTaskLists>
    1dcc:	16 c0       	rjmp	.+44     	; 0x1dfa <prvAddNewTaskToReadyList+0x78>
    1dce:	80 91 2c 2c 	lds	r24, 0x2C2C	; 0x802c2c <xSchedulerRunning>
    1dd2:	88 23       	and	r24, r24
    1dd4:	91 f4       	brne	.+36     	; 0x1dfa <prvAddNewTaskToReadyList+0x78>
    1dd6:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    1dda:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    1dde:	fc 01       	movw	r30, r24
    1de0:	22 8d       	ldd	r18, Z+26	; 0x1a
    1de2:	89 81       	ldd	r24, Y+1	; 0x01
    1de4:	9a 81       	ldd	r25, Y+2	; 0x02
    1de6:	fc 01       	movw	r30, r24
    1de8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dea:	82 17       	cp	r24, r18
    1dec:	30 f0       	brcs	.+12     	; 0x1dfa <prvAddNewTaskToReadyList+0x78>
    1dee:	89 81       	ldd	r24, Y+1	; 0x01
    1df0:	9a 81       	ldd	r25, Y+2	; 0x02
    1df2:	80 93 c8 2b 	sts	0x2BC8, r24	; 0x802bc8 <pxCurrentTCB>
    1df6:	90 93 c9 2b 	sts	0x2BC9, r25	; 0x802bc9 <pxCurrentTCB+0x1>
    1dfa:	80 91 30 2c 	lds	r24, 0x2C30	; 0x802c30 <uxTaskNumber>
    1dfe:	8f 5f       	subi	r24, 0xFF	; 255
    1e00:	80 93 30 2c 	sts	0x2C30, r24	; 0x802c30 <uxTaskNumber>
    1e04:	20 91 30 2c 	lds	r18, 0x2C30	; 0x802c30 <uxTaskNumber>
    1e08:	89 81       	ldd	r24, Y+1	; 0x01
    1e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e0c:	fc 01       	movw	r30, r24
    1e0e:	25 a3       	std	Z+37, r18	; 0x25
    1e10:	89 81       	ldd	r24, Y+1	; 0x01
    1e12:	9a 81       	ldd	r25, Y+2	; 0x02
    1e14:	fc 01       	movw	r30, r24
    1e16:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e18:	80 91 2b 2c 	lds	r24, 0x2C2B	; 0x802c2b <uxTopReadyPriority>
    1e1c:	89 17       	cp	r24, r25
    1e1e:	30 f4       	brcc	.+12     	; 0x1e2c <prvAddNewTaskToReadyList+0xaa>
    1e20:	89 81       	ldd	r24, Y+1	; 0x01
    1e22:	9a 81       	ldd	r25, Y+2	; 0x02
    1e24:	fc 01       	movw	r30, r24
    1e26:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e28:	80 93 2b 2c 	sts	0x2C2B, r24	; 0x802c2b <uxTopReadyPriority>
    1e2c:	89 81       	ldd	r24, Y+1	; 0x01
    1e2e:	9a 81       	ldd	r25, Y+2	; 0x02
    1e30:	ac 01       	movw	r20, r24
    1e32:	4e 5f       	subi	r20, 0xFE	; 254
    1e34:	5f 4f       	sbci	r21, 0xFF	; 255
    1e36:	89 81       	ldd	r24, Y+1	; 0x01
    1e38:	9a 81       	ldd	r25, Y+2	; 0x02
    1e3a:	fc 01       	movw	r30, r24
    1e3c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e3e:	28 2f       	mov	r18, r24
    1e40:	30 e0       	ldi	r19, 0x00	; 0
    1e42:	6b e0       	ldi	r22, 0x0B	; 11
    1e44:	62 9f       	mul	r22, r18
    1e46:	c0 01       	movw	r24, r0
    1e48:	63 9f       	mul	r22, r19
    1e4a:	90 0d       	add	r25, r0
    1e4c:	11 24       	eor	r1, r1
    1e4e:	86 53       	subi	r24, 0x36	; 54
    1e50:	94 4d       	sbci	r25, 0xD4	; 212
    1e52:	ba 01       	movw	r22, r20
    1e54:	0e 94 df 05 	call	0xbbe	; 0xbbe <vListInsertEnd>
    1e58:	ff 91       	pop	r31
    1e5a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1e5e:	80 91 2c 2c 	lds	r24, 0x2C2C	; 0x802c2c <xSchedulerRunning>
    1e62:	88 23       	and	r24, r24
    1e64:	71 f0       	breq	.+28     	; 0x1e82 <prvAddNewTaskToReadyList+0x100>
    1e66:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    1e6a:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    1e6e:	fc 01       	movw	r30, r24
    1e70:	22 8d       	ldd	r18, Z+26	; 0x1a
    1e72:	89 81       	ldd	r24, Y+1	; 0x01
    1e74:	9a 81       	ldd	r25, Y+2	; 0x02
    1e76:	fc 01       	movw	r30, r24
    1e78:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e7a:	28 17       	cp	r18, r24
    1e7c:	10 f4       	brcc	.+4      	; 0x1e82 <prvAddNewTaskToReadyList+0x100>
    1e7e:	0e 94 2a 09 	call	0x1254	; 0x1254 <vPortYield>
    1e82:	00 00       	nop
    1e84:	0f 90       	pop	r0
    1e86:	0f 90       	pop	r0
    1e88:	df 91       	pop	r29
    1e8a:	cf 91       	pop	r28
    1e8c:	08 95       	ret

00001e8e <vTaskDelay>:
    1e8e:	cf 93       	push	r28
    1e90:	df 93       	push	r29
    1e92:	cd b7       	in	r28, 0x3d	; 61
    1e94:	de b7       	in	r29, 0x3e	; 62
    1e96:	25 97       	sbiw	r28, 0x05	; 5
    1e98:	cd bf       	out	0x3d, r28	; 61
    1e9a:	de bf       	out	0x3e, r29	; 62
    1e9c:	6a 83       	std	Y+2, r22	; 0x02
    1e9e:	7b 83       	std	Y+3, r23	; 0x03
    1ea0:	8c 83       	std	Y+4, r24	; 0x04
    1ea2:	9d 83       	std	Y+5, r25	; 0x05
    1ea4:	19 82       	std	Y+1, r1	; 0x01
    1ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ea8:	9b 81       	ldd	r25, Y+3	; 0x03
    1eaa:	ac 81       	ldd	r26, Y+4	; 0x04
    1eac:	bd 81       	ldd	r27, Y+5	; 0x05
    1eae:	89 2b       	or	r24, r25
    1eb0:	8a 2b       	or	r24, r26
    1eb2:	8b 2b       	or	r24, r27
    1eb4:	71 f0       	breq	.+28     	; 0x1ed2 <vTaskDelay+0x44>
    1eb6:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <vTaskSuspendAll>
    1eba:	8a 81       	ldd	r24, Y+2	; 0x02
    1ebc:	9b 81       	ldd	r25, Y+3	; 0x03
    1ebe:	ac 81       	ldd	r26, Y+4	; 0x04
    1ec0:	bd 81       	ldd	r27, Y+5	; 0x05
    1ec2:	40 e0       	ldi	r20, 0x00	; 0
    1ec4:	bc 01       	movw	r22, r24
    1ec6:	cd 01       	movw	r24, r26
    1ec8:	0e 94 8c 13 	call	0x2718	; 0x2718 <prvAddCurrentTaskToDelayedList>
    1ecc:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xTaskResumeAll>
    1ed0:	89 83       	std	Y+1, r24	; 0x01
    1ed2:	89 81       	ldd	r24, Y+1	; 0x01
    1ed4:	88 23       	and	r24, r24
    1ed6:	11 f4       	brne	.+4      	; 0x1edc <vTaskDelay+0x4e>
    1ed8:	0e 94 2a 09 	call	0x1254	; 0x1254 <vPortYield>
    1edc:	00 00       	nop
    1ede:	25 96       	adiw	r28, 0x05	; 5
    1ee0:	cd bf       	out	0x3d, r28	; 61
    1ee2:	de bf       	out	0x3e, r29	; 62
    1ee4:	df 91       	pop	r29
    1ee6:	cf 91       	pop	r28
    1ee8:	08 95       	ret

00001eea <vTaskStartScheduler>:
    1eea:	ef 92       	push	r14
    1eec:	ff 92       	push	r15
    1eee:	0f 93       	push	r16
    1ef0:	cf 93       	push	r28
    1ef2:	df 93       	push	r29
    1ef4:	1f 92       	push	r1
    1ef6:	cd b7       	in	r28, 0x3d	; 61
    1ef8:	de b7       	in	r29, 0x3e	; 62
    1efa:	0f 2e       	mov	r0, r31
    1efc:	f5 e3       	ldi	r31, 0x35	; 53
    1efe:	ef 2e       	mov	r14, r31
    1f00:	fc e2       	ldi	r31, 0x2C	; 44
    1f02:	ff 2e       	mov	r15, r31
    1f04:	f0 2d       	mov	r31, r0
    1f06:	00 e0       	ldi	r16, 0x00	; 0
    1f08:	20 e0       	ldi	r18, 0x00	; 0
    1f0a:	30 e0       	ldi	r19, 0x00	; 0
    1f0c:	48 ec       	ldi	r20, 0xC8	; 200
    1f0e:	50 e0       	ldi	r21, 0x00	; 0
    1f10:	60 e0       	ldi	r22, 0x00	; 0
    1f12:	70 e2       	ldi	r23, 0x20	; 32
    1f14:	87 ea       	ldi	r24, 0xA7	; 167
    1f16:	92 e1       	ldi	r25, 0x12	; 18
    1f18:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <xTaskCreate>
    1f1c:	89 83       	std	Y+1, r24	; 0x01
    1f1e:	89 81       	ldd	r24, Y+1	; 0x01
    1f20:	81 30       	cpi	r24, 0x01	; 1
    1f22:	09 f5       	brne	.+66     	; 0x1f66 <vTaskStartScheduler+0x7c>
    1f24:	80 ea       	ldi	r24, 0xA0	; 160
    1f26:	90 e0       	ldi	r25, 0x00	; 0
    1f28:	20 ea       	ldi	r18, 0xA0	; 160
    1f2a:	30 e0       	ldi	r19, 0x00	; 0
    1f2c:	f9 01       	movw	r30, r18
    1f2e:	22 81       	ldd	r18, Z+2	; 0x02
    1f30:	28 7f       	andi	r18, 0xF8	; 248
    1f32:	fc 01       	movw	r30, r24
    1f34:	22 83       	std	Z+2, r18	; 0x02
    1f36:	8f ef       	ldi	r24, 0xFF	; 255
    1f38:	9f ef       	ldi	r25, 0xFF	; 255
    1f3a:	dc 01       	movw	r26, r24
    1f3c:	80 93 31 2c 	sts	0x2C31, r24	; 0x802c31 <xNextTaskUnblockTime>
    1f40:	90 93 32 2c 	sts	0x2C32, r25	; 0x802c32 <xNextTaskUnblockTime+0x1>
    1f44:	a0 93 33 2c 	sts	0x2C33, r26	; 0x802c33 <xNextTaskUnblockTime+0x2>
    1f48:	b0 93 34 2c 	sts	0x2C34, r27	; 0x802c34 <xNextTaskUnblockTime+0x3>
    1f4c:	81 e0       	ldi	r24, 0x01	; 1
    1f4e:	80 93 2c 2c 	sts	0x2C2C, r24	; 0x802c2c <xSchedulerRunning>
    1f52:	10 92 27 2c 	sts	0x2C27, r1	; 0x802c27 <xTickCount>
    1f56:	10 92 28 2c 	sts	0x2C28, r1	; 0x802c28 <xTickCount+0x1>
    1f5a:	10 92 29 2c 	sts	0x2C29, r1	; 0x802c29 <xTickCount+0x2>
    1f5e:	10 92 2a 2c 	sts	0x2C2A, r1	; 0x802c2a <xTickCount+0x3>
    1f62:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <xPortStartScheduler>
    1f66:	00 00       	nop
    1f68:	0f 90       	pop	r0
    1f6a:	df 91       	pop	r29
    1f6c:	cf 91       	pop	r28
    1f6e:	0f 91       	pop	r16
    1f70:	ff 90       	pop	r15
    1f72:	ef 90       	pop	r14
    1f74:	08 95       	ret

00001f76 <vTaskSuspendAll>:
    1f76:	cf 93       	push	r28
    1f78:	df 93       	push	r29
    1f7a:	cd b7       	in	r28, 0x3d	; 61
    1f7c:	de b7       	in	r29, 0x3e	; 62
    1f7e:	80 91 37 2c 	lds	r24, 0x2C37	; 0x802c37 <uxSchedulerSuspended>
    1f82:	8f 5f       	subi	r24, 0xFF	; 255
    1f84:	80 93 37 2c 	sts	0x2C37, r24	; 0x802c37 <uxSchedulerSuspended>
    1f88:	00 00       	nop
    1f8a:	df 91       	pop	r29
    1f8c:	cf 91       	pop	r28
    1f8e:	08 95       	ret

00001f90 <xTaskResumeAll>:
    1f90:	cf 93       	push	r28
    1f92:	df 93       	push	r29
    1f94:	00 d0       	rcall	.+0      	; 0x1f96 <xTaskResumeAll+0x6>
    1f96:	1f 92       	push	r1
    1f98:	cd b7       	in	r28, 0x3d	; 61
    1f9a:	de b7       	in	r29, 0x3e	; 62
    1f9c:	19 82       	std	Y+1, r1	; 0x01
    1f9e:	1a 82       	std	Y+2, r1	; 0x02
    1fa0:	1b 82       	std	Y+3, r1	; 0x03
    1fa2:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1fa6:	ff 93       	push	r31
    1fa8:	f8 7f       	andi	r31, 0xF8	; 248
    1faa:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1fae:	80 91 37 2c 	lds	r24, 0x2C37	; 0x802c37 <uxSchedulerSuspended>
    1fb2:	81 50       	subi	r24, 0x01	; 1
    1fb4:	80 93 37 2c 	sts	0x2C37, r24	; 0x802c37 <uxSchedulerSuspended>
    1fb8:	80 91 37 2c 	lds	r24, 0x2C37	; 0x802c37 <uxSchedulerSuspended>
    1fbc:	88 23       	and	r24, r24
    1fbe:	09 f0       	breq	.+2      	; 0x1fc2 <xTaskResumeAll+0x32>
    1fc0:	74 c0       	rjmp	.+232    	; 0x20aa <xTaskResumeAll+0x11a>
    1fc2:	80 91 26 2c 	lds	r24, 0x2C26	; 0x802c26 <uxCurrentNumberOfTasks>
    1fc6:	88 23       	and	r24, r24
    1fc8:	09 f4       	brne	.+2      	; 0x1fcc <xTaskResumeAll+0x3c>
    1fca:	6f c0       	rjmp	.+222    	; 0x20aa <xTaskResumeAll+0x11a>
    1fcc:	46 c0       	rjmp	.+140    	; 0x205a <xTaskResumeAll+0xca>
    1fce:	80 91 17 2c 	lds	r24, 0x2C17	; 0x802c17 <xPendingReadyList+0x7>
    1fd2:	90 91 18 2c 	lds	r25, 0x2C18	; 0x802c18 <xPendingReadyList+0x8>
    1fd6:	fc 01       	movw	r30, r24
    1fd8:	80 85       	ldd	r24, Z+8	; 0x08
    1fda:	91 85       	ldd	r25, Z+9	; 0x09
    1fdc:	89 83       	std	Y+1, r24	; 0x01
    1fde:	9a 83       	std	Y+2, r25	; 0x02
    1fe0:	89 81       	ldd	r24, Y+1	; 0x01
    1fe2:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe4:	0e 96       	adiw	r24, 0x0e	; 14
    1fe6:	0e 94 ab 06 	call	0xd56	; 0xd56 <uxListRemove>
    1fea:	89 81       	ldd	r24, Y+1	; 0x01
    1fec:	9a 81       	ldd	r25, Y+2	; 0x02
    1fee:	02 96       	adiw	r24, 0x02	; 2
    1ff0:	0e 94 ab 06 	call	0xd56	; 0xd56 <uxListRemove>
    1ff4:	89 81       	ldd	r24, Y+1	; 0x01
    1ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ff8:	fc 01       	movw	r30, r24
    1ffa:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ffc:	80 91 2b 2c 	lds	r24, 0x2C2B	; 0x802c2b <uxTopReadyPriority>
    2000:	89 17       	cp	r24, r25
    2002:	30 f4       	brcc	.+12     	; 0x2010 <xTaskResumeAll+0x80>
    2004:	89 81       	ldd	r24, Y+1	; 0x01
    2006:	9a 81       	ldd	r25, Y+2	; 0x02
    2008:	fc 01       	movw	r30, r24
    200a:	82 8d       	ldd	r24, Z+26	; 0x1a
    200c:	80 93 2b 2c 	sts	0x2C2B, r24	; 0x802c2b <uxTopReadyPriority>
    2010:	89 81       	ldd	r24, Y+1	; 0x01
    2012:	9a 81       	ldd	r25, Y+2	; 0x02
    2014:	ac 01       	movw	r20, r24
    2016:	4e 5f       	subi	r20, 0xFE	; 254
    2018:	5f 4f       	sbci	r21, 0xFF	; 255
    201a:	89 81       	ldd	r24, Y+1	; 0x01
    201c:	9a 81       	ldd	r25, Y+2	; 0x02
    201e:	fc 01       	movw	r30, r24
    2020:	82 8d       	ldd	r24, Z+26	; 0x1a
    2022:	28 2f       	mov	r18, r24
    2024:	30 e0       	ldi	r19, 0x00	; 0
    2026:	6b e0       	ldi	r22, 0x0B	; 11
    2028:	62 9f       	mul	r22, r18
    202a:	c0 01       	movw	r24, r0
    202c:	63 9f       	mul	r22, r19
    202e:	90 0d       	add	r25, r0
    2030:	11 24       	eor	r1, r1
    2032:	86 53       	subi	r24, 0x36	; 54
    2034:	94 4d       	sbci	r25, 0xD4	; 212
    2036:	ba 01       	movw	r22, r20
    2038:	0e 94 df 05 	call	0xbbe	; 0xbbe <vListInsertEnd>
    203c:	89 81       	ldd	r24, Y+1	; 0x01
    203e:	9a 81       	ldd	r25, Y+2	; 0x02
    2040:	fc 01       	movw	r30, r24
    2042:	22 8d       	ldd	r18, Z+26	; 0x1a
    2044:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    2048:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    204c:	fc 01       	movw	r30, r24
    204e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2050:	28 17       	cp	r18, r24
    2052:	18 f0       	brcs	.+6      	; 0x205a <xTaskResumeAll+0xca>
    2054:	81 e0       	ldi	r24, 0x01	; 1
    2056:	80 93 2e 2c 	sts	0x2C2E, r24	; 0x802c2e <xYieldPending>
    205a:	80 91 10 2c 	lds	r24, 0x2C10	; 0x802c10 <xPendingReadyList>
    205e:	88 23       	and	r24, r24
    2060:	09 f0       	breq	.+2      	; 0x2064 <xTaskResumeAll+0xd4>
    2062:	b5 cf       	rjmp	.-150    	; 0x1fce <xTaskResumeAll+0x3e>
    2064:	89 81       	ldd	r24, Y+1	; 0x01
    2066:	9a 81       	ldd	r25, Y+2	; 0x02
    2068:	89 2b       	or	r24, r25
    206a:	11 f0       	breq	.+4      	; 0x2070 <xTaskResumeAll+0xe0>
    206c:	0e 94 51 13 	call	0x26a2	; 0x26a2 <prvResetNextTaskUnblockTime>
    2070:	80 91 2d 2c 	lds	r24, 0x2C2D	; 0x802c2d <uxPendedTicks>
    2074:	8c 83       	std	Y+4, r24	; 0x04
    2076:	8c 81       	ldd	r24, Y+4	; 0x04
    2078:	88 23       	and	r24, r24
    207a:	79 f0       	breq	.+30     	; 0x209a <xTaskResumeAll+0x10a>
    207c:	0e 94 5f 10 	call	0x20be	; 0x20be <xTaskIncrementTick>
    2080:	88 23       	and	r24, r24
    2082:	19 f0       	breq	.+6      	; 0x208a <xTaskResumeAll+0xfa>
    2084:	81 e0       	ldi	r24, 0x01	; 1
    2086:	80 93 2e 2c 	sts	0x2C2E, r24	; 0x802c2e <xYieldPending>
    208a:	8c 81       	ldd	r24, Y+4	; 0x04
    208c:	81 50       	subi	r24, 0x01	; 1
    208e:	8c 83       	std	Y+4, r24	; 0x04
    2090:	8c 81       	ldd	r24, Y+4	; 0x04
    2092:	88 23       	and	r24, r24
    2094:	99 f7       	brne	.-26     	; 0x207c <xTaskResumeAll+0xec>
    2096:	10 92 2d 2c 	sts	0x2C2D, r1	; 0x802c2d <uxPendedTicks>
    209a:	80 91 2e 2c 	lds	r24, 0x2C2E	; 0x802c2e <xYieldPending>
    209e:	88 23       	and	r24, r24
    20a0:	21 f0       	breq	.+8      	; 0x20aa <xTaskResumeAll+0x11a>
    20a2:	81 e0       	ldi	r24, 0x01	; 1
    20a4:	8b 83       	std	Y+3, r24	; 0x03
    20a6:	0e 94 2a 09 	call	0x1254	; 0x1254 <vPortYield>
    20aa:	ff 91       	pop	r31
    20ac:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    20b0:	8b 81       	ldd	r24, Y+3	; 0x03
    20b2:	24 96       	adiw	r28, 0x04	; 4
    20b4:	cd bf       	out	0x3d, r28	; 61
    20b6:	de bf       	out	0x3e, r29	; 62
    20b8:	df 91       	pop	r29
    20ba:	cf 91       	pop	r28
    20bc:	08 95       	ret

000020be <xTaskIncrementTick>:
    20be:	cf 93       	push	r28
    20c0:	df 93       	push	r29
    20c2:	cd b7       	in	r28, 0x3d	; 61
    20c4:	de b7       	in	r29, 0x3e	; 62
    20c6:	2d 97       	sbiw	r28, 0x0d	; 13
    20c8:	cd bf       	out	0x3d, r28	; 61
    20ca:	de bf       	out	0x3e, r29	; 62
    20cc:	19 82       	std	Y+1, r1	; 0x01
    20ce:	80 91 37 2c 	lds	r24, 0x2C37	; 0x802c37 <uxSchedulerSuspended>
    20d2:	88 23       	and	r24, r24
    20d4:	09 f0       	breq	.+2      	; 0x20d8 <xTaskIncrementTick+0x1a>
    20d6:	f1 c0       	rjmp	.+482    	; 0x22ba <xTaskIncrementTick+0x1fc>
    20d8:	80 91 27 2c 	lds	r24, 0x2C27	; 0x802c27 <xTickCount>
    20dc:	90 91 28 2c 	lds	r25, 0x2C28	; 0x802c28 <xTickCount+0x1>
    20e0:	a0 91 29 2c 	lds	r26, 0x2C29	; 0x802c29 <xTickCount+0x2>
    20e4:	b0 91 2a 2c 	lds	r27, 0x2C2A	; 0x802c2a <xTickCount+0x3>
    20e8:	01 96       	adiw	r24, 0x01	; 1
    20ea:	a1 1d       	adc	r26, r1
    20ec:	b1 1d       	adc	r27, r1
    20ee:	8a 83       	std	Y+2, r24	; 0x02
    20f0:	9b 83       	std	Y+3, r25	; 0x03
    20f2:	ac 83       	std	Y+4, r26	; 0x04
    20f4:	bd 83       	std	Y+5, r27	; 0x05
    20f6:	8a 81       	ldd	r24, Y+2	; 0x02
    20f8:	9b 81       	ldd	r25, Y+3	; 0x03
    20fa:	ac 81       	ldd	r26, Y+4	; 0x04
    20fc:	bd 81       	ldd	r27, Y+5	; 0x05
    20fe:	80 93 27 2c 	sts	0x2C27, r24	; 0x802c27 <xTickCount>
    2102:	90 93 28 2c 	sts	0x2C28, r25	; 0x802c28 <xTickCount+0x1>
    2106:	a0 93 29 2c 	sts	0x2C29, r26	; 0x802c29 <xTickCount+0x2>
    210a:	b0 93 2a 2c 	sts	0x2C2A, r27	; 0x802c2a <xTickCount+0x3>
    210e:	8a 81       	ldd	r24, Y+2	; 0x02
    2110:	9b 81       	ldd	r25, Y+3	; 0x03
    2112:	ac 81       	ldd	r26, Y+4	; 0x04
    2114:	bd 81       	ldd	r27, Y+5	; 0x05
    2116:	89 2b       	or	r24, r25
    2118:	8a 2b       	or	r24, r26
    211a:	8b 2b       	or	r24, r27
    211c:	d9 f4       	brne	.+54     	; 0x2154 <xTaskIncrementTick+0x96>
    211e:	80 91 0c 2c 	lds	r24, 0x2C0C	; 0x802c0c <pxDelayedTaskList>
    2122:	90 91 0d 2c 	lds	r25, 0x2C0D	; 0x802c0d <pxDelayedTaskList+0x1>
    2126:	8e 83       	std	Y+6, r24	; 0x06
    2128:	9f 83       	std	Y+7, r25	; 0x07
    212a:	80 91 0e 2c 	lds	r24, 0x2C0E	; 0x802c0e <pxOverflowDelayedTaskList>
    212e:	90 91 0f 2c 	lds	r25, 0x2C0F	; 0x802c0f <pxOverflowDelayedTaskList+0x1>
    2132:	80 93 0c 2c 	sts	0x2C0C, r24	; 0x802c0c <pxDelayedTaskList>
    2136:	90 93 0d 2c 	sts	0x2C0D, r25	; 0x802c0d <pxDelayedTaskList+0x1>
    213a:	8e 81       	ldd	r24, Y+6	; 0x06
    213c:	9f 81       	ldd	r25, Y+7	; 0x07
    213e:	80 93 0e 2c 	sts	0x2C0E, r24	; 0x802c0e <pxOverflowDelayedTaskList>
    2142:	90 93 0f 2c 	sts	0x2C0F, r25	; 0x802c0f <pxOverflowDelayedTaskList+0x1>
    2146:	80 91 2f 2c 	lds	r24, 0x2C2F	; 0x802c2f <xNumOfOverflows>
    214a:	8f 5f       	subi	r24, 0xFF	; 255
    214c:	80 93 2f 2c 	sts	0x2C2F, r24	; 0x802c2f <xNumOfOverflows>
    2150:	0e 94 51 13 	call	0x26a2	; 0x26a2 <prvResetNextTaskUnblockTime>
    2154:	80 91 31 2c 	lds	r24, 0x2C31	; 0x802c31 <xNextTaskUnblockTime>
    2158:	90 91 32 2c 	lds	r25, 0x2C32	; 0x802c32 <xNextTaskUnblockTime+0x1>
    215c:	a0 91 33 2c 	lds	r26, 0x2C33	; 0x802c33 <xNextTaskUnblockTime+0x2>
    2160:	b0 91 34 2c 	lds	r27, 0x2C34	; 0x802c34 <xNextTaskUnblockTime+0x3>
    2164:	2a 81       	ldd	r18, Y+2	; 0x02
    2166:	3b 81       	ldd	r19, Y+3	; 0x03
    2168:	4c 81       	ldd	r20, Y+4	; 0x04
    216a:	5d 81       	ldd	r21, Y+5	; 0x05
    216c:	28 17       	cp	r18, r24
    216e:	39 07       	cpc	r19, r25
    2170:	4a 07       	cpc	r20, r26
    2172:	5b 07       	cpc	r21, r27
    2174:	08 f4       	brcc	.+2      	; 0x2178 <xTaskIncrementTick+0xba>
    2176:	8a c0       	rjmp	.+276    	; 0x228c <xTaskIncrementTick+0x1ce>
    2178:	80 91 0c 2c 	lds	r24, 0x2C0C	; 0x802c0c <pxDelayedTaskList>
    217c:	90 91 0d 2c 	lds	r25, 0x2C0D	; 0x802c0d <pxDelayedTaskList+0x1>
    2180:	fc 01       	movw	r30, r24
    2182:	80 81       	ld	r24, Z
    2184:	88 23       	and	r24, r24
    2186:	61 f4       	brne	.+24     	; 0x21a0 <xTaskIncrementTick+0xe2>
    2188:	8f ef       	ldi	r24, 0xFF	; 255
    218a:	9f ef       	ldi	r25, 0xFF	; 255
    218c:	dc 01       	movw	r26, r24
    218e:	80 93 31 2c 	sts	0x2C31, r24	; 0x802c31 <xNextTaskUnblockTime>
    2192:	90 93 32 2c 	sts	0x2C32, r25	; 0x802c32 <xNextTaskUnblockTime+0x1>
    2196:	a0 93 33 2c 	sts	0x2C33, r26	; 0x802c33 <xNextTaskUnblockTime+0x2>
    219a:	b0 93 34 2c 	sts	0x2C34, r27	; 0x802c34 <xNextTaskUnblockTime+0x3>
    219e:	76 c0       	rjmp	.+236    	; 0x228c <xTaskIncrementTick+0x1ce>
    21a0:	80 91 0c 2c 	lds	r24, 0x2C0C	; 0x802c0c <pxDelayedTaskList>
    21a4:	90 91 0d 2c 	lds	r25, 0x2C0D	; 0x802c0d <pxDelayedTaskList+0x1>
    21a8:	fc 01       	movw	r30, r24
    21aa:	87 81       	ldd	r24, Z+7	; 0x07
    21ac:	90 85       	ldd	r25, Z+8	; 0x08
    21ae:	fc 01       	movw	r30, r24
    21b0:	80 85       	ldd	r24, Z+8	; 0x08
    21b2:	91 85       	ldd	r25, Z+9	; 0x09
    21b4:	88 87       	std	Y+8, r24	; 0x08
    21b6:	99 87       	std	Y+9, r25	; 0x09
    21b8:	88 85       	ldd	r24, Y+8	; 0x08
    21ba:	99 85       	ldd	r25, Y+9	; 0x09
    21bc:	fc 01       	movw	r30, r24
    21be:	82 81       	ldd	r24, Z+2	; 0x02
    21c0:	93 81       	ldd	r25, Z+3	; 0x03
    21c2:	a4 81       	ldd	r26, Z+4	; 0x04
    21c4:	b5 81       	ldd	r27, Z+5	; 0x05
    21c6:	8a 87       	std	Y+10, r24	; 0x0a
    21c8:	9b 87       	std	Y+11, r25	; 0x0b
    21ca:	ac 87       	std	Y+12, r26	; 0x0c
    21cc:	bd 87       	std	Y+13, r27	; 0x0d
    21ce:	2a 81       	ldd	r18, Y+2	; 0x02
    21d0:	3b 81       	ldd	r19, Y+3	; 0x03
    21d2:	4c 81       	ldd	r20, Y+4	; 0x04
    21d4:	5d 81       	ldd	r21, Y+5	; 0x05
    21d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    21d8:	9b 85       	ldd	r25, Y+11	; 0x0b
    21da:	ac 85       	ldd	r26, Y+12	; 0x0c
    21dc:	bd 85       	ldd	r27, Y+13	; 0x0d
    21de:	28 17       	cp	r18, r24
    21e0:	39 07       	cpc	r19, r25
    21e2:	4a 07       	cpc	r20, r26
    21e4:	5b 07       	cpc	r21, r27
    21e6:	68 f4       	brcc	.+26     	; 0x2202 <xTaskIncrementTick+0x144>
    21e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    21ea:	9b 85       	ldd	r25, Y+11	; 0x0b
    21ec:	ac 85       	ldd	r26, Y+12	; 0x0c
    21ee:	bd 85       	ldd	r27, Y+13	; 0x0d
    21f0:	80 93 31 2c 	sts	0x2C31, r24	; 0x802c31 <xNextTaskUnblockTime>
    21f4:	90 93 32 2c 	sts	0x2C32, r25	; 0x802c32 <xNextTaskUnblockTime+0x1>
    21f8:	a0 93 33 2c 	sts	0x2C33, r26	; 0x802c33 <xNextTaskUnblockTime+0x2>
    21fc:	b0 93 34 2c 	sts	0x2C34, r27	; 0x802c34 <xNextTaskUnblockTime+0x3>
    2200:	45 c0       	rjmp	.+138    	; 0x228c <xTaskIncrementTick+0x1ce>
    2202:	88 85       	ldd	r24, Y+8	; 0x08
    2204:	99 85       	ldd	r25, Y+9	; 0x09
    2206:	02 96       	adiw	r24, 0x02	; 2
    2208:	0e 94 ab 06 	call	0xd56	; 0xd56 <uxListRemove>
    220c:	88 85       	ldd	r24, Y+8	; 0x08
    220e:	99 85       	ldd	r25, Y+9	; 0x09
    2210:	fc 01       	movw	r30, r24
    2212:	80 8d       	ldd	r24, Z+24	; 0x18
    2214:	91 8d       	ldd	r25, Z+25	; 0x19
    2216:	89 2b       	or	r24, r25
    2218:	29 f0       	breq	.+10     	; 0x2224 <xTaskIncrementTick+0x166>
    221a:	88 85       	ldd	r24, Y+8	; 0x08
    221c:	99 85       	ldd	r25, Y+9	; 0x09
    221e:	0e 96       	adiw	r24, 0x0e	; 14
    2220:	0e 94 ab 06 	call	0xd56	; 0xd56 <uxListRemove>
    2224:	88 85       	ldd	r24, Y+8	; 0x08
    2226:	99 85       	ldd	r25, Y+9	; 0x09
    2228:	fc 01       	movw	r30, r24
    222a:	92 8d       	ldd	r25, Z+26	; 0x1a
    222c:	80 91 2b 2c 	lds	r24, 0x2C2B	; 0x802c2b <uxTopReadyPriority>
    2230:	89 17       	cp	r24, r25
    2232:	30 f4       	brcc	.+12     	; 0x2240 <xTaskIncrementTick+0x182>
    2234:	88 85       	ldd	r24, Y+8	; 0x08
    2236:	99 85       	ldd	r25, Y+9	; 0x09
    2238:	fc 01       	movw	r30, r24
    223a:	82 8d       	ldd	r24, Z+26	; 0x1a
    223c:	80 93 2b 2c 	sts	0x2C2B, r24	; 0x802c2b <uxTopReadyPriority>
    2240:	88 85       	ldd	r24, Y+8	; 0x08
    2242:	99 85       	ldd	r25, Y+9	; 0x09
    2244:	ac 01       	movw	r20, r24
    2246:	4e 5f       	subi	r20, 0xFE	; 254
    2248:	5f 4f       	sbci	r21, 0xFF	; 255
    224a:	88 85       	ldd	r24, Y+8	; 0x08
    224c:	99 85       	ldd	r25, Y+9	; 0x09
    224e:	fc 01       	movw	r30, r24
    2250:	82 8d       	ldd	r24, Z+26	; 0x1a
    2252:	28 2f       	mov	r18, r24
    2254:	30 e0       	ldi	r19, 0x00	; 0
    2256:	6b e0       	ldi	r22, 0x0B	; 11
    2258:	62 9f       	mul	r22, r18
    225a:	c0 01       	movw	r24, r0
    225c:	63 9f       	mul	r22, r19
    225e:	90 0d       	add	r25, r0
    2260:	11 24       	eor	r1, r1
    2262:	86 53       	subi	r24, 0x36	; 54
    2264:	94 4d       	sbci	r25, 0xD4	; 212
    2266:	ba 01       	movw	r22, r20
    2268:	0e 94 df 05 	call	0xbbe	; 0xbbe <vListInsertEnd>
    226c:	88 85       	ldd	r24, Y+8	; 0x08
    226e:	99 85       	ldd	r25, Y+9	; 0x09
    2270:	fc 01       	movw	r30, r24
    2272:	22 8d       	ldd	r18, Z+26	; 0x1a
    2274:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    2278:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    227c:	fc 01       	movw	r30, r24
    227e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2280:	28 17       	cp	r18, r24
    2282:	08 f4       	brcc	.+2      	; 0x2286 <xTaskIncrementTick+0x1c8>
    2284:	79 cf       	rjmp	.-270    	; 0x2178 <xTaskIncrementTick+0xba>
    2286:	81 e0       	ldi	r24, 0x01	; 1
    2288:	89 83       	std	Y+1, r24	; 0x01
    228a:	76 cf       	rjmp	.-276    	; 0x2178 <xTaskIncrementTick+0xba>
    228c:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    2290:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    2294:	fc 01       	movw	r30, r24
    2296:	82 8d       	ldd	r24, Z+26	; 0x1a
    2298:	28 2f       	mov	r18, r24
    229a:	30 e0       	ldi	r19, 0x00	; 0
    229c:	4b e0       	ldi	r20, 0x0B	; 11
    229e:	42 9f       	mul	r20, r18
    22a0:	c0 01       	movw	r24, r0
    22a2:	43 9f       	mul	r20, r19
    22a4:	90 0d       	add	r25, r0
    22a6:	11 24       	eor	r1, r1
    22a8:	86 53       	subi	r24, 0x36	; 54
    22aa:	94 4d       	sbci	r25, 0xD4	; 212
    22ac:	fc 01       	movw	r30, r24
    22ae:	80 81       	ld	r24, Z
    22b0:	82 30       	cpi	r24, 0x02	; 2
    22b2:	40 f0       	brcs	.+16     	; 0x22c4 <xTaskIncrementTick+0x206>
    22b4:	81 e0       	ldi	r24, 0x01	; 1
    22b6:	89 83       	std	Y+1, r24	; 0x01
    22b8:	05 c0       	rjmp	.+10     	; 0x22c4 <xTaskIncrementTick+0x206>
    22ba:	80 91 2d 2c 	lds	r24, 0x2C2D	; 0x802c2d <uxPendedTicks>
    22be:	8f 5f       	subi	r24, 0xFF	; 255
    22c0:	80 93 2d 2c 	sts	0x2C2D, r24	; 0x802c2d <uxPendedTicks>
    22c4:	80 91 2e 2c 	lds	r24, 0x2C2E	; 0x802c2e <xYieldPending>
    22c8:	88 23       	and	r24, r24
    22ca:	11 f0       	breq	.+4      	; 0x22d0 <xTaskIncrementTick+0x212>
    22cc:	81 e0       	ldi	r24, 0x01	; 1
    22ce:	89 83       	std	Y+1, r24	; 0x01
    22d0:	89 81       	ldd	r24, Y+1	; 0x01
    22d2:	2d 96       	adiw	r28, 0x0d	; 13
    22d4:	cd bf       	out	0x3d, r28	; 61
    22d6:	de bf       	out	0x3e, r29	; 62
    22d8:	df 91       	pop	r29
    22da:	cf 91       	pop	r28
    22dc:	08 95       	ret

000022de <vTaskSwitchContext>:
    22de:	cf 93       	push	r28
    22e0:	df 93       	push	r29
    22e2:	cd b7       	in	r28, 0x3d	; 61
    22e4:	de b7       	in	r29, 0x3e	; 62
    22e6:	29 97       	sbiw	r28, 0x09	; 9
    22e8:	cd bf       	out	0x3d, r28	; 61
    22ea:	de bf       	out	0x3e, r29	; 62
    22ec:	80 91 37 2c 	lds	r24, 0x2C37	; 0x802c37 <uxSchedulerSuspended>
    22f0:	88 23       	and	r24, r24
    22f2:	21 f0       	breq	.+8      	; 0x22fc <vTaskSwitchContext+0x1e>
    22f4:	81 e0       	ldi	r24, 0x01	; 1
    22f6:	80 93 2e 2c 	sts	0x2C2E, r24	; 0x802c2e <xYieldPending>
    22fa:	ba c0       	rjmp	.+372    	; 0x2470 <vTaskSwitchContext+0x192>
    22fc:	10 92 2e 2c 	sts	0x2C2E, r1	; 0x802c2e <xYieldPending>
    2300:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    2304:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    2308:	fc 01       	movw	r30, r24
    230a:	83 8d       	ldd	r24, Z+27	; 0x1b
    230c:	94 8d       	ldd	r25, Z+28	; 0x1c
    230e:	8a 83       	std	Y+2, r24	; 0x02
    2310:	9b 83       	std	Y+3, r25	; 0x03
    2312:	85 ea       	ldi	r24, 0xA5	; 165
    2314:	95 ea       	ldi	r25, 0xA5	; 165
    2316:	dc 01       	movw	r26, r24
    2318:	8c 83       	std	Y+4, r24	; 0x04
    231a:	9d 83       	std	Y+5, r25	; 0x05
    231c:	ae 83       	std	Y+6, r26	; 0x06
    231e:	bf 83       	std	Y+7, r27	; 0x07
    2320:	8a 81       	ldd	r24, Y+2	; 0x02
    2322:	9b 81       	ldd	r25, Y+3	; 0x03
    2324:	fc 01       	movw	r30, r24
    2326:	20 81       	ld	r18, Z
    2328:	31 81       	ldd	r19, Z+1	; 0x01
    232a:	42 81       	ldd	r20, Z+2	; 0x02
    232c:	53 81       	ldd	r21, Z+3	; 0x03
    232e:	8c 81       	ldd	r24, Y+4	; 0x04
    2330:	9d 81       	ldd	r25, Y+5	; 0x05
    2332:	ae 81       	ldd	r26, Y+6	; 0x06
    2334:	bf 81       	ldd	r27, Y+7	; 0x07
    2336:	28 17       	cp	r18, r24
    2338:	39 07       	cpc	r19, r25
    233a:	4a 07       	cpc	r20, r26
    233c:	5b 07       	cpc	r21, r27
    233e:	99 f5       	brne	.+102    	; 0x23a6 <vTaskSwitchContext+0xc8>
    2340:	8a 81       	ldd	r24, Y+2	; 0x02
    2342:	9b 81       	ldd	r25, Y+3	; 0x03
    2344:	04 96       	adiw	r24, 0x04	; 4
    2346:	fc 01       	movw	r30, r24
    2348:	20 81       	ld	r18, Z
    234a:	31 81       	ldd	r19, Z+1	; 0x01
    234c:	42 81       	ldd	r20, Z+2	; 0x02
    234e:	53 81       	ldd	r21, Z+3	; 0x03
    2350:	8c 81       	ldd	r24, Y+4	; 0x04
    2352:	9d 81       	ldd	r25, Y+5	; 0x05
    2354:	ae 81       	ldd	r26, Y+6	; 0x06
    2356:	bf 81       	ldd	r27, Y+7	; 0x07
    2358:	28 17       	cp	r18, r24
    235a:	39 07       	cpc	r19, r25
    235c:	4a 07       	cpc	r20, r26
    235e:	5b 07       	cpc	r21, r27
    2360:	11 f5       	brne	.+68     	; 0x23a6 <vTaskSwitchContext+0xc8>
    2362:	8a 81       	ldd	r24, Y+2	; 0x02
    2364:	9b 81       	ldd	r25, Y+3	; 0x03
    2366:	08 96       	adiw	r24, 0x08	; 8
    2368:	fc 01       	movw	r30, r24
    236a:	20 81       	ld	r18, Z
    236c:	31 81       	ldd	r19, Z+1	; 0x01
    236e:	42 81       	ldd	r20, Z+2	; 0x02
    2370:	53 81       	ldd	r21, Z+3	; 0x03
    2372:	8c 81       	ldd	r24, Y+4	; 0x04
    2374:	9d 81       	ldd	r25, Y+5	; 0x05
    2376:	ae 81       	ldd	r26, Y+6	; 0x06
    2378:	bf 81       	ldd	r27, Y+7	; 0x07
    237a:	28 17       	cp	r18, r24
    237c:	39 07       	cpc	r19, r25
    237e:	4a 07       	cpc	r20, r26
    2380:	5b 07       	cpc	r21, r27
    2382:	89 f4       	brne	.+34     	; 0x23a6 <vTaskSwitchContext+0xc8>
    2384:	8a 81       	ldd	r24, Y+2	; 0x02
    2386:	9b 81       	ldd	r25, Y+3	; 0x03
    2388:	0c 96       	adiw	r24, 0x0c	; 12
    238a:	fc 01       	movw	r30, r24
    238c:	20 81       	ld	r18, Z
    238e:	31 81       	ldd	r19, Z+1	; 0x01
    2390:	42 81       	ldd	r20, Z+2	; 0x02
    2392:	53 81       	ldd	r21, Z+3	; 0x03
    2394:	8c 81       	ldd	r24, Y+4	; 0x04
    2396:	9d 81       	ldd	r25, Y+5	; 0x05
    2398:	ae 81       	ldd	r26, Y+6	; 0x06
    239a:	bf 81       	ldd	r27, Y+7	; 0x07
    239c:	28 17       	cp	r18, r24
    239e:	39 07       	cpc	r19, r25
    23a0:	4a 07       	cpc	r20, r26
    23a2:	5b 07       	cpc	r21, r27
    23a4:	71 f0       	breq	.+28     	; 0x23c2 <vTaskSwitchContext+0xe4>
    23a6:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    23aa:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    23ae:	9c 01       	movw	r18, r24
    23b0:	23 5e       	subi	r18, 0xE3	; 227
    23b2:	3f 4f       	sbci	r19, 0xFF	; 255
    23b4:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    23b8:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    23bc:	b9 01       	movw	r22, r18
    23be:	0e 94 79 14 	call	0x28f2	; 0x28f2 <vApplicationStackOverflowHook>
    23c2:	80 91 2b 2c 	lds	r24, 0x2C2B	; 0x802c2b <uxTopReadyPriority>
    23c6:	89 83       	std	Y+1, r24	; 0x01
    23c8:	03 c0       	rjmp	.+6      	; 0x23d0 <vTaskSwitchContext+0xf2>
    23ca:	89 81       	ldd	r24, Y+1	; 0x01
    23cc:	81 50       	subi	r24, 0x01	; 1
    23ce:	89 83       	std	Y+1, r24	; 0x01
    23d0:	89 81       	ldd	r24, Y+1	; 0x01
    23d2:	28 2f       	mov	r18, r24
    23d4:	30 e0       	ldi	r19, 0x00	; 0
    23d6:	4b e0       	ldi	r20, 0x0B	; 11
    23d8:	42 9f       	mul	r20, r18
    23da:	c0 01       	movw	r24, r0
    23dc:	43 9f       	mul	r20, r19
    23de:	90 0d       	add	r25, r0
    23e0:	11 24       	eor	r1, r1
    23e2:	86 53       	subi	r24, 0x36	; 54
    23e4:	94 4d       	sbci	r25, 0xD4	; 212
    23e6:	fc 01       	movw	r30, r24
    23e8:	80 81       	ld	r24, Z
    23ea:	88 23       	and	r24, r24
    23ec:	71 f3       	breq	.-36     	; 0x23ca <vTaskSwitchContext+0xec>
    23ee:	89 81       	ldd	r24, Y+1	; 0x01
    23f0:	28 2f       	mov	r18, r24
    23f2:	30 e0       	ldi	r19, 0x00	; 0
    23f4:	4b e0       	ldi	r20, 0x0B	; 11
    23f6:	42 9f       	mul	r20, r18
    23f8:	c0 01       	movw	r24, r0
    23fa:	43 9f       	mul	r20, r19
    23fc:	90 0d       	add	r25, r0
    23fe:	11 24       	eor	r1, r1
    2400:	86 53       	subi	r24, 0x36	; 54
    2402:	94 4d       	sbci	r25, 0xD4	; 212
    2404:	88 87       	std	Y+8, r24	; 0x08
    2406:	99 87       	std	Y+9, r25	; 0x09
    2408:	88 85       	ldd	r24, Y+8	; 0x08
    240a:	99 85       	ldd	r25, Y+9	; 0x09
    240c:	fc 01       	movw	r30, r24
    240e:	81 81       	ldd	r24, Z+1	; 0x01
    2410:	92 81       	ldd	r25, Z+2	; 0x02
    2412:	fc 01       	movw	r30, r24
    2414:	24 81       	ldd	r18, Z+4	; 0x04
    2416:	35 81       	ldd	r19, Z+5	; 0x05
    2418:	88 85       	ldd	r24, Y+8	; 0x08
    241a:	99 85       	ldd	r25, Y+9	; 0x09
    241c:	fc 01       	movw	r30, r24
    241e:	21 83       	std	Z+1, r18	; 0x01
    2420:	32 83       	std	Z+2, r19	; 0x02
    2422:	88 85       	ldd	r24, Y+8	; 0x08
    2424:	99 85       	ldd	r25, Y+9	; 0x09
    2426:	fc 01       	movw	r30, r24
    2428:	21 81       	ldd	r18, Z+1	; 0x01
    242a:	32 81       	ldd	r19, Z+2	; 0x02
    242c:	88 85       	ldd	r24, Y+8	; 0x08
    242e:	99 85       	ldd	r25, Y+9	; 0x09
    2430:	03 96       	adiw	r24, 0x03	; 3
    2432:	28 17       	cp	r18, r24
    2434:	39 07       	cpc	r19, r25
    2436:	69 f4       	brne	.+26     	; 0x2452 <vTaskSwitchContext+0x174>
    2438:	88 85       	ldd	r24, Y+8	; 0x08
    243a:	99 85       	ldd	r25, Y+9	; 0x09
    243c:	fc 01       	movw	r30, r24
    243e:	81 81       	ldd	r24, Z+1	; 0x01
    2440:	92 81       	ldd	r25, Z+2	; 0x02
    2442:	fc 01       	movw	r30, r24
    2444:	24 81       	ldd	r18, Z+4	; 0x04
    2446:	35 81       	ldd	r19, Z+5	; 0x05
    2448:	88 85       	ldd	r24, Y+8	; 0x08
    244a:	99 85       	ldd	r25, Y+9	; 0x09
    244c:	fc 01       	movw	r30, r24
    244e:	21 83       	std	Z+1, r18	; 0x01
    2450:	32 83       	std	Z+2, r19	; 0x02
    2452:	88 85       	ldd	r24, Y+8	; 0x08
    2454:	99 85       	ldd	r25, Y+9	; 0x09
    2456:	fc 01       	movw	r30, r24
    2458:	81 81       	ldd	r24, Z+1	; 0x01
    245a:	92 81       	ldd	r25, Z+2	; 0x02
    245c:	fc 01       	movw	r30, r24
    245e:	80 85       	ldd	r24, Z+8	; 0x08
    2460:	91 85       	ldd	r25, Z+9	; 0x09
    2462:	80 93 c8 2b 	sts	0x2BC8, r24	; 0x802bc8 <pxCurrentTCB>
    2466:	90 93 c9 2b 	sts	0x2BC9, r25	; 0x802bc9 <pxCurrentTCB+0x1>
    246a:	89 81       	ldd	r24, Y+1	; 0x01
    246c:	80 93 2b 2c 	sts	0x2C2B, r24	; 0x802c2b <uxTopReadyPriority>
    2470:	00 00       	nop
    2472:	29 96       	adiw	r28, 0x09	; 9
    2474:	cd bf       	out	0x3d, r28	; 61
    2476:	de bf       	out	0x3e, r29	; 62
    2478:	df 91       	pop	r29
    247a:	cf 91       	pop	r28
    247c:	08 95       	ret

0000247e <xTaskRemoveFromEventList>:
    247e:	cf 93       	push	r28
    2480:	df 93       	push	r29
    2482:	cd b7       	in	r28, 0x3d	; 61
    2484:	de b7       	in	r29, 0x3e	; 62
    2486:	25 97       	sbiw	r28, 0x05	; 5
    2488:	cd bf       	out	0x3d, r28	; 61
    248a:	de bf       	out	0x3e, r29	; 62
    248c:	8c 83       	std	Y+4, r24	; 0x04
    248e:	9d 83       	std	Y+5, r25	; 0x05
    2490:	8c 81       	ldd	r24, Y+4	; 0x04
    2492:	9d 81       	ldd	r25, Y+5	; 0x05
    2494:	fc 01       	movw	r30, r24
    2496:	87 81       	ldd	r24, Z+7	; 0x07
    2498:	90 85       	ldd	r25, Z+8	; 0x08
    249a:	fc 01       	movw	r30, r24
    249c:	80 85       	ldd	r24, Z+8	; 0x08
    249e:	91 85       	ldd	r25, Z+9	; 0x09
    24a0:	8a 83       	std	Y+2, r24	; 0x02
    24a2:	9b 83       	std	Y+3, r25	; 0x03
    24a4:	8a 81       	ldd	r24, Y+2	; 0x02
    24a6:	9b 81       	ldd	r25, Y+3	; 0x03
    24a8:	0e 96       	adiw	r24, 0x0e	; 14
    24aa:	0e 94 ab 06 	call	0xd56	; 0xd56 <uxListRemove>
    24ae:	80 91 37 2c 	lds	r24, 0x2C37	; 0x802c37 <uxSchedulerSuspended>
    24b2:	88 23       	and	r24, r24
    24b4:	51 f5       	brne	.+84     	; 0x250a <xTaskRemoveFromEventList+0x8c>
    24b6:	8a 81       	ldd	r24, Y+2	; 0x02
    24b8:	9b 81       	ldd	r25, Y+3	; 0x03
    24ba:	02 96       	adiw	r24, 0x02	; 2
    24bc:	0e 94 ab 06 	call	0xd56	; 0xd56 <uxListRemove>
    24c0:	8a 81       	ldd	r24, Y+2	; 0x02
    24c2:	9b 81       	ldd	r25, Y+3	; 0x03
    24c4:	fc 01       	movw	r30, r24
    24c6:	92 8d       	ldd	r25, Z+26	; 0x1a
    24c8:	80 91 2b 2c 	lds	r24, 0x2C2B	; 0x802c2b <uxTopReadyPriority>
    24cc:	89 17       	cp	r24, r25
    24ce:	30 f4       	brcc	.+12     	; 0x24dc <xTaskRemoveFromEventList+0x5e>
    24d0:	8a 81       	ldd	r24, Y+2	; 0x02
    24d2:	9b 81       	ldd	r25, Y+3	; 0x03
    24d4:	fc 01       	movw	r30, r24
    24d6:	82 8d       	ldd	r24, Z+26	; 0x1a
    24d8:	80 93 2b 2c 	sts	0x2C2B, r24	; 0x802c2b <uxTopReadyPriority>
    24dc:	8a 81       	ldd	r24, Y+2	; 0x02
    24de:	9b 81       	ldd	r25, Y+3	; 0x03
    24e0:	ac 01       	movw	r20, r24
    24e2:	4e 5f       	subi	r20, 0xFE	; 254
    24e4:	5f 4f       	sbci	r21, 0xFF	; 255
    24e6:	8a 81       	ldd	r24, Y+2	; 0x02
    24e8:	9b 81       	ldd	r25, Y+3	; 0x03
    24ea:	fc 01       	movw	r30, r24
    24ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    24ee:	28 2f       	mov	r18, r24
    24f0:	30 e0       	ldi	r19, 0x00	; 0
    24f2:	6b e0       	ldi	r22, 0x0B	; 11
    24f4:	62 9f       	mul	r22, r18
    24f6:	c0 01       	movw	r24, r0
    24f8:	63 9f       	mul	r22, r19
    24fa:	90 0d       	add	r25, r0
    24fc:	11 24       	eor	r1, r1
    24fe:	86 53       	subi	r24, 0x36	; 54
    2500:	94 4d       	sbci	r25, 0xD4	; 212
    2502:	ba 01       	movw	r22, r20
    2504:	0e 94 df 05 	call	0xbbe	; 0xbbe <vListInsertEnd>
    2508:	08 c0       	rjmp	.+16     	; 0x251a <xTaskRemoveFromEventList+0x9c>
    250a:	8a 81       	ldd	r24, Y+2	; 0x02
    250c:	9b 81       	ldd	r25, Y+3	; 0x03
    250e:	0e 96       	adiw	r24, 0x0e	; 14
    2510:	bc 01       	movw	r22, r24
    2512:	80 e1       	ldi	r24, 0x10	; 16
    2514:	9c e2       	ldi	r25, 0x2C	; 44
    2516:	0e 94 df 05 	call	0xbbe	; 0xbbe <vListInsertEnd>
    251a:	8a 81       	ldd	r24, Y+2	; 0x02
    251c:	9b 81       	ldd	r25, Y+3	; 0x03
    251e:	fc 01       	movw	r30, r24
    2520:	22 8d       	ldd	r18, Z+26	; 0x1a
    2522:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    2526:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    252a:	fc 01       	movw	r30, r24
    252c:	82 8d       	ldd	r24, Z+26	; 0x1a
    252e:	82 17       	cp	r24, r18
    2530:	30 f4       	brcc	.+12     	; 0x253e <xTaskRemoveFromEventList+0xc0>
    2532:	81 e0       	ldi	r24, 0x01	; 1
    2534:	89 83       	std	Y+1, r24	; 0x01
    2536:	81 e0       	ldi	r24, 0x01	; 1
    2538:	80 93 2e 2c 	sts	0x2C2E, r24	; 0x802c2e <xYieldPending>
    253c:	01 c0       	rjmp	.+2      	; 0x2540 <xTaskRemoveFromEventList+0xc2>
    253e:	19 82       	std	Y+1, r1	; 0x01
    2540:	89 81       	ldd	r24, Y+1	; 0x01
    2542:	25 96       	adiw	r28, 0x05	; 5
    2544:	cd bf       	out	0x3d, r28	; 61
    2546:	de bf       	out	0x3e, r29	; 62
    2548:	df 91       	pop	r29
    254a:	cf 91       	pop	r28
    254c:	08 95       	ret

0000254e <prvIdleTask>:
    254e:	cf 93       	push	r28
    2550:	df 93       	push	r29
    2552:	1f 92       	push	r1
    2554:	1f 92       	push	r1
    2556:	cd b7       	in	r28, 0x3d	; 61
    2558:	de b7       	in	r29, 0x3e	; 62
    255a:	89 83       	std	Y+1, r24	; 0x01
    255c:	9a 83       	std	Y+2, r25	; 0x02
    255e:	0e 94 f5 12 	call	0x25ea	; 0x25ea <prvCheckTasksWaitingTermination>
    2562:	80 91 ca 2b 	lds	r24, 0x2BCA	; 0x802bca <pxReadyTasksLists>
    2566:	82 30       	cpi	r24, 0x02	; 2
    2568:	10 f0       	brcs	.+4      	; 0x256e <prvIdleTask+0x20>
    256a:	0e 94 2a 09 	call	0x1254	; 0x1254 <vPortYield>
    256e:	0e 94 8c 17 	call	0x2f18	; 0x2f18 <vApplicationIdleHook>
    2572:	f5 cf       	rjmp	.-22     	; 0x255e <prvIdleTask+0x10>

00002574 <prvInitialiseTaskLists>:
    2574:	cf 93       	push	r28
    2576:	df 93       	push	r29
    2578:	1f 92       	push	r1
    257a:	cd b7       	in	r28, 0x3d	; 61
    257c:	de b7       	in	r29, 0x3e	; 62
    257e:	19 82       	std	Y+1, r1	; 0x01
    2580:	10 c0       	rjmp	.+32     	; 0x25a2 <prvInitialiseTaskLists+0x2e>
    2582:	89 81       	ldd	r24, Y+1	; 0x01
    2584:	28 2f       	mov	r18, r24
    2586:	30 e0       	ldi	r19, 0x00	; 0
    2588:	4b e0       	ldi	r20, 0x0B	; 11
    258a:	42 9f       	mul	r20, r18
    258c:	c0 01       	movw	r24, r0
    258e:	43 9f       	mul	r20, r19
    2590:	90 0d       	add	r25, r0
    2592:	11 24       	eor	r1, r1
    2594:	86 53       	subi	r24, 0x36	; 54
    2596:	94 4d       	sbci	r25, 0xD4	; 212
    2598:	0e 94 92 05 	call	0xb24	; 0xb24 <vListInitialise>
    259c:	89 81       	ldd	r24, Y+1	; 0x01
    259e:	8f 5f       	subi	r24, 0xFF	; 255
    25a0:	89 83       	std	Y+1, r24	; 0x01
    25a2:	89 81       	ldd	r24, Y+1	; 0x01
    25a4:	84 30       	cpi	r24, 0x04	; 4
    25a6:	68 f3       	brcs	.-38     	; 0x2582 <prvInitialiseTaskLists+0xe>
    25a8:	86 ef       	ldi	r24, 0xF6	; 246
    25aa:	9b e2       	ldi	r25, 0x2B	; 43
    25ac:	0e 94 92 05 	call	0xb24	; 0xb24 <vListInitialise>
    25b0:	81 e0       	ldi	r24, 0x01	; 1
    25b2:	9c e2       	ldi	r25, 0x2C	; 44
    25b4:	0e 94 92 05 	call	0xb24	; 0xb24 <vListInitialise>
    25b8:	80 e1       	ldi	r24, 0x10	; 16
    25ba:	9c e2       	ldi	r25, 0x2C	; 44
    25bc:	0e 94 92 05 	call	0xb24	; 0xb24 <vListInitialise>
    25c0:	8b e1       	ldi	r24, 0x1B	; 27
    25c2:	9c e2       	ldi	r25, 0x2C	; 44
    25c4:	0e 94 92 05 	call	0xb24	; 0xb24 <vListInitialise>
    25c8:	86 ef       	ldi	r24, 0xF6	; 246
    25ca:	9b e2       	ldi	r25, 0x2B	; 43
    25cc:	80 93 0c 2c 	sts	0x2C0C, r24	; 0x802c0c <pxDelayedTaskList>
    25d0:	90 93 0d 2c 	sts	0x2C0D, r25	; 0x802c0d <pxDelayedTaskList+0x1>
    25d4:	81 e0       	ldi	r24, 0x01	; 1
    25d6:	9c e2       	ldi	r25, 0x2C	; 44
    25d8:	80 93 0e 2c 	sts	0x2C0E, r24	; 0x802c0e <pxOverflowDelayedTaskList>
    25dc:	90 93 0f 2c 	sts	0x2C0F, r25	; 0x802c0f <pxOverflowDelayedTaskList+0x1>
    25e0:	00 00       	nop
    25e2:	0f 90       	pop	r0
    25e4:	df 91       	pop	r29
    25e6:	cf 91       	pop	r28
    25e8:	08 95       	ret

000025ea <prvCheckTasksWaitingTermination>:
    25ea:	cf 93       	push	r28
    25ec:	df 93       	push	r29
    25ee:	cd b7       	in	r28, 0x3d	; 61
    25f0:	de b7       	in	r29, 0x3e	; 62
    25f2:	00 00       	nop
    25f4:	df 91       	pop	r29
    25f6:	cf 91       	pop	r28
    25f8:	08 95       	ret

000025fa <prvTaskCheckFreeStackSpace>:
    25fa:	cf 93       	push	r28
    25fc:	df 93       	push	r29
    25fe:	00 d0       	rcall	.+0      	; 0x2600 <prvTaskCheckFreeStackSpace+0x6>
    2600:	00 d0       	rcall	.+0      	; 0x2602 <prvTaskCheckFreeStackSpace+0x8>
    2602:	cd b7       	in	r28, 0x3d	; 61
    2604:	de b7       	in	r29, 0x3e	; 62
    2606:	8d 83       	std	Y+5, r24	; 0x05
    2608:	9e 83       	std	Y+6, r25	; 0x06
    260a:	19 82       	std	Y+1, r1	; 0x01
    260c:	1a 82       	std	Y+2, r1	; 0x02
    260e:	1b 82       	std	Y+3, r1	; 0x03
    2610:	1c 82       	std	Y+4, r1	; 0x04
    2612:	10 c0       	rjmp	.+32     	; 0x2634 <prvTaskCheckFreeStackSpace+0x3a>
    2614:	8d 81       	ldd	r24, Y+5	; 0x05
    2616:	9e 81       	ldd	r25, Y+6	; 0x06
    2618:	01 96       	adiw	r24, 0x01	; 1
    261a:	8d 83       	std	Y+5, r24	; 0x05
    261c:	9e 83       	std	Y+6, r25	; 0x06
    261e:	89 81       	ldd	r24, Y+1	; 0x01
    2620:	9a 81       	ldd	r25, Y+2	; 0x02
    2622:	ab 81       	ldd	r26, Y+3	; 0x03
    2624:	bc 81       	ldd	r27, Y+4	; 0x04
    2626:	01 96       	adiw	r24, 0x01	; 1
    2628:	a1 1d       	adc	r26, r1
    262a:	b1 1d       	adc	r27, r1
    262c:	89 83       	std	Y+1, r24	; 0x01
    262e:	9a 83       	std	Y+2, r25	; 0x02
    2630:	ab 83       	std	Y+3, r26	; 0x03
    2632:	bc 83       	std	Y+4, r27	; 0x04
    2634:	8d 81       	ldd	r24, Y+5	; 0x05
    2636:	9e 81       	ldd	r25, Y+6	; 0x06
    2638:	fc 01       	movw	r30, r24
    263a:	80 81       	ld	r24, Z
    263c:	85 3a       	cpi	r24, 0xA5	; 165
    263e:	51 f3       	breq	.-44     	; 0x2614 <prvTaskCheckFreeStackSpace+0x1a>
    2640:	89 81       	ldd	r24, Y+1	; 0x01
    2642:	9a 81       	ldd	r25, Y+2	; 0x02
    2644:	26 96       	adiw	r28, 0x06	; 6
    2646:	cd bf       	out	0x3d, r28	; 61
    2648:	de bf       	out	0x3e, r29	; 62
    264a:	df 91       	pop	r29
    264c:	cf 91       	pop	r28
    264e:	08 95       	ret

00002650 <uxTaskGetStackHighWaterMark>:
    2650:	cf 93       	push	r28
    2652:	df 93       	push	r29
    2654:	cd b7       	in	r28, 0x3d	; 61
    2656:	de b7       	in	r29, 0x3e	; 62
    2658:	27 97       	sbiw	r28, 0x07	; 7
    265a:	cd bf       	out	0x3d, r28	; 61
    265c:	de bf       	out	0x3e, r29	; 62
    265e:	8e 83       	std	Y+6, r24	; 0x06
    2660:	9f 83       	std	Y+7, r25	; 0x07
    2662:	8e 81       	ldd	r24, Y+6	; 0x06
    2664:	9f 81       	ldd	r25, Y+7	; 0x07
    2666:	89 2b       	or	r24, r25
    2668:	29 f4       	brne	.+10     	; 0x2674 <uxTaskGetStackHighWaterMark+0x24>
    266a:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    266e:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    2672:	02 c0       	rjmp	.+4      	; 0x2678 <uxTaskGetStackHighWaterMark+0x28>
    2674:	8e 81       	ldd	r24, Y+6	; 0x06
    2676:	9f 81       	ldd	r25, Y+7	; 0x07
    2678:	89 83       	std	Y+1, r24	; 0x01
    267a:	9a 83       	std	Y+2, r25	; 0x02
    267c:	89 81       	ldd	r24, Y+1	; 0x01
    267e:	9a 81       	ldd	r25, Y+2	; 0x02
    2680:	fc 01       	movw	r30, r24
    2682:	83 8d       	ldd	r24, Z+27	; 0x1b
    2684:	94 8d       	ldd	r25, Z+28	; 0x1c
    2686:	8b 83       	std	Y+3, r24	; 0x03
    2688:	9c 83       	std	Y+4, r25	; 0x04
    268a:	8b 81       	ldd	r24, Y+3	; 0x03
    268c:	9c 81       	ldd	r25, Y+4	; 0x04
    268e:	0e 94 fd 12 	call	0x25fa	; 0x25fa <prvTaskCheckFreeStackSpace>
    2692:	8d 83       	std	Y+5, r24	; 0x05
    2694:	8d 81       	ldd	r24, Y+5	; 0x05
    2696:	27 96       	adiw	r28, 0x07	; 7
    2698:	cd bf       	out	0x3d, r28	; 61
    269a:	de bf       	out	0x3e, r29	; 62
    269c:	df 91       	pop	r29
    269e:	cf 91       	pop	r28
    26a0:	08 95       	ret

000026a2 <prvResetNextTaskUnblockTime>:
    26a2:	cf 93       	push	r28
    26a4:	df 93       	push	r29
    26a6:	1f 92       	push	r1
    26a8:	1f 92       	push	r1
    26aa:	cd b7       	in	r28, 0x3d	; 61
    26ac:	de b7       	in	r29, 0x3e	; 62
    26ae:	80 91 0c 2c 	lds	r24, 0x2C0C	; 0x802c0c <pxDelayedTaskList>
    26b2:	90 91 0d 2c 	lds	r25, 0x2C0D	; 0x802c0d <pxDelayedTaskList+0x1>
    26b6:	fc 01       	movw	r30, r24
    26b8:	80 81       	ld	r24, Z
    26ba:	88 23       	and	r24, r24
    26bc:	61 f4       	brne	.+24     	; 0x26d6 <prvResetNextTaskUnblockTime+0x34>
    26be:	8f ef       	ldi	r24, 0xFF	; 255
    26c0:	9f ef       	ldi	r25, 0xFF	; 255
    26c2:	dc 01       	movw	r26, r24
    26c4:	80 93 31 2c 	sts	0x2C31, r24	; 0x802c31 <xNextTaskUnblockTime>
    26c8:	90 93 32 2c 	sts	0x2C32, r25	; 0x802c32 <xNextTaskUnblockTime+0x1>
    26cc:	a0 93 33 2c 	sts	0x2C33, r26	; 0x802c33 <xNextTaskUnblockTime+0x2>
    26d0:	b0 93 34 2c 	sts	0x2C34, r27	; 0x802c34 <xNextTaskUnblockTime+0x3>
    26d4:	1b c0       	rjmp	.+54     	; 0x270c <prvResetNextTaskUnblockTime+0x6a>
    26d6:	80 91 0c 2c 	lds	r24, 0x2C0C	; 0x802c0c <pxDelayedTaskList>
    26da:	90 91 0d 2c 	lds	r25, 0x2C0D	; 0x802c0d <pxDelayedTaskList+0x1>
    26de:	fc 01       	movw	r30, r24
    26e0:	87 81       	ldd	r24, Z+7	; 0x07
    26e2:	90 85       	ldd	r25, Z+8	; 0x08
    26e4:	fc 01       	movw	r30, r24
    26e6:	80 85       	ldd	r24, Z+8	; 0x08
    26e8:	91 85       	ldd	r25, Z+9	; 0x09
    26ea:	89 83       	std	Y+1, r24	; 0x01
    26ec:	9a 83       	std	Y+2, r25	; 0x02
    26ee:	89 81       	ldd	r24, Y+1	; 0x01
    26f0:	9a 81       	ldd	r25, Y+2	; 0x02
    26f2:	fc 01       	movw	r30, r24
    26f4:	82 81       	ldd	r24, Z+2	; 0x02
    26f6:	93 81       	ldd	r25, Z+3	; 0x03
    26f8:	a4 81       	ldd	r26, Z+4	; 0x04
    26fa:	b5 81       	ldd	r27, Z+5	; 0x05
    26fc:	80 93 31 2c 	sts	0x2C31, r24	; 0x802c31 <xNextTaskUnblockTime>
    2700:	90 93 32 2c 	sts	0x2C32, r25	; 0x802c32 <xNextTaskUnblockTime+0x1>
    2704:	a0 93 33 2c 	sts	0x2C33, r26	; 0x802c33 <xNextTaskUnblockTime+0x2>
    2708:	b0 93 34 2c 	sts	0x2C34, r27	; 0x802c34 <xNextTaskUnblockTime+0x3>
    270c:	00 00       	nop
    270e:	0f 90       	pop	r0
    2710:	0f 90       	pop	r0
    2712:	df 91       	pop	r29
    2714:	cf 91       	pop	r28
    2716:	08 95       	ret

00002718 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    2718:	cf 93       	push	r28
    271a:	df 93       	push	r29
    271c:	cd b7       	in	r28, 0x3d	; 61
    271e:	de b7       	in	r29, 0x3e	; 62
    2720:	2d 97       	sbiw	r28, 0x0d	; 13
    2722:	cd bf       	out	0x3d, r28	; 61
    2724:	de bf       	out	0x3e, r29	; 62
    2726:	69 87       	std	Y+9, r22	; 0x09
    2728:	7a 87       	std	Y+10, r23	; 0x0a
    272a:	8b 87       	std	Y+11, r24	; 0x0b
    272c:	9c 87       	std	Y+12, r25	; 0x0c
    272e:	4d 87       	std	Y+13, r20	; 0x0d
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    2730:	80 91 27 2c 	lds	r24, 0x2C27	; 0x802c27 <xTickCount>
    2734:	90 91 28 2c 	lds	r25, 0x2C28	; 0x802c28 <xTickCount+0x1>
    2738:	a0 91 29 2c 	lds	r26, 0x2C29	; 0x802c29 <xTickCount+0x2>
    273c:	b0 91 2a 2c 	lds	r27, 0x2C2A	; 0x802c2a <xTickCount+0x3>
    2740:	89 83       	std	Y+1, r24	; 0x01
    2742:	9a 83       	std	Y+2, r25	; 0x02
    2744:	ab 83       	std	Y+3, r26	; 0x03
    2746:	bc 83       	std	Y+4, r27	; 0x04
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2748:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    274c:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    2750:	02 96       	adiw	r24, 0x02	; 2
    2752:	0e 94 ab 06 	call	0xd56	; 0xd56 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    2756:	89 85       	ldd	r24, Y+9	; 0x09
    2758:	9a 85       	ldd	r25, Y+10	; 0x0a
    275a:	ab 85       	ldd	r26, Y+11	; 0x0b
    275c:	bc 85       	ldd	r27, Y+12	; 0x0c
    275e:	8f 3f       	cpi	r24, 0xFF	; 255
    2760:	9f 4f       	sbci	r25, 0xFF	; 255
    2762:	af 4f       	sbci	r26, 0xFF	; 255
    2764:	bf 4f       	sbci	r27, 0xFF	; 255
    2766:	71 f4       	brne	.+28     	; 0x2784 <prvAddCurrentTaskToDelayedList+0x6c>
    2768:	8d 85       	ldd	r24, Y+13	; 0x0d
    276a:	88 23       	and	r24, r24
    276c:	59 f0       	breq	.+22     	; 0x2784 <prvAddCurrentTaskToDelayedList+0x6c>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    276e:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    2772:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    2776:	02 96       	adiw	r24, 0x02	; 2
    2778:	bc 01       	movw	r22, r24
    277a:	8b e1       	ldi	r24, 0x1B	; 27
    277c:	9c e2       	ldi	r25, 0x2C	; 44
    277e:	0e 94 df 05 	call	0xbbe	; 0xbbe <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2782:	64 c0       	rjmp	.+200    	; 0x284c <prvAddCurrentTaskToDelayedList+0x134>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    2784:	29 81       	ldd	r18, Y+1	; 0x01
    2786:	3a 81       	ldd	r19, Y+2	; 0x02
    2788:	4b 81       	ldd	r20, Y+3	; 0x03
    278a:	5c 81       	ldd	r21, Y+4	; 0x04
    278c:	89 85       	ldd	r24, Y+9	; 0x09
    278e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2790:	ab 85       	ldd	r26, Y+11	; 0x0b
    2792:	bc 85       	ldd	r27, Y+12	; 0x0c
    2794:	82 0f       	add	r24, r18
    2796:	93 1f       	adc	r25, r19
    2798:	a4 1f       	adc	r26, r20
    279a:	b5 1f       	adc	r27, r21
    279c:	8d 83       	std	Y+5, r24	; 0x05
    279e:	9e 83       	std	Y+6, r25	; 0x06
    27a0:	af 83       	std	Y+7, r26	; 0x07
    27a2:	b8 87       	std	Y+8, r27	; 0x08

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    27a4:	20 91 c8 2b 	lds	r18, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    27a8:	30 91 c9 2b 	lds	r19, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    27ac:	8d 81       	ldd	r24, Y+5	; 0x05
    27ae:	9e 81       	ldd	r25, Y+6	; 0x06
    27b0:	af 81       	ldd	r26, Y+7	; 0x07
    27b2:	b8 85       	ldd	r27, Y+8	; 0x08
    27b4:	f9 01       	movw	r30, r18
    27b6:	82 83       	std	Z+2, r24	; 0x02
    27b8:	93 83       	std	Z+3, r25	; 0x03
    27ba:	a4 83       	std	Z+4, r26	; 0x04
    27bc:	b5 83       	std	Z+5, r27	; 0x05

			if( xTimeToWake < xConstTickCount )
    27be:	2d 81       	ldd	r18, Y+5	; 0x05
    27c0:	3e 81       	ldd	r19, Y+6	; 0x06
    27c2:	4f 81       	ldd	r20, Y+7	; 0x07
    27c4:	58 85       	ldd	r21, Y+8	; 0x08
    27c6:	89 81       	ldd	r24, Y+1	; 0x01
    27c8:	9a 81       	ldd	r25, Y+2	; 0x02
    27ca:	ab 81       	ldd	r26, Y+3	; 0x03
    27cc:	bc 81       	ldd	r27, Y+4	; 0x04
    27ce:	28 17       	cp	r18, r24
    27d0:	39 07       	cpc	r19, r25
    27d2:	4a 07       	cpc	r20, r26
    27d4:	5b 07       	cpc	r21, r27
    27d6:	78 f4       	brcc	.+30     	; 0x27f6 <prvAddCurrentTaskToDelayedList+0xde>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    27d8:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    27dc:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    27e0:	9c 01       	movw	r18, r24
    27e2:	2e 5f       	subi	r18, 0xFE	; 254
    27e4:	3f 4f       	sbci	r19, 0xFF	; 255
    27e6:	80 91 0e 2c 	lds	r24, 0x2C0E	; 0x802c0e <pxOverflowDelayedTaskList>
    27ea:	90 91 0f 2c 	lds	r25, 0x2C0F	; 0x802c0f <pxOverflowDelayedTaskList+0x1>
    27ee:	b9 01       	movw	r22, r18
    27f0:	0e 94 2a 06 	call	0xc54	; 0xc54 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    27f4:	2b c0       	rjmp	.+86     	; 0x284c <prvAddCurrentTaskToDelayedList+0x134>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    27f6:	80 91 c8 2b 	lds	r24, 0x2BC8	; 0x802bc8 <pxCurrentTCB>
    27fa:	90 91 c9 2b 	lds	r25, 0x2BC9	; 0x802bc9 <pxCurrentTCB+0x1>
    27fe:	9c 01       	movw	r18, r24
    2800:	2e 5f       	subi	r18, 0xFE	; 254
    2802:	3f 4f       	sbci	r19, 0xFF	; 255
    2804:	80 91 0c 2c 	lds	r24, 0x2C0C	; 0x802c0c <pxDelayedTaskList>
    2808:	90 91 0d 2c 	lds	r25, 0x2C0D	; 0x802c0d <pxDelayedTaskList+0x1>
    280c:	b9 01       	movw	r22, r18
    280e:	0e 94 2a 06 	call	0xc54	; 0xc54 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    2812:	80 91 31 2c 	lds	r24, 0x2C31	; 0x802c31 <xNextTaskUnblockTime>
    2816:	90 91 32 2c 	lds	r25, 0x2C32	; 0x802c32 <xNextTaskUnblockTime+0x1>
    281a:	a0 91 33 2c 	lds	r26, 0x2C33	; 0x802c33 <xNextTaskUnblockTime+0x2>
    281e:	b0 91 34 2c 	lds	r27, 0x2C34	; 0x802c34 <xNextTaskUnblockTime+0x3>
    2822:	2d 81       	ldd	r18, Y+5	; 0x05
    2824:	3e 81       	ldd	r19, Y+6	; 0x06
    2826:	4f 81       	ldd	r20, Y+7	; 0x07
    2828:	58 85       	ldd	r21, Y+8	; 0x08
    282a:	28 17       	cp	r18, r24
    282c:	39 07       	cpc	r19, r25
    282e:	4a 07       	cpc	r20, r26
    2830:	5b 07       	cpc	r21, r27
    2832:	60 f4       	brcc	.+24     	; 0x284c <prvAddCurrentTaskToDelayedList+0x134>
				{
					xNextTaskUnblockTime = xTimeToWake;
    2834:	8d 81       	ldd	r24, Y+5	; 0x05
    2836:	9e 81       	ldd	r25, Y+6	; 0x06
    2838:	af 81       	ldd	r26, Y+7	; 0x07
    283a:	b8 85       	ldd	r27, Y+8	; 0x08
    283c:	80 93 31 2c 	sts	0x2C31, r24	; 0x802c31 <xNextTaskUnblockTime>
    2840:	90 93 32 2c 	sts	0x2C32, r25	; 0x802c32 <xNextTaskUnblockTime+0x1>
    2844:	a0 93 33 2c 	sts	0x2C33, r26	; 0x802c33 <xNextTaskUnblockTime+0x2>
    2848:	b0 93 34 2c 	sts	0x2C34, r27	; 0x802c34 <xNextTaskUnblockTime+0x3>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    284c:	00 00       	nop
    284e:	2d 96       	adiw	r28, 0x0d	; 13
    2850:	cd bf       	out	0x3d, r28	; 61
    2852:	de bf       	out	0x3e, r29	; 62
    2854:	df 91       	pop	r29
    2856:	cf 91       	pop	r28
    2858:	08 95       	ret

0000285a <checkAllStacks>:
// sleep instead.
//
#if RUNTIME_CHECKS == 1

void checkAllStacks(void)
{
    285a:	cf 93       	push	r28
    285c:	df 93       	push	r29
    285e:	1f 92       	push	r1
    2860:	cd b7       	in	r28, 0x3d	; 61
    2862:	de b7       	in	r29, 0x3e	; 62
	const unsigned portBASE_TYPE min = 20;
    2864:	84 e1       	ldi	r24, 0x14	; 20
    2866:	89 83       	std	Y+1, r24	; 0x01

	minStackSpace_Idle	= uxTaskGetStackHighWaterMark( ( xTaskHandle ) NULL );
    2868:	80 e0       	ldi	r24, 0x00	; 0
    286a:	90 e0       	ldi	r25, 0x00	; 0
    286c:	0e 94 28 13 	call	0x2650	; 0x2650 <uxTaskGetStackHighWaterMark>
    2870:	80 93 39 2c 	sts	0x2C39, r24	; 0x802c39 <minStackSpace_Idle>
	
	minStackSpace_C0s 	= uxTaskGetStackHighWaterMark( ( xTaskHandle ) hUSARTC0_Send );
    2874:	80 91 73 2c 	lds	r24, 0x2C73	; 0x802c73 <hUSARTC0_Send>
    2878:	90 91 74 2c 	lds	r25, 0x2C74	; 0x802c74 <hUSARTC0_Send+0x1>
    287c:	0e 94 28 13 	call	0x2650	; 0x2650 <uxTaskGetStackHighWaterMark>
    2880:	80 93 3c 2c 	sts	0x2C3C, r24	; 0x802c3c <minStackSpace_C0s>
	
	minStackSpace_C1 	= uxTaskGetStackHighWaterMark( ( xTaskHandle ) hUSARTC1_Receive );
    2884:	80 91 69 2c 	lds	r24, 0x2C69	; 0x802c69 <hUSARTC1_Receive>
    2888:	90 91 6a 2c 	lds	r25, 0x2C6A	; 0x802c6a <hUSARTC1_Receive+0x1>
    288c:	0e 94 28 13 	call	0x2650	; 0x2650 <uxTaskGetStackHighWaterMark>
    2890:	80 93 3b 2c 	sts	0x2C3B, r24	; 0x802c3b <minStackSpace_C1>
	
	minStackSpace_E0 	= uxTaskGetStackHighWaterMark( ( xTaskHandle ) hUSARTE0_Receive );
    2894:	80 91 61 2c 	lds	r24, 0x2C61	; 0x802c61 <hUSARTE0_Receive>
    2898:	90 91 62 2c 	lds	r25, 0x2C62	; 0x802c62 <hUSARTE0_Receive+0x1>
    289c:	0e 94 28 13 	call	0x2650	; 0x2650 <uxTaskGetStackHighWaterMark>
    28a0:	80 93 3a 2c 	sts	0x2C3A, r24	; 0x802c3a <minStackSpace_E0>
	
	if(minStackSpace_C0s<min ||
    28a4:	90 91 3c 2c 	lds	r25, 0x2C3C	; 0x802c3c <minStackSpace_C0s>
    28a8:	89 81       	ldd	r24, Y+1	; 0x01
    28aa:	98 17       	cp	r25, r24
    28ac:	78 f0       	brcs	.+30     	; 0x28cc <checkAllStacks+0x72>
	   minStackSpace_C1<min  || 
    28ae:	90 91 3b 2c 	lds	r25, 0x2C3B	; 0x802c3b <minStackSpace_C1>
	
	minStackSpace_C1 	= uxTaskGetStackHighWaterMark( ( xTaskHandle ) hUSARTC1_Receive );
	
	minStackSpace_E0 	= uxTaskGetStackHighWaterMark( ( xTaskHandle ) hUSARTE0_Receive );
	
	if(minStackSpace_C0s<min ||
    28b2:	89 81       	ldd	r24, Y+1	; 0x01
    28b4:	98 17       	cp	r25, r24
    28b6:	50 f0       	brcs	.+20     	; 0x28cc <checkAllStacks+0x72>
	   minStackSpace_C1<min  || 
	   minStackSpace_E0<min  || 
    28b8:	90 91 3a 2c 	lds	r25, 0x2C3A	; 0x802c3a <minStackSpace_E0>
	minStackSpace_C1 	= uxTaskGetStackHighWaterMark( ( xTaskHandle ) hUSARTC1_Receive );
	
	minStackSpace_E0 	= uxTaskGetStackHighWaterMark( ( xTaskHandle ) hUSARTE0_Receive );
	
	if(minStackSpace_C0s<min ||
	   minStackSpace_C1<min  || 
    28bc:	89 81       	ldd	r24, Y+1	; 0x01
    28be:	98 17       	cp	r25, r24
    28c0:	28 f0       	brcs	.+10     	; 0x28cc <checkAllStacks+0x72>
	   minStackSpace_E0<min  || 
	   minStackSpace_Idle<min)
    28c2:	90 91 39 2c 	lds	r25, 0x2C39	; 0x802c39 <minStackSpace_Idle>
	
	minStackSpace_E0 	= uxTaskGetStackHighWaterMark( ( xTaskHandle ) hUSARTE0_Receive );
	
	if(minStackSpace_C0s<min ||
	   minStackSpace_C1<min  || 
	   minStackSpace_E0<min  || 
    28c6:	89 81       	ldd	r24, Y+1	; 0x01
    28c8:	98 17       	cp	r25, r24
    28ca:	18 f4       	brcc	.+6      	; 0x28d2 <checkAllStacks+0x78>
	   minStackSpace_Idle<min)
	{
		error(ERR_LOW_HEAP_SPACE);
    28cc:	84 e3       	ldi	r24, 0x34	; 52
    28ce:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
	}	
}
    28d2:	00 00       	nop
    28d4:	0f 90       	pop	r0
    28d6:	df 91       	pop	r29
    28d8:	cf 91       	pop	r28
    28da:	08 95       	ret

000028dc <vApplicationMallocFailedHook>:

//----------------------------------------------
// catch heap overflow
//
void vApplicationMallocFailedHook( void )
{
    28dc:	cf 93       	push	r28
    28de:	df 93       	push	r29
    28e0:	cd b7       	in	r28, 0x3d	; 61
    28e2:	de b7       	in	r29, 0x3e	; 62
	error(ERR_LOW_HEAP_SPACE);		
    28e4:	84 e3       	ldi	r24, 0x34	; 52
    28e6:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
} 
    28ea:	00 00       	nop
    28ec:	df 91       	pop	r29
    28ee:	cf 91       	pop	r28
    28f0:	08 95       	ret

000028f2 <vApplicationStackOverflowHook>:

//----------------------------------------------
// to report kernel detected stack overflows
//
void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed portCHAR *pcTaskName )
{
    28f2:	cf 93       	push	r28
    28f4:	df 93       	push	r29
    28f6:	00 d0       	rcall	.+0      	; 0x28f8 <vApplicationStackOverflowHook+0x6>
    28f8:	1f 92       	push	r1
    28fa:	cd b7       	in	r28, 0x3d	; 61
    28fc:	de b7       	in	r29, 0x3e	; 62
    28fe:	89 83       	std	Y+1, r24	; 0x01
    2900:	9a 83       	std	Y+2, r25	; 0x02
    2902:	6b 83       	std	Y+3, r22	; 0x03
    2904:	7c 83       	std	Y+4, r23	; 0x04
	/* Just to stop compiler warnings. */
	(void) pxTask;
	(void) pcTaskName;

	#if RUNTIME_CHECKS == 1
	checkAllStacks();
    2906:	0e 94 2d 14 	call	0x285a	; 0x285a <checkAllStacks>
	#endif

	error(ERR_STACK_OVERFLOW);
    290a:	8b e2       	ldi	r24, 0x2B	; 43
    290c:	0e 94 9e 14 	call	0x293c	; 0x293c <error>

}
    2910:	00 00       	nop
    2912:	24 96       	adiw	r28, 0x04	; 4
    2914:	cd bf       	out	0x3d, r28	; 61
    2916:	de bf       	out	0x3e, r29	; 62
    2918:	df 91       	pop	r29
    291a:	cf 91       	pop	r28
    291c:	08 95       	ret

0000291e <errorNonFatal>:
//
// for errors that are not directly caused by 
// kernel problems 
//
void errorNonFatal(u8 errCode)
{
    291e:	cf 93       	push	r28
    2920:	df 93       	push	r29
    2922:	1f 92       	push	r1
    2924:	1f 92       	push	r1
    2926:	cd b7       	in	r28, 0x3d	; 61
    2928:	de b7       	in	r29, 0x3e	; 62
    292a:	8a 83       	std	Y+2, r24	; 0x02
	(void)errCode;

	u8 a=42; (void)a;
    292c:	8a e2       	ldi	r24, 0x2A	; 42
    292e:	89 83       	std	Y+1, r24	; 0x01

}
    2930:	00 00       	nop
    2932:	0f 90       	pop	r0
    2934:	0f 90       	pop	r0
    2936:	df 91       	pop	r29
    2938:	cf 91       	pop	r28
    293a:	08 95       	ret

0000293c <error>:

//----------------------------------------------
//
void error(u8 errCode)
{
    293c:	cf 93       	push	r28
    293e:	df 93       	push	r29
    2940:	1f 92       	push	r1
    2942:	1f 92       	push	r1
    2944:	cd b7       	in	r28, 0x3d	; 61
    2946:	de b7       	in	r29, 0x3e	; 62
    2948:	8a 83       	std	Y+2, r24	; 0x02
	u8 a;

	if(errCode==ERR_STACK_OVERFLOW)
    294a:	8a 81       	ldd	r24, Y+2	; 0x02
    294c:	8b 32       	cpi	r24, 0x2B	; 43
    294e:	19 f4       	brne	.+6      	; 0x2956 <error+0x1a>
		a = 1;
    2950:	81 e0       	ldi	r24, 0x01	; 1
    2952:	89 83       	std	Y+1, r24	; 0x01
    2954:	0e c0       	rjmp	.+28     	; 0x2972 <error+0x36>
	else if(errCode==ERR_QUEUE_SEND_FAILED)
    2956:	8a 81       	ldd	r24, Y+2	; 0x02
    2958:	8c 32       	cpi	r24, 0x2C	; 44
    295a:	19 f4       	brne	.+6      	; 0x2962 <error+0x26>
		a = 2;
    295c:	82 e0       	ldi	r24, 0x02	; 2
    295e:	89 83       	std	Y+1, r24	; 0x01
    2960:	08 c0       	rjmp	.+16     	; 0x2972 <error+0x36>
	else if(errCode==ERR_BYTES_SHOULD_BE_AVAILABLE)
    2962:	8a 81       	ldd	r24, Y+2	; 0x02
    2964:	8f 32       	cpi	r24, 0x2F	; 47
    2966:	19 f4       	brne	.+6      	; 0x296e <error+0x32>
		a = 3;
    2968:	83 e0       	ldi	r24, 0x03	; 3
    296a:	89 83       	std	Y+1, r24	; 0x01
    296c:	02 c0       	rjmp	.+4      	; 0x2972 <error+0x36>
    else
		a = 4;
    296e:	84 e0       	ldi	r24, 0x04	; 4
    2970:	89 83       	std	Y+1, r24	; 0x01
// TODO from here:
//
// - log the occurance of any error in flash mem (inc counter)
// - print a message

	software_reset();
    2972:	0e 94 c1 14 	call	0x2982	; 0x2982 <software_reset>
}
    2976:	00 00       	nop
    2978:	0f 90       	pop	r0
    297a:	0f 90       	pop	r0
    297c:	df 91       	pop	r29
    297e:	cf 91       	pop	r28
    2980:	08 95       	ret

00002982 <software_reset>:

//----------------------------------------------
//
void software_reset(void)
{
    2982:	cf 93       	push	r28
    2984:	df 93       	push	r29
    2986:	cd b7       	in	r28, 0x3d	; 61
    2988:	de b7       	in	r29, 0x3e	; 62
	CPU_CCP  = CCP_IOREG_gc;
    298a:	84 e3       	ldi	r24, 0x34	; 52
    298c:	90 e0       	ldi	r25, 0x00	; 0
    298e:	28 ed       	ldi	r18, 0xD8	; 216
    2990:	fc 01       	movw	r30, r24
    2992:	20 83       	st	Z, r18
	RST.CTRL = RST_SWRST_bm ;
    2994:	88 e7       	ldi	r24, 0x78	; 120
    2996:	90 e0       	ldi	r25, 0x00	; 0
    2998:	21 e0       	ldi	r18, 0x01	; 1
    299a:	fc 01       	movw	r30, r24
    299c:	21 83       	std	Z+1, r18	; 0x01
}
    299e:	00 00       	nop
    29a0:	df 91       	pop	r29
    29a2:	cf 91       	pop	r28
    29a4:	08 95       	ret

000029a6 <initUsarts>:
//-----------------------------------------------------------
// all usart preparation including port pin setup
//
//
void initUsarts(void)
{
    29a6:	cf 92       	push	r12
    29a8:	ef 92       	push	r14
    29aa:	0f 93       	push	r16
    29ac:	cf 93       	push	r28
    29ae:	df 93       	push	r29
    29b0:	cd b7       	in	r28, 0x3d	; 61
    29b2:	de b7       	in	r29, 0x3e	; 62

	//-----------------------------
	// USARTC0 setup ( RXD0, TXD0 )

	/* PC3 (TXD0) as output. */
	PORTC.DIRSET = PIN3_bm;
    29b4:	80 e4       	ldi	r24, 0x40	; 64
    29b6:	96 e0       	ldi	r25, 0x06	; 6
    29b8:	28 e0       	ldi	r18, 0x08	; 8
    29ba:	fc 01       	movw	r30, r24
    29bc:	21 83       	std	Z+1, r18	; 0x01
	/* PC2 (RXD0) as input. */
	PORTC.DIRCLR = PIN2_bm;
    29be:	80 e4       	ldi	r24, 0x40	; 64
    29c0:	96 e0       	ldi	r25, 0x06	; 6
    29c2:	24 e0       	ldi	r18, 0x04	; 4
    29c4:	fc 01       	movw	r30, r24
    29c6:	22 83       	std	Z+2, r18	; 0x02

	usart_setup( &USARTC0_data, &USARTC0, BSEL_57600, BSCALE_57600, receivetransmit,RX_INTRPT_LEVEL,TX_INTRPT_LEVEL);
    29c8:	cc 24       	eor	r12, r12
    29ca:	c3 94       	inc	r12
    29cc:	68 94       	set
    29ce:	ee 24       	eor	r14, r14
    29d0:	e4 f8       	bld	r14, 4
    29d2:	00 e0       	ldi	r16, 0x00	; 0
    29d4:	2a ef       	ldi	r18, 0xFA	; 250
    29d6:	4e e6       	ldi	r20, 0x6E	; 110
    29d8:	58 e0       	ldi	r21, 0x08	; 8
    29da:	60 ea       	ldi	r22, 0xA0	; 160
    29dc:	78 e0       	ldi	r23, 0x08	; 8
    29de:	89 e4       	ldi	r24, 0x49	; 73
    29e0:	9c e2       	ldi	r25, 0x2C	; 44
    29e2:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <usart_setup>
	//PORTE.DIRSET = PIN3_bm;
	/* PC2 (RXD0) as input. */
	//PORTE.DIRCLR = PIN2_bm;

	//usart_setup( &USARTE0_data, &USARTE0, BSEL_38400, BSCALE_38400, receiveonly,RX_INTRPT_LEVEL,TX_INTRPT_LEVEL);
}
    29e6:	00 00       	nop
    29e8:	df 91       	pop	r29
    29ea:	cf 91       	pop	r28
    29ec:	0f 91       	pop	r16
    29ee:	ef 90       	pop	r14
    29f0:	cf 90       	pop	r12
    29f2:	08 95       	ret

000029f4 <usart_setup>:
                 		s16 bsel, 
						s8 bscale,
				 		dirctrl_t dirctrl,
				 		USART_DREINTLVL_t recIntLevel, // Rx
				 		USART_DREINTLVL_t dreIntLevel) // Tx     
{
    29f4:	cf 92       	push	r12
    29f6:	ef 92       	push	r14
    29f8:	0f 93       	push	r16
    29fa:	cf 93       	push	r28
    29fc:	df 93       	push	r29
    29fe:	cd b7       	in	r28, 0x3d	; 61
    2a00:	de b7       	in	r29, 0x3e	; 62
    2a02:	2b 97       	sbiw	r28, 0x0b	; 11
    2a04:	cd bf       	out	0x3d, r28	; 61
    2a06:	de bf       	out	0x3e, r29	; 62
    2a08:	8a 83       	std	Y+2, r24	; 0x02
    2a0a:	9b 83       	std	Y+3, r25	; 0x03
    2a0c:	6c 83       	std	Y+4, r22	; 0x04
    2a0e:	7d 83       	std	Y+5, r23	; 0x05
    2a10:	4e 83       	std	Y+6, r20	; 0x06
    2a12:	5f 83       	std	Y+7, r21	; 0x07
    2a14:	28 87       	std	Y+8, r18	; 0x08
    2a16:	09 87       	std	Y+9, r16	; 0x09
    2a18:	ea 86       	std	Y+10, r14	; 0x0a
    2a1a:	cb 86       	std	Y+11, r12	; 0x0b
	unsigned portBASE_TYPE uxQueueLength = SERIAL_PORT_BUFFER_LEN;
    2a1c:	82 e5       	ldi	r24, 0x52	; 82
    2a1e:	89 83       	std	Y+1, r24	; 0x01

	// Setup for specific usart and initialize buffer queues
	//
	USART_InterruptDriver_Initialize(usartData, uxQueueLength, dirctrl, usart, dreIntLevel);
    2a20:	2c 81       	ldd	r18, Y+4	; 0x04
    2a22:	3d 81       	ldd	r19, Y+5	; 0x05
    2a24:	8a 81       	ldd	r24, Y+2	; 0x02
    2a26:	9b 81       	ldd	r25, Y+3	; 0x03
    2a28:	0b 85       	ldd	r16, Y+11	; 0x0b
    2a2a:	49 85       	ldd	r20, Y+9	; 0x09
    2a2c:	69 81       	ldd	r22, Y+1	; 0x01
    2a2e:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <USART_InterruptDriver_Initialize>


	USART_2x_Disable(usartData->usart);
    2a32:	8a 81       	ldd	r24, Y+2	; 0x02
    2a34:	9b 81       	ldd	r25, Y+3	; 0x03
    2a36:	fc 01       	movw	r30, r24
    2a38:	80 81       	ld	r24, Z
    2a3a:	91 81       	ldd	r25, Z+1	; 0x01
    2a3c:	2a 81       	ldd	r18, Y+2	; 0x02
    2a3e:	3b 81       	ldd	r19, Y+3	; 0x03
    2a40:	f9 01       	movw	r30, r18
    2a42:	20 81       	ld	r18, Z
    2a44:	31 81       	ldd	r19, Z+1	; 0x01
    2a46:	f9 01       	movw	r30, r18
    2a48:	24 81       	ldd	r18, Z+4	; 0x04
    2a4a:	2b 7f       	andi	r18, 0xFB	; 251
    2a4c:	fc 01       	movw	r30, r24
    2a4e:	24 83       	std	Z+4, r18	; 0x04

	// set format: 8 Data bits, No Parity, 1 Stop bit.
    // this also implicitly sets the communication mode to asynchronous and data order to 'LSB first'
	//
	USART_Format_Set(usartData->usart, USART_CHSIZE_8BIT_gc, USART_PMODE_DISABLED_gc, false);
    2a50:	8a 81       	ldd	r24, Y+2	; 0x02
    2a52:	9b 81       	ldd	r25, Y+3	; 0x03
    2a54:	fc 01       	movw	r30, r24
    2a56:	80 81       	ld	r24, Z
    2a58:	91 81       	ldd	r25, Z+1	; 0x01
    2a5a:	23 e0       	ldi	r18, 0x03	; 3
    2a5c:	fc 01       	movw	r30, r24
    2a5e:	25 83       	std	Z+5, r18	; 0x05
	// Set data order
	//USART_Set_Data_Order_LSB_first(usartData->usart);

	// Enable RXC interrupt.
	//
	USART_RxdInterruptLevel_Set(usartData->usart, recIntLevel);
    2a60:	8a 81       	ldd	r24, Y+2	; 0x02
    2a62:	9b 81       	ldd	r25, Y+3	; 0x03
    2a64:	fc 01       	movw	r30, r24
    2a66:	80 81       	ld	r24, Z
    2a68:	91 81       	ldd	r25, Z+1	; 0x01
    2a6a:	2a 81       	ldd	r18, Y+2	; 0x02
    2a6c:	3b 81       	ldd	r19, Y+3	; 0x03
    2a6e:	f9 01       	movw	r30, r18
    2a70:	20 81       	ld	r18, Z
    2a72:	31 81       	ldd	r19, Z+1	; 0x01
    2a74:	f9 01       	movw	r30, r18
    2a76:	23 81       	ldd	r18, Z+3	; 0x03
    2a78:	32 2f       	mov	r19, r18
    2a7a:	3f 7c       	andi	r19, 0xCF	; 207
    2a7c:	2a 85       	ldd	r18, Y+10	; 0x0a
    2a7e:	23 2b       	or	r18, r19
    2a80:	fc 01       	movw	r30, r24
    2a82:	23 83       	std	Z+3, r18	; 0x03

	// Disable the Data Register Empty interrupt.
	// This is enabled when a byte is actually sent.
	USART_DreInterruptLevel_Set(usartData->usart, USART_DREINTLVL_OFF_gc);
    2a84:	8a 81       	ldd	r24, Y+2	; 0x02
    2a86:	9b 81       	ldd	r25, Y+3	; 0x03
    2a88:	fc 01       	movw	r30, r24
    2a8a:	80 81       	ld	r24, Z
    2a8c:	91 81       	ldd	r25, Z+1	; 0x01
    2a8e:	2a 81       	ldd	r18, Y+2	; 0x02
    2a90:	3b 81       	ldd	r19, Y+3	; 0x03
    2a92:	f9 01       	movw	r30, r18
    2a94:	20 81       	ld	r18, Z
    2a96:	31 81       	ldd	r19, Z+1	; 0x01
    2a98:	f9 01       	movw	r30, r18
    2a9a:	23 81       	ldd	r18, Z+3	; 0x03
    2a9c:	2c 7f       	andi	r18, 0xFC	; 252
    2a9e:	fc 01       	movw	r30, r24
    2aa0:	23 83       	std	Z+3, r18	; 0x03

	// Disable Txd interrupt. This is not used at all.
	// The Dre Interrupt is used instead to control transmission.
	USART_TxdInterruptLevel_Set(usartData->usart, USART_TXCINTLVL_OFF_gc);
    2aa2:	8a 81       	ldd	r24, Y+2	; 0x02
    2aa4:	9b 81       	ldd	r25, Y+3	; 0x03
    2aa6:	fc 01       	movw	r30, r24
    2aa8:	80 81       	ld	r24, Z
    2aaa:	91 81       	ldd	r25, Z+1	; 0x01
    2aac:	2a 81       	ldd	r18, Y+2	; 0x02
    2aae:	3b 81       	ldd	r19, Y+3	; 0x03
    2ab0:	f9 01       	movw	r30, r18
    2ab2:	20 81       	ld	r18, Z
    2ab4:	31 81       	ldd	r19, Z+1	; 0x01
    2ab6:	f9 01       	movw	r30, r18
    2ab8:	23 81       	ldd	r18, Z+3	; 0x03
    2aba:	23 7f       	andi	r18, 0xF3	; 243
    2abc:	fc 01       	movw	r30, r24
    2abe:	23 83       	std	Z+3, r18	; 0x03

	// set baud via driver function
	//
	USART_Baudrate_Set(usartData->usart, bsel, bscale);
    2ac0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac4:	fc 01       	movw	r30, r24
    2ac6:	80 81       	ld	r24, Z
    2ac8:	91 81       	ldd	r25, Z+1	; 0x01
    2aca:	2e 81       	ldd	r18, Y+6	; 0x06
    2acc:	fc 01       	movw	r30, r24
    2ace:	26 83       	std	Z+6, r18	; 0x06
    2ad0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ad2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ad4:	fc 01       	movw	r30, r24
    2ad6:	80 81       	ld	r24, Z
    2ad8:	91 81       	ldd	r25, Z+1	; 0x01
    2ada:	28 85       	ldd	r18, Y+8	; 0x08
    2adc:	02 2e       	mov	r0, r18
    2ade:	00 0c       	add	r0, r0
    2ae0:	33 0b       	sbc	r19, r19
    2ae2:	22 95       	swap	r18
    2ae4:	32 95       	swap	r19
    2ae6:	30 7f       	andi	r19, 0xF0	; 240
    2ae8:	32 27       	eor	r19, r18
    2aea:	20 7f       	andi	r18, 0xF0	; 240
    2aec:	32 27       	eor	r19, r18
    2aee:	42 2f       	mov	r20, r18
    2af0:	2e 81       	ldd	r18, Y+6	; 0x06
    2af2:	3f 81       	ldd	r19, Y+7	; 0x07
    2af4:	23 2f       	mov	r18, r19
    2af6:	33 0f       	add	r19, r19
    2af8:	33 0b       	sbc	r19, r19
    2afa:	24 2b       	or	r18, r20
    2afc:	fc 01       	movw	r30, r24
    2afe:	27 83       	std	Z+7, r18	; 0x07

	// Enable RX and TX.
	//
	#if SERIAL_SIMULATION == 0
	if((dirctrl == receivetransmit) || (dirctrl == receiveonly))
    2b00:	89 85       	ldd	r24, Y+9	; 0x09
    2b02:	88 23       	and	r24, r24
    2b04:	19 f0       	breq	.+6      	; 0x2b0c <usart_setup+0x118>
    2b06:	89 85       	ldd	r24, Y+9	; 0x09
    2b08:	81 30       	cpi	r24, 0x01	; 1
    2b0a:	79 f4       	brne	.+30     	; 0x2b2a <usart_setup+0x136>
	{
		USART_Rx_Enable(usartData->usart);
    2b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b10:	fc 01       	movw	r30, r24
    2b12:	80 81       	ld	r24, Z
    2b14:	91 81       	ldd	r25, Z+1	; 0x01
    2b16:	2a 81       	ldd	r18, Y+2	; 0x02
    2b18:	3b 81       	ldd	r19, Y+3	; 0x03
    2b1a:	f9 01       	movw	r30, r18
    2b1c:	20 81       	ld	r18, Z
    2b1e:	31 81       	ldd	r19, Z+1	; 0x01
    2b20:	f9 01       	movw	r30, r18
    2b22:	24 81       	ldd	r18, Z+4	; 0x04
    2b24:	20 61       	ori	r18, 0x10	; 16
    2b26:	fc 01       	movw	r30, r24
    2b28:	24 83       	std	Z+4, r18	; 0x04
	}
	#endif
	if((dirctrl == receivetransmit) || (dirctrl == transmitonly))
    2b2a:	89 85       	ldd	r24, Y+9	; 0x09
    2b2c:	88 23       	and	r24, r24
    2b2e:	19 f0       	breq	.+6      	; 0x2b36 <usart_setup+0x142>
    2b30:	89 85       	ldd	r24, Y+9	; 0x09
    2b32:	82 30       	cpi	r24, 0x02	; 2
    2b34:	79 f4       	brne	.+30     	; 0x2b54 <usart_setup+0x160>
	{
		USART_Tx_Enable(usartData->usart);
    2b36:	8a 81       	ldd	r24, Y+2	; 0x02
    2b38:	9b 81       	ldd	r25, Y+3	; 0x03
    2b3a:	fc 01       	movw	r30, r24
    2b3c:	80 81       	ld	r24, Z
    2b3e:	91 81       	ldd	r25, Z+1	; 0x01
    2b40:	2a 81       	ldd	r18, Y+2	; 0x02
    2b42:	3b 81       	ldd	r19, Y+3	; 0x03
    2b44:	f9 01       	movw	r30, r18
    2b46:	20 81       	ld	r18, Z
    2b48:	31 81       	ldd	r19, Z+1	; 0x01
    2b4a:	f9 01       	movw	r30, r18
    2b4c:	24 81       	ldd	r18, Z+4	; 0x04
    2b4e:	28 60       	ori	r18, 0x08	; 8
    2b50:	fc 01       	movw	r30, r24
    2b52:	24 83       	std	Z+4, r18	; 0x04
	}
}
    2b54:	00 00       	nop
    2b56:	2b 96       	adiw	r28, 0x0b	; 11
    2b58:	cd bf       	out	0x3d, r28	; 61
    2b5a:	de bf       	out	0x3e, r29	; 62
    2b5c:	df 91       	pop	r29
    2b5e:	cf 91       	pop	r28
    2b60:	0f 91       	pop	r16
    2b62:	ef 90       	pop	r14
    2b64:	cf 90       	pop	r12
    2b66:	08 95       	ret

00002b68 <vInitClock>:
#define EXTERNAL_CLOCK_15MHZ 0
#define EXTERNAL_CLOCK_30MHZ 0
#define EXTERNAL_CLOCK_8MHZ  1

void vInitClock(void)
{
    2b68:	cf 93       	push	r28
    2b6a:	df 93       	push	r29
    2b6c:	cd b7       	in	r28, 0x3d	; 61
    2b6e:	de b7       	in	r29, 0x3e	; 62

	// After the bootloader was running we put everything to a defined state
	// and use the internal 2 MHz oscillator first:
	//
	CLKSYS_Enable( OSC_RC2MEN_bm );
    2b70:	80 e5       	ldi	r24, 0x50	; 80
    2b72:	90 e0       	ldi	r25, 0x00	; 0
    2b74:	20 e5       	ldi	r18, 0x50	; 80
    2b76:	30 e0       	ldi	r19, 0x00	; 0
    2b78:	f9 01       	movw	r30, r18
    2b7a:	20 81       	ld	r18, Z
    2b7c:	21 60       	ori	r18, 0x01	; 1
    2b7e:	fc 01       	movw	r30, r24
    2b80:	20 83       	st	Z, r18
	do {} while ( CLKSYS_IsReady( OSC_RC2MRDY_bm ) == 0 );
    2b82:	80 e5       	ldi	r24, 0x50	; 80
    2b84:	90 e0       	ldi	r25, 0x00	; 0
    2b86:	fc 01       	movw	r30, r24
    2b88:	81 81       	ldd	r24, Z+1	; 0x01
    2b8a:	88 2f       	mov	r24, r24
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	81 70       	andi	r24, 0x01	; 1
    2b90:	99 27       	eor	r25, r25
    2b92:	89 2b       	or	r24, r25
    2b94:	b1 f3       	breq	.-20     	; 0x2b82 <vInitClock+0x1a>

	// select the 2 MHz oscillator as system clock.
	//
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC2M_gc );	
    2b96:	80 e0       	ldi	r24, 0x00	; 0
    2b98:	0e 94 c6 01 	call	0x38c	; 0x38c <CLKSYS_Main_ClockSource_Select>

	// disable all clock sources including the pll, except the 2 MHz one. 
	//
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
    2b9c:	8e e1       	ldi	r24, 0x1E	; 30
    2b9e:	0e 94 8f 01 	call	0x31e	; 0x31e <CLKSYS_Disable>

	// prescalers off 
	//
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    2ba2:	60 e0       	ldi	r22, 0x00	; 0
    2ba4:	80 e0       	ldi	r24, 0x00	; 0
    2ba6:	0e 94 af 01 	call	0x35e	; 0x35e <CLKSYS_Prescalers_Config>

// Enable for external 2-9 MHz crystal with 256 clks startup time.
// Check if it's stable and set the external
// oscillator as the main clock source.
//
CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,false,OSC_XOSCSEL_XTAL_256CLK_gc );
    2baa:	43 e0       	ldi	r20, 0x03	; 3
    2bac:	60 e0       	ldi	r22, 0x00	; 0
    2bae:	80 e4       	ldi	r24, 0x40	; 64
    2bb0:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <CLKSYS_XOSC_Config>
CLKSYS_Enable( OSC_XOSCEN_bm );
    2bb4:	80 e5       	ldi	r24, 0x50	; 80
    2bb6:	90 e0       	ldi	r25, 0x00	; 0
    2bb8:	20 e5       	ldi	r18, 0x50	; 80
    2bba:	30 e0       	ldi	r19, 0x00	; 0
    2bbc:	f9 01       	movw	r30, r18
    2bbe:	20 81       	ld	r18, Z
    2bc0:	28 60       	ori	r18, 0x08	; 8
    2bc2:	fc 01       	movw	r30, r24
    2bc4:	20 83       	st	Z, r18
do {} while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    2bc6:	80 e5       	ldi	r24, 0x50	; 80
    2bc8:	90 e0       	ldi	r25, 0x00	; 0
    2bca:	fc 01       	movw	r30, r24
    2bcc:	81 81       	ldd	r24, Z+1	; 0x01
    2bce:	88 2f       	mov	r24, r24
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	88 70       	andi	r24, 0x08	; 8
    2bd4:	99 27       	eor	r25, r25
    2bd6:	89 2b       	or	r24, r25
    2bd8:	b1 f3       	breq	.-20     	; 0x2bc6 <vInitClock+0x5e>

// The clock is stable now and the PLL can be started.
// Select the external xtal osc as source for the PLL
// and multiply by 4.
//
CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 4 );
    2bda:	64 e0       	ldi	r22, 0x04	; 4
    2bdc:	80 ec       	ldi	r24, 0xC0	; 192
    2bde:	0e 94 77 01 	call	0x2ee	; 0x2ee <CLKSYS_PLL_Config>
CLKSYS_Enable( OSC_PLLEN_bm );
    2be2:	80 e5       	ldi	r24, 0x50	; 80
    2be4:	90 e0       	ldi	r25, 0x00	; 0
    2be6:	20 e5       	ldi	r18, 0x50	; 80
    2be8:	30 e0       	ldi	r19, 0x00	; 0
    2bea:	f9 01       	movw	r30, r18
    2bec:	20 81       	ld	r18, Z
    2bee:	20 61       	ori	r18, 0x10	; 16
    2bf0:	fc 01       	movw	r30, r24
    2bf2:	20 83       	st	Z, r18

// all prescaler divide by 1
//
CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    2bf4:	60 e0       	ldi	r22, 0x00	; 0
    2bf6:	80 e0       	ldi	r24, 0x00	; 0
    2bf8:	0e 94 af 01 	call	0x35e	; 0x35e <CLKSYS_Prescalers_Config>
do {} while ( CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    2bfc:	80 e5       	ldi	r24, 0x50	; 80
    2bfe:	90 e0       	ldi	r25, 0x00	; 0
    2c00:	fc 01       	movw	r30, r24
    2c02:	81 81       	ldd	r24, Z+1	; 0x01
    2c04:	88 2f       	mov	r24, r24
    2c06:	90 e0       	ldi	r25, 0x00	; 0
    2c08:	80 71       	andi	r24, 0x10	; 16
    2c0a:	99 27       	eor	r25, r25
    2c0c:	89 2b       	or	r24, r25
    2c0e:	b1 f3       	breq	.-20     	; 0x2bfc <vInitClock+0x94>

// select the PLL as system clock
//
CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    2c10:	84 e0       	ldi	r24, 0x04	; 4
    2c12:	0e 94 c6 01 	call	0x38c	; 0x38c <CLKSYS_Main_ClockSource_Select>

// disable all internal oszillators
//
CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm);
    2c16:	87 e0       	ldi	r24, 0x07	; 7
    2c18:	0e 94 8f 01 	call	0x31e	; 0x31e <CLKSYS_Disable>
#endif
}
    2c1c:	00 00       	nop
    2c1e:	df 91       	pop	r29
    2c20:	cf 91       	pop	r28
    2c22:	08 95       	ret

00002c24 <disableUnusedModules>:
//
// Disable everything that is not used.
//

void disableUnusedModules(void)
{
    2c24:	cf 93       	push	r28
    2c26:	df 93       	push	r29
    2c28:	1f 92       	push	r1
    2c2a:	cd b7       	in	r28, 0x3d	; 61
    2c2c:	de b7       	in	r29, 0x3e	; 62
	//  - DMA
	//  - event system
	//  - RTC
	//  - external bus interface
	//
	PR.PRGEN |= PR_AES_bm | PR_DMA_bm | PR_EVSYS_bm | PR_RTC_bm;
    2c2e:	80 e7       	ldi	r24, 0x70	; 112
    2c30:	90 e0       	ldi	r25, 0x00	; 0
    2c32:	20 e7       	ldi	r18, 0x70	; 112
    2c34:	30 e0       	ldi	r19, 0x00	; 0
    2c36:	f9 01       	movw	r30, r18
    2c38:	20 81       	ld	r18, Z
    2c3a:	27 61       	ori	r18, 0x17	; 23
    2c3c:	fc 01       	movw	r30, r24
    2c3e:	20 83       	st	Z, r18
	//	- ADC on port B
	//  - DAC
	//
	// leave ADCA active !
	//
	PR.PRPA |= PR_AC_bm;
    2c40:	80 e7       	ldi	r24, 0x70	; 112
    2c42:	90 e0       	ldi	r25, 0x00	; 0
    2c44:	20 e7       	ldi	r18, 0x70	; 112
    2c46:	30 e0       	ldi	r19, 0x00	; 0
    2c48:	f9 01       	movw	r30, r18
    2c4a:	21 81       	ldd	r18, Z+1	; 0x01
    2c4c:	21 60       	ori	r18, 0x01	; 1
    2c4e:	fc 01       	movw	r30, r24
    2c50:	21 83       	std	Z+1, r18	; 0x01
	PR.PRPB |= PR_AC_bm | PR_ADC_bm | PR_DAC_bm;
    2c52:	80 e7       	ldi	r24, 0x70	; 112
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	20 e7       	ldi	r18, 0x70	; 112
    2c58:	30 e0       	ldi	r19, 0x00	; 0
    2c5a:	f9 01       	movw	r30, r18
    2c5c:	22 81       	ldd	r18, Z+2	; 0x02
    2c5e:	27 60       	ori	r18, 0x07	; 7
    2c60:	fc 01       	movw	r30, r24
    2c62:	22 83       	std	Z+2, r18	; 0x02
	// - TCD1, TCD1       on, used for nested intrrupt tests
	// - TCC1, TCD0, TCE0 (if not simulating serial input)
	//
	// TCC0 is the tick timer, always on!
	//
	PR.PRPC |= PR_HIRES_bm;
    2c64:	80 e7       	ldi	r24, 0x70	; 112
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	20 e7       	ldi	r18, 0x70	; 112
    2c6a:	30 e0       	ldi	r19, 0x00	; 0
    2c6c:	f9 01       	movw	r30, r18
    2c6e:	23 81       	ldd	r18, Z+3	; 0x03
    2c70:	24 60       	ori	r18, 0x04	; 4
    2c72:	fc 01       	movw	r30, r24
    2c74:	23 83       	std	Z+3, r18	; 0x03
	PR.PRPD |= PR_HIRES_bm;
    2c76:	80 e7       	ldi	r24, 0x70	; 112
    2c78:	90 e0       	ldi	r25, 0x00	; 0
    2c7a:	20 e7       	ldi	r18, 0x70	; 112
    2c7c:	30 e0       	ldi	r19, 0x00	; 0
    2c7e:	f9 01       	movw	r30, r18
    2c80:	24 81       	ldd	r18, Z+4	; 0x04
    2c82:	24 60       	ori	r18, 0x04	; 4
    2c84:	fc 01       	movw	r30, r24
    2c86:	24 83       	std	Z+4, r18	; 0x04
	PR.PRPE |= PR_HIRES_bm;
    2c88:	80 e7       	ldi	r24, 0x70	; 112
    2c8a:	90 e0       	ldi	r25, 0x00	; 0
    2c8c:	20 e7       	ldi	r18, 0x70	; 112
    2c8e:	30 e0       	ldi	r19, 0x00	; 0
    2c90:	f9 01       	movw	r30, r18
    2c92:	25 81       	ldd	r18, Z+5	; 0x05
    2c94:	24 60       	ori	r18, 0x04	; 4
    2c96:	fc 01       	movw	r30, r24
    2c98:	25 83       	std	Z+5, r18	; 0x05

	#if NESTING_TEST == 0
	PR.PRPD |= PR_TC0_bm;		// TCD0 off
    2c9a:	80 e7       	ldi	r24, 0x70	; 112
    2c9c:	90 e0       	ldi	r25, 0x00	; 0
    2c9e:	20 e7       	ldi	r18, 0x70	; 112
    2ca0:	30 e0       	ldi	r19, 0x00	; 0
    2ca2:	f9 01       	movw	r30, r18
    2ca4:	24 81       	ldd	r18, Z+4	; 0x04
    2ca6:	21 60       	ori	r18, 0x01	; 1
    2ca8:	fc 01       	movw	r30, r24
    2caa:	24 83       	std	Z+4, r18	; 0x04
	PR.PRPD |= PR_TC1_bm;		// TCD1 off
    2cac:	80 e7       	ldi	r24, 0x70	; 112
    2cae:	90 e0       	ldi	r25, 0x00	; 0
    2cb0:	20 e7       	ldi	r18, 0x70	; 112
    2cb2:	30 e0       	ldi	r19, 0x00	; 0
    2cb4:	f9 01       	movw	r30, r18
    2cb6:	24 81       	ldd	r18, Z+4	; 0x04
    2cb8:	22 60       	ori	r18, 0x02	; 2
    2cba:	fc 01       	movw	r30, r24
    2cbc:	24 83       	std	Z+4, r18	; 0x04
	#endif

	#if SERIAL_SIMULATION == 0
	// TCC0 is tick timer, always on
	PR.PRPC |= PR_TC1_bm;       // TCC1 off
    2cbe:	80 e7       	ldi	r24, 0x70	; 112
    2cc0:	90 e0       	ldi	r25, 0x00	; 0
    2cc2:	20 e7       	ldi	r18, 0x70	; 112
    2cc4:	30 e0       	ldi	r19, 0x00	; 0
    2cc6:	f9 01       	movw	r30, r18
    2cc8:	23 81       	ldd	r18, Z+3	; 0x03
    2cca:	22 60       	ori	r18, 0x02	; 2
    2ccc:	fc 01       	movw	r30, r24
    2cce:	23 83       	std	Z+3, r18	; 0x03
	PR.PRPE |= PR_TC0_bm;		// TCE0 off
    2cd0:	80 e7       	ldi	r24, 0x70	; 112
    2cd2:	90 e0       	ldi	r25, 0x00	; 0
    2cd4:	20 e7       	ldi	r18, 0x70	; 112
    2cd6:	30 e0       	ldi	r19, 0x00	; 0
    2cd8:	f9 01       	movw	r30, r18
    2cda:	25 81       	ldd	r18, Z+5	; 0x05
    2cdc:	21 60       	ori	r18, 0x01	; 1
    2cde:	fc 01       	movw	r30, r24
    2ce0:	25 83       	std	Z+5, r18	; 0x05

	// disable SPI, TWI
	//
	// all uarts are active !
	//
	PR.PRPC |= PR_SPI_bm | PR_TWI_bm;
    2ce2:	80 e7       	ldi	r24, 0x70	; 112
    2ce4:	90 e0       	ldi	r25, 0x00	; 0
    2ce6:	20 e7       	ldi	r18, 0x70	; 112
    2ce8:	30 e0       	ldi	r19, 0x00	; 0
    2cea:	f9 01       	movw	r30, r18
    2cec:	23 81       	ldd	r18, Z+3	; 0x03
    2cee:	28 64       	ori	r18, 0x48	; 72
    2cf0:	fc 01       	movw	r30, r24
    2cf2:	23 83       	std	Z+3, r18	; 0x03
	PR.PRPD |= PR_SPI_bm;
    2cf4:	80 e7       	ldi	r24, 0x70	; 112
    2cf6:	90 e0       	ldi	r25, 0x00	; 0
    2cf8:	20 e7       	ldi	r18, 0x70	; 112
    2cfa:	30 e0       	ldi	r19, 0x00	; 0
    2cfc:	f9 01       	movw	r30, r18
    2cfe:	24 81       	ldd	r18, Z+4	; 0x04
    2d00:	28 60       	ori	r18, 0x08	; 8
    2d02:	fc 01       	movw	r30, r24
    2d04:	24 83       	std	Z+4, r18	; 0x04
	PR.PRPE |=             PR_TWI_bm;
    2d06:	80 e7       	ldi	r24, 0x70	; 112
    2d08:	90 e0       	ldi	r25, 0x00	; 0
    2d0a:	20 e7       	ldi	r18, 0x70	; 112
    2d0c:	30 e0       	ldi	r19, 0x00	; 0
    2d0e:	f9 01       	movw	r30, r18
    2d10:	25 81       	ldd	r18, Z+5	; 0x05
    2d12:	20 64       	ori	r18, 0x40	; 64
    2d14:	fc 01       	movw	r30, r24
    2d16:	25 83       	std	Z+5, r18	; 0x05

	// enable eeprom and flash power reduction
	//
	NVM.CTRLB |= NVM_EPRM_bm | NVM_FPRM_bm;
    2d18:	80 ec       	ldi	r24, 0xC0	; 192
    2d1a:	91 e0       	ldi	r25, 0x01	; 1
    2d1c:	20 ec       	ldi	r18, 0xC0	; 192
    2d1e:	31 e0       	ldi	r19, 0x01	; 1
    2d20:	f9 01       	movw	r30, r18
    2d22:	24 85       	ldd	r18, Z+12	; 0x0c
    2d24:	26 60       	ori	r18, 0x06	; 6
    2d26:	fc 01       	movw	r30, r24
    2d28:	24 87       	std	Z+12, r18	; 0x0c

	DISABLE_JTAG();
    2d2a:	8f e3       	ldi	r24, 0x3F	; 63
    2d2c:	90 e0       	ldi	r25, 0x00	; 0
    2d2e:	fc 01       	movw	r30, r24
    2d30:	80 81       	ld	r24, Z
    2d32:	89 83       	std	Y+1, r24	; 0x01
    2d34:	f8 94       	cli
    2d36:	84 e3       	ldi	r24, 0x34	; 52
    2d38:	90 e0       	ldi	r25, 0x00	; 0
    2d3a:	28 ed       	ldi	r18, 0xD8	; 216
    2d3c:	fc 01       	movw	r30, r24
    2d3e:	20 83       	st	Z, r18
    2d40:	86 e9       	ldi	r24, 0x96	; 150
    2d42:	90 e0       	ldi	r25, 0x00	; 0
    2d44:	21 e0       	ldi	r18, 0x01	; 1
    2d46:	fc 01       	movw	r30, r24
    2d48:	20 83       	st	Z, r18
    2d4a:	8f e3       	ldi	r24, 0x3F	; 63
    2d4c:	90 e0       	ldi	r25, 0x00	; 0
    2d4e:	29 81       	ldd	r18, Y+1	; 0x01
    2d50:	fc 01       	movw	r30, r24
    2d52:	20 83       	st	Z, r18

#else
#error device not supported, low power configuration is device specific!
#endif

}
    2d54:	00 00       	nop
    2d56:	0f 90       	pop	r0
    2d58:	df 91       	pop	r29
    2d5a:	cf 91       	pop	r28
    2d5c:	08 95       	ret

00002d5e <vPortPreparation>:
        

//-----------------------------------------------------------
//
void vPortPreparation(void)
{
    2d5e:	ef 92       	push	r14
    2d60:	0f 93       	push	r16
    2d62:	cf 93       	push	r28
    2d64:	df 93       	push	r29
    2d66:	cd b7       	in	r28, 0x3d	; 61
    2d68:	de b7       	in	r29, 0x3e	; 62
	// PA4 is adc input UY
	// PA5 is adc input UZ
	// PA6 is GND , used to calibrate the adc
	
	// PA7 is unused
	__PORT_PULLUP(PORTA, PIN7_bm);
    2d6a:	80 eb       	ldi	r24, 0xB0	; 176
    2d6c:	90 e0       	ldi	r25, 0x00	; 0
    2d6e:	20 e8       	ldi	r18, 0x80	; 128
    2d70:	fc 01       	movw	r30, r24
    2d72:	20 83       	st	Z, r18
    2d74:	80 e0       	ldi	r24, 0x00	; 0
    2d76:	96 e0       	ldi	r25, 0x06	; 6
    2d78:	28 e1       	ldi	r18, 0x18	; 24
    2d7a:	fc 01       	movw	r30, r24
    2d7c:	20 8b       	std	Z+16, r18	; 0x10
	//==============

	// PB0 = DIRCTRL1 as output
	// set the RS485 driver to input (Nexusbus)
	//
	PORTB.DIRSET = PIN0_bm; // pin0 is output
    2d7e:	80 e2       	ldi	r24, 0x20	; 32
    2d80:	96 e0       	ldi	r25, 0x06	; 6
    2d82:	21 e0       	ldi	r18, 0x01	; 1
    2d84:	fc 01       	movw	r30, r24
    2d86:	21 83       	std	Z+1, r18	; 0x01
	PORTB.OUTCLR = PIN0_bm; // DE=0, RS485 driver is off
    2d88:	80 e2       	ldi	r24, 0x20	; 32
    2d8a:	96 e0       	ldi	r25, 0x06	; 6
    2d8c:	21 e0       	ldi	r18, 0x01	; 1
    2d8e:	fc 01       	movw	r30, r24
    2d90:	26 83       	std	Z+6, r18	; 0x06

	// PB1 = DIRCTRL2 as output, 
	// enable the RS485 Transmitter for GPS output
	//
	PORTB.DIRSET = PIN1_bm; // pin1 is output
    2d92:	80 e2       	ldi	r24, 0x20	; 32
    2d94:	96 e0       	ldi	r25, 0x06	; 6
    2d96:	22 e0       	ldi	r18, 0x02	; 2
    2d98:	fc 01       	movw	r30, r24
    2d9a:	21 83       	std	Z+1, r18	; 0x01
	PORTB.OUTSET = PIN1_bm;	// DE=1 , RS484 driver is on
    2d9c:	80 e2       	ldi	r24, 0x20	; 32
    2d9e:	96 e0       	ldi	r25, 0x06	; 6
    2da0:	22 e0       	ldi	r18, 0x02	; 2
    2da2:	fc 01       	movw	r30, r24
    2da4:	25 83       	std	Z+5, r18	; 0x05

	// PB2 = DIRCTRL2 as output, 
	// this pin controls the reset line of the BT-222 bluetooth modem 
	//
	PORTB.DIRSET = PIN2_bm; // pin2 is output
    2da6:	80 e2       	ldi	r24, 0x20	; 32
    2da8:	96 e0       	ldi	r25, 0x06	; 6
    2daa:	24 e0       	ldi	r18, 0x04	; 4
    2dac:	fc 01       	movw	r30, r24
    2dae:	21 83       	std	Z+1, r18	; 0x01
	PORTB.OUTSET = PIN2_bm;	// BLUERES=1 , reset of BT-222 is high
    2db0:	80 e2       	ldi	r24, 0x20	; 32
    2db2:	96 e0       	ldi	r25, 0x06	; 6
    2db4:	24 e0       	ldi	r18, 0x04	; 4
    2db6:	fc 01       	movw	r30, r24
    2db8:	25 83       	std	Z+5, r18	; 0x05

	// PB3 = LINK
	// this pin is used to read the BT-222 linkstatus
	//
	PORTB.DIRCLR = PIN3_bm; // pin3 is input
    2dba:	80 e2       	ldi	r24, 0x20	; 32
    2dbc:	96 e0       	ldi	r25, 0x06	; 6
    2dbe:	28 e0       	ldi	r18, 0x08	; 8
    2dc0:	fc 01       	movw	r30, r24
    2dc2:	22 83       	std	Z+2, r18	; 0x02

	// PC3 is TXBLUE, serial output to BT-222
	//     initialized with the serial ports

	// PC4 is unused
	__PORT_PULLUP(PORTC, PIN4_bm);
    2dc4:	80 eb       	ldi	r24, 0xB0	; 176
    2dc6:	90 e0       	ldi	r25, 0x00	; 0
    2dc8:	20 e1       	ldi	r18, 0x10	; 16
    2dca:	fc 01       	movw	r30, r24
    2dcc:	20 83       	st	Z, r18
    2dce:	80 e4       	ldi	r24, 0x40	; 64
    2dd0:	96 e0       	ldi	r25, 0x06	; 6
    2dd2:	28 e1       	ldi	r18, 0x18	; 24
    2dd4:	fc 01       	movw	r30, r24
    2dd6:	20 8b       	std	Z+16, r18	; 0x10

	// PC5 is unused
	__PORT_PULLUP(PORTC, PIN5_bm);
    2dd8:	80 eb       	ldi	r24, 0xB0	; 176
    2dda:	90 e0       	ldi	r25, 0x00	; 0
    2ddc:	20 e2       	ldi	r18, 0x20	; 32
    2dde:	fc 01       	movw	r30, r24
    2de0:	20 83       	st	Z, r18
    2de2:	80 e4       	ldi	r24, 0x40	; 64
    2de4:	96 e0       	ldi	r25, 0x06	; 6
    2de6:	28 e1       	ldi	r18, 0x18	; 24
    2de8:	fc 01       	movw	r30, r24
    2dea:	20 8b       	std	Z+16, r18	; 0x10
	
	// PD0 is CAL
	// this pin is connected to the calibration switch
	// and shall trigger an interrupt if pressed.
	//
	PORT_ConfigurePins( &PORTD,
    2dec:	68 94       	set
    2dee:	ee 24       	eor	r14, r14
    2df0:	e1 f8       	bld	r14, 1
    2df2:	00 e0       	ldi	r16, 0x00	; 0
    2df4:	20 e0       	ldi	r18, 0x00	; 0
    2df6:	40 e0       	ldi	r20, 0x00	; 0
    2df8:	61 e0       	ldi	r22, 0x01	; 1
    2dfa:	80 e6       	ldi	r24, 0x60	; 96
    2dfc:	96 e0       	ldi	r25, 0x06	; 6
    2dfe:	0e 94 b0 04 	call	0x960	; 0x960 <PORT_ConfigurePins>
	                    false,
	                    false,
	                    PORT_OPC_TOTEM_gc,
	                    PORT_ISC_FALLING_gc );

	PORT_SetPinsAsInput( &PORTD, PIN0_bm );
    2e02:	80 e6       	ldi	r24, 0x60	; 96
    2e04:	96 e0       	ldi	r25, 0x06	; 6
    2e06:	21 e0       	ldi	r18, 0x01	; 1
    2e08:	fc 01       	movw	r30, r24
    2e0a:	22 83       	std	Z+2, r18	; 0x02

	// Configure Interrupt0 to have medium interrupt level, triggered by pin 0.
	//
	PORT_ConfigureInterrupt0( &PORTD, PORT_INT0LVL_MED_gc, 0x01 );
    2e0c:	41 e0       	ldi	r20, 0x01	; 1
    2e0e:	62 e0       	ldi	r22, 0x02	; 2
    2e10:	80 e6       	ldi	r24, 0x60	; 96
    2e12:	96 e0       	ldi	r25, 0x06	; 6
    2e14:	0e 94 8d 04 	call	0x91a	; 0x91a <PORT_ConfigureInterrupt0>


	// PD1 is unused
	__PORT_PULLUP(PORTD, PIN1_bm);
    2e18:	80 eb       	ldi	r24, 0xB0	; 176
    2e1a:	90 e0       	ldi	r25, 0x00	; 0
    2e1c:	22 e0       	ldi	r18, 0x02	; 2
    2e1e:	fc 01       	movw	r30, r24
    2e20:	20 83       	st	Z, r18
    2e22:	80 e6       	ldi	r24, 0x60	; 96
    2e24:	96 e0       	ldi	r25, 0x06	; 6
    2e26:	28 e1       	ldi	r18, 0x18	; 24
    2e28:	fc 01       	movw	r30, r24
    2e2a:	20 8b       	std	Z+16, r18	; 0x10

	// PD3 is RS2_TX, RS485 output
	//     initialized with the serial ports

	// PD4 is unused
	__PORT_PULLUP(PORTD, PIN4_bm);
    2e2c:	80 eb       	ldi	r24, 0xB0	; 176
    2e2e:	90 e0       	ldi	r25, 0x00	; 0
    2e30:	20 e1       	ldi	r18, 0x10	; 16
    2e32:	fc 01       	movw	r30, r24
    2e34:	20 83       	st	Z, r18
    2e36:	80 e6       	ldi	r24, 0x60	; 96
    2e38:	96 e0       	ldi	r25, 0x06	; 6
    2e3a:	28 e1       	ldi	r18, 0x18	; 24
    2e3c:	fc 01       	movw	r30, r24
    2e3e:	20 8b       	std	Z+16, r18	; 0x10

	// PD5 is unused
	__PORT_PULLUP(PORTD, PIN5_bm);
    2e40:	80 eb       	ldi	r24, 0xB0	; 176
    2e42:	90 e0       	ldi	r25, 0x00	; 0
    2e44:	20 e2       	ldi	r18, 0x20	; 32
    2e46:	fc 01       	movw	r30, r24
    2e48:	20 83       	st	Z, r18
    2e4a:	80 e6       	ldi	r24, 0x60	; 96
    2e4c:	96 e0       	ldi	r25, 0x06	; 6
    2e4e:	28 e1       	ldi	r18, 0x18	; 24
    2e50:	fc 01       	movw	r30, r24
    2e52:	20 8b       	std	Z+16, r18	; 0x10

	// PD6 is RXD2, serial optical input
	//     initialized with the serial ports

	// PD7 is unused
	__PORT_PULLUP(PORTD, PIN7_bm);
    2e54:	80 eb       	ldi	r24, 0xB0	; 176
    2e56:	90 e0       	ldi	r25, 0x00	; 0
    2e58:	20 e8       	ldi	r18, 0x80	; 128
    2e5a:	fc 01       	movw	r30, r24
    2e5c:	20 83       	st	Z, r18
    2e5e:	80 e6       	ldi	r24, 0x60	; 96
    2e60:	96 e0       	ldi	r25, 0x06	; 6
    2e62:	28 e1       	ldi	r18, 0x18	; 24
    2e64:	fc 01       	movw	r30, r24
    2e66:	20 8b       	std	Z+16, r18	; 0x10
	//==============
	//  Port E
	//==============
	
	// PE0 is unused
	__PORT_PULLUP(PORTE, PIN0_bm);
    2e68:	80 eb       	ldi	r24, 0xB0	; 176
    2e6a:	90 e0       	ldi	r25, 0x00	; 0
    2e6c:	21 e0       	ldi	r18, 0x01	; 1
    2e6e:	fc 01       	movw	r30, r24
    2e70:	20 83       	st	Z, r18
    2e72:	80 e8       	ldi	r24, 0x80	; 128
    2e74:	96 e0       	ldi	r25, 0x06	; 6
    2e76:	28 e1       	ldi	r18, 0x18	; 24
    2e78:	fc 01       	movw	r30, r24
    2e7a:	20 8b       	std	Z+16, r18	; 0x10

	// PE1 is unused
	__PORT_PULLUP(PORTE, PIN1_bm);
    2e7c:	80 eb       	ldi	r24, 0xB0	; 176
    2e7e:	90 e0       	ldi	r25, 0x00	; 0
    2e80:	22 e0       	ldi	r18, 0x02	; 2
    2e82:	fc 01       	movw	r30, r24
    2e84:	20 83       	st	Z, r18
    2e86:	80 e8       	ldi	r24, 0x80	; 128
    2e88:	96 e0       	ldi	r25, 0x06	; 6
    2e8a:	28 e1       	ldi	r18, 0x18	; 24
    2e8c:	fc 01       	movw	r30, r24
    2e8e:	20 8b       	std	Z+16, r18	; 0x10

	// PE2 is RXD1, serial optical input
	//     initialized with the serial ports

	// PE3 is unused
	__PORT_PULLUP(PORTE, PIN3_bm);
    2e90:	80 eb       	ldi	r24, 0xB0	; 176
    2e92:	90 e0       	ldi	r25, 0x00	; 0
    2e94:	28 e0       	ldi	r18, 0x08	; 8
    2e96:	fc 01       	movw	r30, r24
    2e98:	20 83       	st	Z, r18
    2e9a:	80 e8       	ldi	r24, 0x80	; 128
    2e9c:	96 e0       	ldi	r25, 0x06	; 6
    2e9e:	28 e1       	ldi	r18, 0x18	; 24
    2ea0:	fc 01       	movw	r30, r24
    2ea2:	20 8b       	std	Z+16, r18	; 0x10
}
    2ea4:	00 00       	nop
    2ea6:	df 91       	pop	r29
    2ea8:	cf 91       	pop	r28
    2eaa:	0f 91       	pop	r16
    2eac:	ef 90       	pop	r14
    2eae:	08 95       	ret

00002eb0 <__vector_64>:
//-----------------------------------------------------------
// Start the boot-loader via software reset
// when the button is pressed.
//
ISR(PORTD_INT0_vect)
{
    2eb0:	1f 92       	push	r1
    2eb2:	0f 92       	push	r0
    2eb4:	00 90 3f 00 	lds	r0, 0x003F	; 0x80003f <__TEXT_REGION_LENGTH__+0x70003f>
    2eb8:	0f 92       	push	r0
    2eba:	11 24       	eor	r1, r1
    2ebc:	00 90 3b 00 	lds	r0, 0x003B	; 0x80003b <__TEXT_REGION_LENGTH__+0x70003b>
    2ec0:	0f 92       	push	r0
    2ec2:	2f 93       	push	r18
    2ec4:	3f 93       	push	r19
    2ec6:	4f 93       	push	r20
    2ec8:	5f 93       	push	r21
    2eca:	6f 93       	push	r22
    2ecc:	7f 93       	push	r23
    2ece:	8f 93       	push	r24
    2ed0:	9f 93       	push	r25
    2ed2:	af 93       	push	r26
    2ed4:	bf 93       	push	r27
    2ed6:	ef 93       	push	r30
    2ed8:	ff 93       	push	r31
    2eda:	cf 93       	push	r28
    2edc:	df 93       	push	r29
    2ede:	cd b7       	in	r28, 0x3d	; 61
    2ee0:	de b7       	in	r29, 0x3e	; 62
	cli();
    2ee2:	f8 94       	cli
	software_reset();
    2ee4:	0e 94 c1 14 	call	0x2982	; 0x2982 <software_reset>
}
    2ee8:	00 00       	nop
    2eea:	df 91       	pop	r29
    2eec:	cf 91       	pop	r28
    2eee:	ff 91       	pop	r31
    2ef0:	ef 91       	pop	r30
    2ef2:	bf 91       	pop	r27
    2ef4:	af 91       	pop	r26
    2ef6:	9f 91       	pop	r25
    2ef8:	8f 91       	pop	r24
    2efa:	7f 91       	pop	r23
    2efc:	6f 91       	pop	r22
    2efe:	5f 91       	pop	r21
    2f00:	4f 91       	pop	r20
    2f02:	3f 91       	pop	r19
    2f04:	2f 91       	pop	r18
    2f06:	0f 90       	pop	r0
    2f08:	00 92 3b 00 	sts	0x003B, r0	; 0x80003b <__TEXT_REGION_LENGTH__+0x70003b>
    2f0c:	0f 90       	pop	r0
    2f0e:	00 92 3f 00 	sts	0x003F, r0	; 0x80003f <__TEXT_REGION_LENGTH__+0x70003f>
    2f12:	0f 90       	pop	r0
    2f14:	1f 90       	pop	r1
    2f16:	18 95       	reti

00002f18 <vApplicationIdleHook>:
u32 idleCnt;

//----------------------------------------------
//
void vApplicationIdleHook( void )
{
    2f18:	cf 93       	push	r28
    2f1a:	df 93       	push	r29
    2f1c:	cd b7       	in	r28, 0x3d	; 61
    2f1e:	de b7       	in	r29, 0x3e	; 62
	
	idleCnt++;
    2f20:	80 91 6f 2c 	lds	r24, 0x2C6F	; 0x802c6f <idleCnt>
    2f24:	90 91 70 2c 	lds	r25, 0x2C70	; 0x802c70 <idleCnt+0x1>
    2f28:	a0 91 71 2c 	lds	r26, 0x2C71	; 0x802c71 <idleCnt+0x2>
    2f2c:	b0 91 72 2c 	lds	r27, 0x2C72	; 0x802c72 <idleCnt+0x3>
    2f30:	01 96       	adiw	r24, 0x01	; 1
    2f32:	a1 1d       	adc	r26, r1
    2f34:	b1 1d       	adc	r27, r1
    2f36:	80 93 6f 2c 	sts	0x2C6F, r24	; 0x802c6f <idleCnt>
    2f3a:	90 93 70 2c 	sts	0x2C70, r25	; 0x802c70 <idleCnt+0x1>
    2f3e:	a0 93 71 2c 	sts	0x2C71, r26	; 0x802c71 <idleCnt+0x2>
    2f42:	b0 93 72 2c 	sts	0x2C72, r27	; 0x802c72 <idleCnt+0x3>

	#if RUNTIME_CHECKS == 1
	checkAllStacks();
    2f46:	0e 94 2d 14 	call	0x285a	; 0x285a <checkAllStacks>
	#endif

	SLEEPMGR_PREPARE_SLEEP(SLEEP_SMODE_IDLE_gc);
    2f4a:	88 e4       	ldi	r24, 0x48	; 72
    2f4c:	90 e0       	ldi	r25, 0x00	; 0
    2f4e:	28 e4       	ldi	r18, 0x48	; 72
    2f50:	30 e0       	ldi	r19, 0x00	; 0
    2f52:	f9 01       	movw	r30, r18
    2f54:	20 81       	ld	r18, Z
    2f56:	20 7f       	andi	r18, 0xF0	; 240
    2f58:	21 60       	ori	r18, 0x01	; 1
    2f5a:	fc 01       	movw	r30, r24
    2f5c:	20 83       	st	Z, r18
	cpu_sleep();
    2f5e:	88 95       	sleep
	SLEEPMGR_DISABLE_SLEEP();
    2f60:	88 e4       	ldi	r24, 0x48	; 72
    2f62:	90 e0       	ldi	r25, 0x00	; 0
    2f64:	28 e4       	ldi	r18, 0x48	; 72
    2f66:	30 e0       	ldi	r19, 0x00	; 0
    2f68:	f9 01       	movw	r30, r18
    2f6a:	20 81       	ld	r18, Z
    2f6c:	2e 7f       	andi	r18, 0xFE	; 254
    2f6e:	fc 01       	movw	r30, r24
    2f70:	20 83       	st	Z, r18
}
    2f72:	00 00       	nop
    2f74:	df 91       	pop	r29
    2f76:	cf 91       	pop	r28
    2f78:	08 95       	ret

00002f7a <main>:


//----------------------------------------------
//
int main(void)
{
    2f7a:	ef 92       	push	r14
    2f7c:	ff 92       	push	r15
    2f7e:	0f 93       	push	r16
    2f80:	cf 93       	push	r28
    2f82:	df 93       	push	r29
    2f84:	cd b7       	in	r28, 0x3d	; 61
    2f86:	de b7       	in	r29, 0x3e	; 62
    2f88:	2c 97       	sbiw	r28, 0x0c	; 12
    2f8a:	cd bf       	out	0x3d, r28	; 61
    2f8c:	de bf       	out	0x3e, r29	; 62
	// if you want to log/track sporadically  occurring
	// problems

	// software reset ?
	//
	if( RST.STATUS & RST_SRF_bm )
    2f8e:	88 e7       	ldi	r24, 0x78	; 120
    2f90:	90 e0       	ldi	r25, 0x00	; 0
    2f92:	fc 01       	movw	r30, r24
    2f94:	80 81       	ld	r24, Z
    2f96:	88 2f       	mov	r24, r24
    2f98:	90 e0       	ldi	r25, 0x00	; 0
    2f9a:	80 72       	andi	r24, 0x20	; 32
    2f9c:	99 27       	eor	r25, r25
    2f9e:	89 2b       	or	r24, r25
    2fa0:	31 f0       	breq	.+12     	; 0x2fae <main+0x34>
	{
		// reset this bit
		RST.STATUS = RST_SRF_bm;
    2fa2:	88 e7       	ldi	r24, 0x78	; 120
    2fa4:	90 e0       	ldi	r25, 0x00	; 0
    2fa6:	20 e2       	ldi	r18, 0x20	; 32
    2fa8:	fc 01       	movw	r30, r24
    2faa:	20 83       	st	Z, r18
    2fac:	2f c0       	rjmp	.+94     	; 0x300c <main+0x92>
	}
	// power on reset ?
	else if( RST.STATUS & RST_PORF_bm)
    2fae:	88 e7       	ldi	r24, 0x78	; 120
    2fb0:	90 e0       	ldi	r25, 0x00	; 0
    2fb2:	fc 01       	movw	r30, r24
    2fb4:	80 81       	ld	r24, Z
    2fb6:	88 2f       	mov	r24, r24
    2fb8:	90 e0       	ldi	r25, 0x00	; 0
    2fba:	81 70       	andi	r24, 0x01	; 1
    2fbc:	99 27       	eor	r25, r25
    2fbe:	89 2b       	or	r24, r25
    2fc0:	31 f0       	breq	.+12     	; 0x2fce <main+0x54>
	{
		// reset this bit
		RST.STATUS = RST_PORF_bm;
    2fc2:	88 e7       	ldi	r24, 0x78	; 120
    2fc4:	90 e0       	ldi	r25, 0x00	; 0
    2fc6:	21 e0       	ldi	r18, 0x01	; 1
    2fc8:	fc 01       	movw	r30, r24
    2fca:	20 83       	st	Z, r18
    2fcc:	1f c0       	rjmp	.+62     	; 0x300c <main+0x92>
	}
	// debugger reset ?
	else if( RST.STATUS & RST_PDIRF_bm)
    2fce:	88 e7       	ldi	r24, 0x78	; 120
    2fd0:	90 e0       	ldi	r25, 0x00	; 0
    2fd2:	fc 01       	movw	r30, r24
    2fd4:	80 81       	ld	r24, Z
    2fd6:	88 2f       	mov	r24, r24
    2fd8:	90 e0       	ldi	r25, 0x00	; 0
    2fda:	80 71       	andi	r24, 0x10	; 16
    2fdc:	99 27       	eor	r25, r25
    2fde:	89 2b       	or	r24, r25
    2fe0:	31 f0       	breq	.+12     	; 0x2fee <main+0x74>
	{
		// reset this bit
		RST.STATUS = RST_PDIRF_bm;
    2fe2:	88 e7       	ldi	r24, 0x78	; 120
    2fe4:	90 e0       	ldi	r25, 0x00	; 0
    2fe6:	20 e1       	ldi	r18, 0x10	; 16
    2fe8:	fc 01       	movw	r30, r24
    2fea:	20 83       	st	Z, r18
    2fec:	0f c0       	rjmp	.+30     	; 0x300c <main+0x92>
	}
	// external reset ?
	else if( RST.STATUS & RST_EXTRF_bm)
    2fee:	88 e7       	ldi	r24, 0x78	; 120
    2ff0:	90 e0       	ldi	r25, 0x00	; 0
    2ff2:	fc 01       	movw	r30, r24
    2ff4:	80 81       	ld	r24, Z
    2ff6:	88 2f       	mov	r24, r24
    2ff8:	90 e0       	ldi	r25, 0x00	; 0
    2ffa:	82 70       	andi	r24, 0x02	; 2
    2ffc:	99 27       	eor	r25, r25
    2ffe:	89 2b       	or	r24, r25
    3000:	29 f0       	breq	.+10     	; 0x300c <main+0x92>
	{
		// reset this bit
		RST.STATUS = RST_EXTRF_bm;
    3002:	88 e7       	ldi	r24, 0x78	; 120
    3004:	90 e0       	ldi	r25, 0x00	; 0
    3006:	22 e0       	ldi	r18, 0x02	; 2
    3008:	fc 01       	movw	r30, r24
    300a:	20 83       	st	Z, r18
	}

	size_t bytesLeft0 = xPortGetFreeHeapSize();
    300c:	0e 94 81 05 	call	0xb02	; 0xb02 <xPortGetFreeHeapSize>
    3010:	89 83       	std	Y+1, r24	; 0x01
    3012:	9a 83       	std	Y+2, r25	; 0x02
	// consistency check
	if(bytesLeft0 != configTOTAL_HEAP_SIZE)
    3014:	89 81       	ldd	r24, Y+1	; 0x01
    3016:	9a 81       	ldd	r25, Y+2	; 0x02
    3018:	88 3b       	cpi	r24, 0xB8	; 184
    301a:	9b 40       	sbci	r25, 0x0B	; 11
    301c:	19 f0       	breq	.+6      	; 0x3024 <main+0xaa>
	{
		error(ERR_LOW_HEAP_SPACE);
    301e:	84 e3       	ldi	r24, 0x34	; 52
    3020:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
	// There must be a minimum stack size to get the initializations done 
	// until the RTOS is running.
	// bss_end depends on configTOTAL_HEAP_SIZE. Decreasing configTOTAL_HEAP_SIZE gives
	// you room for the global stack.
	//
	s16 freeSpaceOnGlobalStack = SP - (uint16_t) &__bss_end;
    3024:	8d e3       	ldi	r24, 0x3D	; 61
    3026:	90 e0       	ldi	r25, 0x00	; 0
    3028:	fc 01       	movw	r30, r24
    302a:	20 81       	ld	r18, Z
    302c:	31 81       	ldd	r19, Z+1	; 0x01
    302e:	87 ea       	ldi	r24, 0xA7	; 167
    3030:	9c e2       	ldi	r25, 0x2C	; 44
    3032:	a9 01       	movw	r20, r18
    3034:	48 1b       	sub	r20, r24
    3036:	59 0b       	sbc	r21, r25
    3038:	ca 01       	movw	r24, r20
    303a:	8b 83       	std	Y+3, r24	; 0x03
    303c:	9c 83       	std	Y+4, r25	; 0x04

	// this value is a guess. It is double checked later on.
	#define MINIMUM_STACK_NEEDED 60
	if( freeSpaceOnGlobalStack < MINIMUM_STACK_NEEDED )	
    303e:	8b 81       	ldd	r24, Y+3	; 0x03
    3040:	9c 81       	ldd	r25, Y+4	; 0x04
    3042:	cc 97       	sbiw	r24, 0x3c	; 60
    3044:	1c f4       	brge	.+6      	; 0x304c <main+0xd2>
	{
		error(ERR_HEAP_TOO_LARGE); // decrease configTOTAL_HEAP_SIZE !
    3046:	8a e3       	ldi	r24, 0x3A	; 58
    3048:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
	}

	// how much stack do we have used up to now?
	u16 minimumStackLeft_before = get_mem_unused();
    304c:	0e 94 c9 18 	call	0x3192	; 0x3192 <get_mem_unused>
    3050:	8d 83       	std	Y+5, r24	; 0x05
    3052:	9e 83       	std	Y+6, r25	; 0x06
	// this should be nearly identical to freeSpaceOnGlobalStack
	// (so this is another consistency check)
	if( freeSpaceOnGlobalStack - minimumStackLeft_before > 10 )
    3054:	2b 81       	ldd	r18, Y+3	; 0x03
    3056:	3c 81       	ldd	r19, Y+4	; 0x04
    3058:	8d 81       	ldd	r24, Y+5	; 0x05
    305a:	9e 81       	ldd	r25, Y+6	; 0x06
    305c:	f9 01       	movw	r30, r18
    305e:	e8 1b       	sub	r30, r24
    3060:	f9 0b       	sbc	r31, r25
    3062:	cf 01       	movw	r24, r30
    3064:	0b 97       	sbiw	r24, 0x0b	; 11
    3066:	18 f0       	brcs	.+6      	; 0x306e <main+0xf4>
	{
		error(ERR_HEAP_TOO_LARGE); // decrease configTOTAL_HEAP_SIZE !
    3068:	8a e3       	ldi	r24, 0x3A	; 58
    306a:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
	}
	//Init clock
	vInitClock();
    306e:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <vInitClock>

	// all usart preparation including port pin setup
	initUsarts();
    3072:	0e 94 d3 14 	call	0x29a6	; 0x29a6 <initUsarts>

	// prepare the queues that hold the data that is ready to be sent out
	initChannelQueues();
    3076:	0e 94 50 19 	call	0x32a0	; 0x32a0 <initChannelQueues>

	//Init port settings (other than serial)
	vPortPreparation();
    307a:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <vPortPreparation>




	// Unused hardware modules are disabled to save power.
	disableUnusedModules();
    307e:	0e 94 12 16 	call	0x2c24	; 0x2c24 <disableUnusedModules>
	



	// Create the tasks
	txPriority = tskIDLE_PRIORITY+1;
    3082:	81 e0       	ldi	r24, 0x01	; 1
    3084:	8f 83       	std	Y+7, r24	; 0x07
	rxPriority = tskIDLE_PRIORITY+1;
    3086:	81 e0       	ldi	r24, 0x01	; 1
    3088:	88 87       	std	Y+8, r24	; 0x08

	xTaskCreate( vLedBlink, (const char *) "ledBlink", configMINIMAL_STACK_SIZE, NULL, 1,&hLedBlink);
    308a:	0f 2e       	mov	r0, r31
    308c:	fb e6       	ldi	r31, 0x6B	; 107
    308e:	ef 2e       	mov	r14, r31
    3090:	fc e2       	ldi	r31, 0x2C	; 44
    3092:	ff 2e       	mov	r15, r31
    3094:	f0 2d       	mov	r31, r0
    3096:	01 e0       	ldi	r16, 0x01	; 1
    3098:	20 e0       	ldi	r18, 0x00	; 0
    309a:	30 e0       	ldi	r19, 0x00	; 0
    309c:	48 ec       	ldi	r20, 0xC8	; 200
    309e:	50 e0       	ldi	r21, 0x00	; 0
    30a0:	65 e0       	ldi	r22, 0x05	; 5
    30a2:	70 e2       	ldi	r23, 0x20	; 32
    30a4:	8a e7       	ldi	r24, 0x7A	; 122
    30a6:	98 e1       	ldi	r25, 0x18	; 24
    30a8:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <xTaskCreate>
	// It must be >0 to ensure that the allocated data in .bss is not
	// touched during initialization of the tasks. 
	// If this error occurs the rtos heap size must be reduced. (The rtos stack
	// is located in .bss , but before the rtos scheduler is starting, the global 
	// stack at the top of the ram is used.)
	u16 minimumStackLeft_after = get_mem_unused();
    30ac:	0e 94 c9 18 	call	0x3192	; 0x3192 <get_mem_unused>
    30b0:	89 87       	std	Y+9, r24	; 0x09
    30b2:	9a 87       	std	Y+10, r25	; 0x0a
	if( minimumStackLeft_after == 0)
    30b4:	89 85       	ldd	r24, Y+9	; 0x09
    30b6:	9a 85       	ldd	r25, Y+10	; 0x0a
    30b8:	89 2b       	or	r24, r25
    30ba:	19 f4       	brne	.+6      	; 0x30c2 <main+0x148>
	{
		error(ERR_LOW_GLOBAL_STACK_SPACE);
    30bc:	8b e3       	ldi	r24, 0x3B	; 59
    30be:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
	}
		
	// Check the # of free bytes on the rtos-heap that may still be allocated by pvPortMalloc().
	// (the rtos heap size is specified in FreeRTOSConfig.h)
	size_t bytesLeft3 = xPortGetFreeHeapSize();
    30c2:	0e 94 81 05 	call	0xb02	; 0xb02 <xPortGetFreeHeapSize>
    30c6:	8b 87       	std	Y+11, r24	; 0x0b
    30c8:	9c 87       	std	Y+12, r25	; 0x0c

	// There must be a minimum of free rtos-heap space left
	// to successfully create the idle task in vTaskStartScheduler().
	#define MIN_STACKSIZE_TO_CREATE_IDLE_TASK 37 + configMINIMAL_STACK_SIZE
	if(bytesLeft3 < ( MIN_STACKSIZE_TO_CREATE_IDLE_TASK ) )
    30ca:	8b 85       	ldd	r24, Y+11	; 0x0b
    30cc:	9c 85       	ldd	r25, Y+12	; 0x0c
    30ce:	8d 3e       	cpi	r24, 0xED	; 237
    30d0:	91 05       	cpc	r25, r1
    30d2:	18 f4       	brcc	.+6      	; 0x30da <main+0x160>
	{
		// It will not be possible to create the idle task.
		// If we don't stop execution here, it will stop immediately after 
		// because of other runtime stack checks.
		//		
		error(ERR_LOW_HEAP_SPACE);
    30d4:	84 e3       	ldi	r24, 0x34	; 52
    30d6:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
	}

	vTaskStartScheduler();
    30da:	0e 94 75 0f 	call	0x1eea	; 0x1eea <vTaskStartScheduler>

	return 0;
    30de:	80 e0       	ldi	r24, 0x00	; 0
    30e0:	90 e0       	ldi	r25, 0x00	; 0
}
    30e2:	2c 96       	adiw	r28, 0x0c	; 12
    30e4:	cd bf       	out	0x3d, r28	; 61
    30e6:	de bf       	out	0x3e, r29	; 62
    30e8:	df 91       	pop	r29
    30ea:	cf 91       	pop	r28
    30ec:	0f 91       	pop	r16
    30ee:	ff 90       	pop	r15
    30f0:	ef 90       	pop	r14
    30f2:	08 95       	ret

000030f4 <vLedBlink>:


void vLedBlink(void *pvParameters) {
    30f4:	cf 93       	push	r28
    30f6:	df 93       	push	r29
    30f8:	1f 92       	push	r1
    30fa:	1f 92       	push	r1
    30fc:	cd b7       	in	r28, 0x3d	; 61
    30fe:	de b7       	in	r29, 0x3e	; 62
    3100:	89 83       	std	Y+1, r24	; 0x01
    3102:	9a 83       	std	Y+2, r25	; 0x02
	(void) pvParameters;

	PORTF.DIRSET = PIN0_bm; //LED1
    3104:	80 ea       	ldi	r24, 0xA0	; 160
    3106:	96 e0       	ldi	r25, 0x06	; 6
    3108:	21 e0       	ldi	r18, 0x01	; 1
    310a:	fc 01       	movw	r30, r24
    310c:	21 83       	std	Z+1, r18	; 0x01
	PORTF.DIRSET = PIN1_bm; //LED2
    310e:	80 ea       	ldi	r24, 0xA0	; 160
    3110:	96 e0       	ldi	r25, 0x06	; 6
    3112:	22 e0       	ldi	r18, 0x02	; 2
    3114:	fc 01       	movw	r30, r24
    3116:	21 83       	std	Z+1, r18	; 0x01
	PORTF.DIRSET = PIN2_bm; //LED3
    3118:	80 ea       	ldi	r24, 0xA0	; 160
    311a:	96 e0       	ldi	r25, 0x06	; 6
    311c:	24 e0       	ldi	r18, 0x04	; 4
    311e:	fc 01       	movw	r30, r24
    3120:	21 83       	std	Z+1, r18	; 0x01
	PORTF.DIRSET = PIN3_bm; //LED4
    3122:	80 ea       	ldi	r24, 0xA0	; 160
    3124:	96 e0       	ldi	r25, 0x06	; 6
    3126:	28 e0       	ldi	r18, 0x08	; 8
    3128:	fc 01       	movw	r30, r24
    312a:	21 83       	std	Z+1, r18	; 0x01
	
	PORTE.DIRSET = PIN0_bm; //LED5
    312c:	80 e8       	ldi	r24, 0x80	; 128
    312e:	96 e0       	ldi	r25, 0x06	; 6
    3130:	21 e0       	ldi	r18, 0x01	; 1
    3132:	fc 01       	movw	r30, r24
    3134:	21 83       	std	Z+1, r18	; 0x01
	PORTE.DIRSET = PIN1_bm; //LED6
    3136:	80 e8       	ldi	r24, 0x80	; 128
    3138:	96 e0       	ldi	r25, 0x06	; 6
    313a:	22 e0       	ldi	r18, 0x02	; 2
    313c:	fc 01       	movw	r30, r24
    313e:	21 83       	std	Z+1, r18	; 0x01
	PORTE.DIRSET = PIN2_bm; //LED7
    3140:	80 e8       	ldi	r24, 0x80	; 128
    3142:	96 e0       	ldi	r25, 0x06	; 6
    3144:	24 e0       	ldi	r18, 0x04	; 4
    3146:	fc 01       	movw	r30, r24
    3148:	21 83       	std	Z+1, r18	; 0x01
	PORTE.DIRSET = PIN3_bm; //LED8
    314a:	80 e8       	ldi	r24, 0x80	; 128
    314c:	96 e0       	ldi	r25, 0x06	; 6
    314e:	28 e0       	ldi	r18, 0x08	; 8
    3150:	fc 01       	movw	r30, r24
    3152:	21 83       	std	Z+1, r18	; 0x01

	for(;;) {
		PORTE.OUT = 0x0F;
    3154:	80 e8       	ldi	r24, 0x80	; 128
    3156:	96 e0       	ldi	r25, 0x06	; 6
    3158:	2f e0       	ldi	r18, 0x0F	; 15
    315a:	fc 01       	movw	r30, r24
    315c:	24 83       	std	Z+4, r18	; 0x04
		PORTF.OUT = 0x0F;
    315e:	80 ea       	ldi	r24, 0xA0	; 160
    3160:	96 e0       	ldi	r25, 0x06	; 6
    3162:	2f e0       	ldi	r18, 0x0F	; 15
    3164:	fc 01       	movw	r30, r24
    3166:	24 83       	std	Z+4, r18	; 0x04
		vTaskDelay(500 / portTICK_RATE_MS);
    3168:	64 ef       	ldi	r22, 0xF4	; 244
    316a:	71 e0       	ldi	r23, 0x01	; 1
    316c:	80 e0       	ldi	r24, 0x00	; 0
    316e:	90 e0       	ldi	r25, 0x00	; 0
    3170:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
		PORTE.OUT = 0x00;
    3174:	80 e8       	ldi	r24, 0x80	; 128
    3176:	96 e0       	ldi	r25, 0x06	; 6
    3178:	fc 01       	movw	r30, r24
    317a:	14 82       	std	Z+4, r1	; 0x04
		PORTF.OUT = 0x00;
    317c:	80 ea       	ldi	r24, 0xA0	; 160
    317e:	96 e0       	ldi	r25, 0x06	; 6
    3180:	fc 01       	movw	r30, r24
    3182:	14 82       	std	Z+4, r1	; 0x04
		vTaskDelay(500 / portTICK_RATE_MS);
    3184:	64 ef       	ldi	r22, 0xF4	; 244
    3186:	71 e0       	ldi	r23, 0x01	; 1
    3188:	80 e0       	ldi	r24, 0x00	; 0
    318a:	90 e0       	ldi	r25, 0x00	; 0
    318c:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
		//sendData();
	}
    3190:	e1 cf       	rjmp	.-62     	; 0x3154 <vLedBlink+0x60>

00003192 <get_mem_unused>:
// !!! discouraged on AVR, anyway). alloca, however, is no problem
// !!! because it allocates on stack.

//  Get minimum of free memory (in bytes) up to now.
unsigned short get_mem_unused (void)
{
    3192:	cf 93       	push	r28
    3194:	df 93       	push	r29
    3196:	00 d0       	rcall	.+0      	; 0x3198 <get_mem_unused+0x6>
    3198:	1f 92       	push	r1
    319a:	cd b7       	in	r28, 0x3d	; 61
    319c:	de b7       	in	r29, 0x3e	; 62
   unsigned short unused = 0;
    319e:	19 82       	std	Y+1, r1	; 0x01
    31a0:	1a 82       	std	Y+2, r1	; 0x02
   unsigned char *p = &__heap_start;
    31a2:	87 ea       	ldi	r24, 0xA7	; 167
    31a4:	9c e2       	ldi	r25, 0x2C	; 44
    31a6:	8b 83       	std	Y+3, r24	; 0x03
    31a8:	9c 83       	std	Y+4, r25	; 0x04

   do
   {
      if (*p++ != MASK)
    31aa:	8b 81       	ldd	r24, Y+3	; 0x03
    31ac:	9c 81       	ldd	r25, Y+4	; 0x04
    31ae:	9c 01       	movw	r18, r24
    31b0:	2f 5f       	subi	r18, 0xFF	; 255
    31b2:	3f 4f       	sbci	r19, 0xFF	; 255
    31b4:	2b 83       	std	Y+3, r18	; 0x03
    31b6:	3c 83       	std	Y+4, r19	; 0x04
    31b8:	fc 01       	movw	r30, r24
    31ba:	80 81       	ld	r24, Z
    31bc:	8a 3a       	cpi	r24, 0xAA	; 170
    31be:	59 f4       	brne	.+22     	; 0x31d6 <get_mem_unused+0x44>
         break;

      unused++;
    31c0:	89 81       	ldd	r24, Y+1	; 0x01
    31c2:	9a 81       	ldd	r25, Y+2	; 0x02
    31c4:	01 96       	adiw	r24, 0x01	; 1
    31c6:	89 83       	std	Y+1, r24	; 0x01
    31c8:	9a 83       	std	Y+2, r25	; 0x02
   } while (p <= (unsigned char*) RAMEND);
    31ca:	8b 81       	ldd	r24, Y+3	; 0x03
    31cc:	9c 81       	ldd	r25, Y+4	; 0x04
    31ce:	81 15       	cp	r24, r1
    31d0:	90 44       	sbci	r25, 0x40	; 64
    31d2:	58 f3       	brcs	.-42     	; 0x31aa <get_mem_unused+0x18>
    31d4:	01 c0       	rjmp	.+2      	; 0x31d8 <get_mem_unused+0x46>
   unsigned char *p = &__heap_start;

   do
   {
      if (*p++ != MASK)
         break;
    31d6:	00 00       	nop

      unused++;
   } while (p <= (unsigned char*) RAMEND);

   return unused;
    31d8:	89 81       	ldd	r24, Y+1	; 0x01
    31da:	9a 81       	ldd	r25, Y+2	; 0x02
}
    31dc:	24 96       	adiw	r28, 0x04	; 4
    31de:	cd bf       	out	0x3d, r28	; 61
    31e0:	de bf       	out	0x3e, r29	; 62
    31e2:	df 91       	pop	r29
    31e4:	cf 91       	pop	r28
    31e6:	08 95       	ret

000031e8 <__vector_77>:
	// Setup clock source and compare match behaviour.
	TC0_ConfigClockSource( &TCD0, TC_CLKSEL_DIV64_gc);

	// Enable the medium-level interrupt.
	TC0_SetOverflowIntLevel( &TCD0, TC_OVFINTLVL_MED_gc);
}
    31e8:	1f 92       	push	r1
    31ea:	0f 92       	push	r0
    31ec:	00 90 3f 00 	lds	r0, 0x003F	; 0x80003f <__TEXT_REGION_LENGTH__+0x70003f>
    31f0:	0f 92       	push	r0
    31f2:	11 24       	eor	r1, r1
    31f4:	8f 93       	push	r24
    31f6:	9f 93       	push	r25
    31f8:	af 93       	push	r26
    31fa:	bf 93       	push	r27
    31fc:	cf 93       	push	r28
    31fe:	df 93       	push	r29
    3200:	cd b7       	in	r28, 0x3d	; 61
    3202:	de b7       	in	r29, 0x3e	; 62
    3204:	80 91 79 2c 	lds	r24, 0x2C79	; 0x802c79 <medIsrCnt>
    3208:	90 91 7a 2c 	lds	r25, 0x2C7A	; 0x802c7a <medIsrCnt+0x1>
    320c:	a0 91 7b 2c 	lds	r26, 0x2C7B	; 0x802c7b <medIsrCnt+0x2>
    3210:	b0 91 7c 2c 	lds	r27, 0x2C7C	; 0x802c7c <medIsrCnt+0x3>
    3214:	01 96       	adiw	r24, 0x01	; 1
    3216:	a1 1d       	adc	r26, r1
    3218:	b1 1d       	adc	r27, r1
    321a:	80 93 79 2c 	sts	0x2C79, r24	; 0x802c79 <medIsrCnt>
    321e:	90 93 7a 2c 	sts	0x2C7A, r25	; 0x802c7a <medIsrCnt+0x1>
    3222:	a0 93 7b 2c 	sts	0x2C7B, r26	; 0x802c7b <medIsrCnt+0x2>
    3226:	b0 93 7c 2c 	sts	0x2C7C, r27	; 0x802c7c <medIsrCnt+0x3>
    322a:	00 00       	nop
    322c:	df 91       	pop	r29
    322e:	cf 91       	pop	r28
    3230:	bf 91       	pop	r27
    3232:	af 91       	pop	r26
    3234:	9f 91       	pop	r25
    3236:	8f 91       	pop	r24
    3238:	0f 90       	pop	r0
    323a:	00 92 3f 00 	sts	0x003F, r0	; 0x80003f <__TEXT_REGION_LENGTH__+0x70003f>
    323e:	0f 90       	pop	r0
    3240:	1f 90       	pop	r1
    3242:	18 95       	reti

00003244 <__vector_83>:
//
u32 highIsrCnt;


ISR(TCD1_OVF_vect)
{
    3244:	1f 92       	push	r1
    3246:	0f 92       	push	r0
    3248:	00 90 3f 00 	lds	r0, 0x003F	; 0x80003f <__TEXT_REGION_LENGTH__+0x70003f>
    324c:	0f 92       	push	r0
    324e:	11 24       	eor	r1, r1
    3250:	8f 93       	push	r24
    3252:	9f 93       	push	r25
    3254:	af 93       	push	r26
    3256:	bf 93       	push	r27
    3258:	cf 93       	push	r28
    325a:	df 93       	push	r29
    325c:	cd b7       	in	r28, 0x3d	; 61
    325e:	de b7       	in	r29, 0x3e	; 62
	// This non-naked isr has a framepointer and local variables
	// my be used.

	highIsrCnt++;
    3260:	80 91 75 2c 	lds	r24, 0x2C75	; 0x802c75 <highIsrCnt>
    3264:	90 91 76 2c 	lds	r25, 0x2C76	; 0x802c76 <highIsrCnt+0x1>
    3268:	a0 91 77 2c 	lds	r26, 0x2C77	; 0x802c77 <highIsrCnt+0x2>
    326c:	b0 91 78 2c 	lds	r27, 0x2C78	; 0x802c78 <highIsrCnt+0x3>
    3270:	01 96       	adiw	r24, 0x01	; 1
    3272:	a1 1d       	adc	r26, r1
    3274:	b1 1d       	adc	r27, r1
    3276:	80 93 75 2c 	sts	0x2C75, r24	; 0x802c75 <highIsrCnt>
    327a:	90 93 76 2c 	sts	0x2C76, r25	; 0x802c76 <highIsrCnt+0x1>
    327e:	a0 93 77 2c 	sts	0x2C77, r26	; 0x802c77 <highIsrCnt+0x2>
    3282:	b0 93 78 2c 	sts	0x2C78, r27	; 0x802c78 <highIsrCnt+0x3>
}
    3286:	00 00       	nop
    3288:	df 91       	pop	r29
    328a:	cf 91       	pop	r28
    328c:	bf 91       	pop	r27
    328e:	af 91       	pop	r26
    3290:	9f 91       	pop	r25
    3292:	8f 91       	pop	r24
    3294:	0f 90       	pop	r0
    3296:	00 92 3f 00 	sts	0x003F, r0	; 0x80003f <__TEXT_REGION_LENGTH__+0x70003f>
    329a:	0f 90       	pop	r0
    329c:	1f 90       	pop	r1
    329e:	18 95       	reti

000032a0 <initChannelQueues>:
//-----------------------------------------------------------
//
// There is one channel queue per serial receiver.
//
void initChannelQueues(void)
{
    32a0:	cf 93       	push	r28
    32a2:	df 93       	push	r29
    32a4:	1f 92       	push	r1
    32a6:	1f 92       	push	r1
    32a8:	cd b7       	in	r28, 0x3d	; 61
    32aa:	de b7       	in	r29, 0x3e	; 62
	const unsigned portBASE_TYPE chQueueLength       = CHANNEL_QUEUE_LENGTH;  
    32ac:	84 ea       	ldi	r24, 0xA4	; 164
    32ae:	89 83       	std	Y+1, r24	; 0x01
	const unsigned portBASE_TYPE dispatchQueueLength = 5;   
    32b0:	85 e0       	ldi	r24, 0x05	; 5
    32b2:	8a 83       	std	Y+2, r24	; 0x02


	if((vUSARTC1_channelQueue = xQueueCreate(chQueueLength, (unsigned portBASE_TYPE ) sizeof(signed char))) == NULL)
    32b4:	40 e0       	ldi	r20, 0x00	; 0
    32b6:	61 e0       	ldi	r22, 0x01	; 1
    32b8:	89 81       	ldd	r24, Y+1	; 0x01
    32ba:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xQueueGenericCreate>
    32be:	80 93 7d 2c 	sts	0x2C7D, r24	; 0x802c7d <vUSARTC1_channelQueue>
    32c2:	90 93 7e 2c 	sts	0x2C7E, r25	; 0x802c7e <vUSARTC1_channelQueue+0x1>
    32c6:	80 91 7d 2c 	lds	r24, 0x2C7D	; 0x802c7d <vUSARTC1_channelQueue>
    32ca:	90 91 7e 2c 	lds	r25, 0x2C7E	; 0x802c7e <vUSARTC1_channelQueue+0x1>
    32ce:	89 2b       	or	r24, r25
    32d0:	19 f4       	brne	.+6      	; 0x32d8 <initChannelQueues+0x38>
		error(ERR_QUEUE_CREATE_HANDLE_NULL);
    32d2:	8a e2       	ldi	r24, 0x2A	; 42
    32d4:	0e 94 9e 14 	call	0x293c	; 0x293c <error>

	if((vUSARTE0_channelQueue = xQueueCreate(chQueueLength, (unsigned portBASE_TYPE ) sizeof(signed char))) == NULL)
    32d8:	40 e0       	ldi	r20, 0x00	; 0
    32da:	61 e0       	ldi	r22, 0x01	; 1
    32dc:	89 81       	ldd	r24, Y+1	; 0x01
    32de:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xQueueGenericCreate>
    32e2:	80 93 9b 2c 	sts	0x2C9B, r24	; 0x802c9b <vUSARTE0_channelQueue>
    32e6:	90 93 9c 2c 	sts	0x2C9C, r25	; 0x802c9c <vUSARTE0_channelQueue+0x1>
    32ea:	80 91 9b 2c 	lds	r24, 0x2C9B	; 0x802c9b <vUSARTE0_channelQueue>
    32ee:	90 91 9c 2c 	lds	r25, 0x2C9C	; 0x802c9c <vUSARTE0_channelQueue+0x1>
    32f2:	89 2b       	or	r24, r25
    32f4:	19 f4       	brne	.+6      	; 0x32fc <initChannelQueues+0x5c>
		error(ERR_QUEUE_CREATE_HANDLE_NULL);
    32f6:	8a e2       	ldi	r24, 0x2A	; 42
    32f8:	0e 94 9e 14 	call	0x293c	; 0x293c <error>

	channelIndex[C1_channelNo] = vUSARTC1_channelQueue;
    32fc:	80 91 7d 2c 	lds	r24, 0x2C7D	; 0x802c7d <vUSARTC1_channelQueue>
    3300:	90 91 7e 2c 	lds	r25, 0x2C7E	; 0x802c7e <vUSARTC1_channelQueue+0x1>
    3304:	80 93 81 2c 	sts	0x2C81, r24	; 0x802c81 <channelIndex+0x2>
    3308:	90 93 82 2c 	sts	0x2C82, r25	; 0x802c82 <channelIndex+0x3>
	channelIndex[E0_channelNo] = vUSARTE0_channelQueue;
    330c:	80 91 9b 2c 	lds	r24, 0x2C9B	; 0x802c9b <vUSARTE0_channelQueue>
    3310:	90 91 9c 2c 	lds	r25, 0x2C9C	; 0x802c9c <vUSARTE0_channelQueue+0x1>
    3314:	80 93 87 2c 	sts	0x2C87, r24	; 0x802c87 <channelIndex+0x8>
    3318:	90 93 88 2c 	sts	0x2C88, r25	; 0x802c88 <channelIndex+0x9>


	// The dispatch queue tells which channel has the next 
	// datagram complete to send.
	if((vChannelDispatchQueue = xQueueCreate(dispatchQueueLength, (unsigned portBASE_TYPE ) sizeof(signed char))) == NULL)
    331c:	40 e0       	ldi	r20, 0x00	; 0
    331e:	61 e0       	ldi	r22, 0x01	; 1
    3320:	8a 81       	ldd	r24, Y+2	; 0x02
    3322:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xQueueGenericCreate>
    3326:	80 93 99 2c 	sts	0x2C99, r24	; 0x802c99 <vChannelDispatchQueue>
    332a:	90 93 9a 2c 	sts	0x2C9A, r25	; 0x802c9a <vChannelDispatchQueue+0x1>
    332e:	80 91 99 2c 	lds	r24, 0x2C99	; 0x802c99 <vChannelDispatchQueue>
    3332:	90 91 9a 2c 	lds	r25, 0x2C9A	; 0x802c9a <vChannelDispatchQueue+0x1>
    3336:	89 2b       	or	r24, r25
    3338:	19 f4       	brne	.+6      	; 0x3340 <initChannelQueues+0xa0>
		error(ERR_QUEUE_CREATE_HANDLE_NULL);
    333a:	8a e2       	ldi	r24, 0x2A	; 42
    333c:	0e 94 9e 14 	call	0x293c	; 0x293c <error>
}
    3340:	00 00       	nop
    3342:	0f 90       	pop	r0
    3344:	0f 90       	pop	r0
    3346:	df 91       	pop	r29
    3348:	cf 91       	pop	r28
    334a:	08 95       	ret

0000334c <sm_init>:


// datagram state machine handlers
//
void sm_init(dgStateMaschine_t* sm)
{
    334c:	cf 93       	push	r28
    334e:	df 93       	push	r29
    3350:	1f 92       	push	r1
    3352:	1f 92       	push	r1
    3354:	cd b7       	in	r28, 0x3d	; 61
    3356:	de b7       	in	r29, 0x3e	; 62
    3358:	89 83       	std	Y+1, r24	; 0x01
    335a:	9a 83       	std	Y+2, r25	; 0x02
	sm->state = outside;
    335c:	89 81       	ldd	r24, Y+1	; 0x01
    335e:	9a 81       	ldd	r25, Y+2	; 0x02
    3360:	fc 01       	movw	r30, r24
    3362:	10 82       	st	Z, r1
}
    3364:	00 00       	nop
    3366:	0f 90       	pop	r0
    3368:	0f 90       	pop	r0
    336a:	df 91       	pop	r29
    336c:	cf 91       	pop	r28
    336e:	08 95       	ret

00003370 <sm_setState>:


// returns false if the checksum is not as expected.
//
bool sm_setState(dgStateMaschine_t* sm, char cChar)
{
    3370:	cf 93       	push	r28
    3372:	df 93       	push	r29
    3374:	00 d0       	rcall	.+0      	; 0x3376 <sm_setState+0x6>
    3376:	cd b7       	in	r28, 0x3d	; 61
    3378:	de b7       	in	r29, 0x3e	; 62
    337a:	89 83       	std	Y+1, r24	; 0x01
    337c:	9a 83       	std	Y+2, r25	; 0x02
    337e:	6b 83       	std	Y+3, r22	; 0x03
	return internalSetState(sm, cChar);
    3380:	89 81       	ldd	r24, Y+1	; 0x01
    3382:	9a 81       	ldd	r25, Y+2	; 0x02
    3384:	6b 81       	ldd	r22, Y+3	; 0x03
    3386:	0e 94 cb 19 	call	0x3396	; 0x3396 <internalSetState>
}
    338a:	23 96       	adiw	r28, 0x03	; 3
    338c:	cd bf       	out	0x3d, r28	; 61
    338e:	de bf       	out	0x3e, r29	; 62
    3390:	df 91       	pop	r29
    3392:	cf 91       	pop	r28
    3394:	08 95       	ret

00003396 <internalSetState>:

}
*/

static bool internalSetState(dgStateMaschine_t* sm, char cChar)
{
    3396:	cf 93       	push	r28
    3398:	df 93       	push	r29
    339a:	cd b7       	in	r28, 0x3d	; 61
    339c:	de b7       	in	r29, 0x3e	; 62
    339e:	25 97       	sbiw	r28, 0x05	; 5
    33a0:	cd bf       	out	0x3d, r28	; 61
    33a2:	de bf       	out	0x3e, r29	; 62
    33a4:	8b 83       	std	Y+3, r24	; 0x03
    33a6:	9c 83       	std	Y+4, r25	; 0x04
    33a8:	6d 83       	std	Y+5, r22	; 0x05
	switch(sm->state)
    33aa:	8b 81       	ldd	r24, Y+3	; 0x03
    33ac:	9c 81       	ldd	r25, Y+4	; 0x04
    33ae:	fc 01       	movw	r30, r24
    33b0:	80 81       	ld	r24, Z
    33b2:	88 2f       	mov	r24, r24
    33b4:	90 e0       	ldi	r25, 0x00	; 0
    33b6:	81 30       	cpi	r24, 0x01	; 1
    33b8:	91 05       	cpc	r25, r1
    33ba:	f1 f0       	breq	.+60     	; 0x33f8 <internalSetState+0x62>
    33bc:	82 30       	cpi	r24, 0x02	; 2
    33be:	91 05       	cpc	r25, r1
    33c0:	1c f4       	brge	.+6      	; 0x33c8 <internalSetState+0x32>
    33c2:	89 2b       	or	r24, r25
    33c4:	41 f0       	breq	.+16     	; 0x33d6 <internalSetState+0x40>
    33c6:	6b c0       	rjmp	.+214    	; 0x349e <internalSetState+0x108>
    33c8:	82 30       	cpi	r24, 0x02	; 2
    33ca:	91 05       	cpc	r25, r1
    33cc:	b1 f1       	breq	.+108    	; 0x343a <internalSetState+0xa4>
    33ce:	03 97       	sbiw	r24, 0x03	; 3
    33d0:	09 f4       	brne	.+2      	; 0x33d4 <internalSetState+0x3e>
    33d2:	3e c0       	rjmp	.+124    	; 0x3450 <internalSetState+0xba>
    33d4:	64 c0       	rjmp	.+200    	; 0x349e <internalSetState+0x108>
	{
		case outside:
			if( cChar=='$' || cChar=='!' )
    33d6:	8d 81       	ldd	r24, Y+5	; 0x05
    33d8:	84 32       	cpi	r24, 0x24	; 36
    33da:	21 f0       	breq	.+8      	; 0x33e4 <internalSetState+0x4e>
    33dc:	8d 81       	ldd	r24, Y+5	; 0x05
    33de:	81 32       	cpi	r24, 0x21	; 33
    33e0:	09 f0       	breq	.+2      	; 0x33e4 <internalSetState+0x4e>
    33e2:	62 c0       	rjmp	.+196    	; 0x34a8 <internalSetState+0x112>
			{
				sm->chksum = 0; // '$' is not part of the check sum, start with new checksum calc here!
    33e4:	8b 81       	ldd	r24, Y+3	; 0x03
    33e6:	9c 81       	ldd	r25, Y+4	; 0x04
    33e8:	fc 01       	movw	r30, r24
    33ea:	11 82       	std	Z+1, r1	; 0x01
				sm->state  = inside ;	
    33ec:	8b 81       	ldd	r24, Y+3	; 0x03
    33ee:	9c 81       	ldd	r25, Y+4	; 0x04
    33f0:	21 e0       	ldi	r18, 0x01	; 1
    33f2:	fc 01       	movw	r30, r24
    33f4:	20 83       	st	Z, r18
			}
		break;
    33f6:	58 c0       	rjmp	.+176    	; 0x34a8 <internalSetState+0x112>
		case inside:			
			if( cChar == '*' )
    33f8:	8d 81       	ldd	r24, Y+5	; 0x05
    33fa:	8a 32       	cpi	r24, 0x2A	; 42
    33fc:	31 f4       	brne	.+12     	; 0x340a <internalSetState+0x74>
				// '*' is not in the check sum, omit checksum calc here!
				sm->state = eom; // next 2 chars are the checksum		 
    33fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3400:	9c 81       	ldd	r25, Y+4	; 0x04
    3402:	22 e0       	ldi	r18, 0x02	; 2
    3404:	fc 01       	movw	r30, r24
    3406:	20 83       	st	Z, r18
    3408:	0c c0       	rjmp	.+24     	; 0x3422 <internalSetState+0x8c>
			else
				sm->chksum ^= cChar;
    340a:	8b 81       	ldd	r24, Y+3	; 0x03
    340c:	9c 81       	ldd	r25, Y+4	; 0x04
    340e:	fc 01       	movw	r30, r24
    3410:	81 81       	ldd	r24, Z+1	; 0x01
    3412:	98 2f       	mov	r25, r24
    3414:	8d 81       	ldd	r24, Y+5	; 0x05
    3416:	89 27       	eor	r24, r25
    3418:	28 2f       	mov	r18, r24
    341a:	8b 81       	ldd	r24, Y+3	; 0x03
    341c:	9c 81       	ldd	r25, Y+4	; 0x04
    341e:	fc 01       	movw	r30, r24
    3420:	21 83       	std	Z+1, r18	; 0x01
			if( cChar == '\r' || cChar == '\n' )
    3422:	8d 81       	ldd	r24, Y+5	; 0x05
    3424:	8d 30       	cpi	r24, 0x0D	; 13
    3426:	21 f0       	breq	.+8      	; 0x3430 <internalSetState+0x9a>
    3428:	8d 81       	ldd	r24, Y+5	; 0x05
    342a:	8a 30       	cpi	r24, 0x0A	; 10
    342c:	09 f0       	breq	.+2      	; 0x3430 <internalSetState+0x9a>
    342e:	3e c0       	rjmp	.+124    	; 0x34ac <internalSetState+0x116>
				sm->state = outside;
    3430:	8b 81       	ldd	r24, Y+3	; 0x03
    3432:	9c 81       	ldd	r25, Y+4	; 0x04
    3434:	fc 01       	movw	r30, r24
    3436:	10 82       	st	Z, r1
		break;
    3438:	39 c0       	rjmp	.+114    	; 0x34ac <internalSetState+0x116>
		case eom:	
			(sm->chkstr)[0] = cChar;	
    343a:	8b 81       	ldd	r24, Y+3	; 0x03
    343c:	9c 81       	ldd	r25, Y+4	; 0x04
    343e:	2d 81       	ldd	r18, Y+5	; 0x05
    3440:	fc 01       	movw	r30, r24
    3442:	22 83       	std	Z+2, r18	; 0x02
			sm->state = chks1;		 
    3444:	8b 81       	ldd	r24, Y+3	; 0x03
    3446:	9c 81       	ldd	r25, Y+4	; 0x04
    3448:	23 e0       	ldi	r18, 0x03	; 3
    344a:	fc 01       	movw	r30, r24
    344c:	20 83       	st	Z, r18
		break;
    344e:	31 c0       	rjmp	.+98     	; 0x34b2 <internalSetState+0x11c>
		case chks1:
			(sm->chkstr)[1] = cChar;
    3450:	8b 81       	ldd	r24, Y+3	; 0x03
    3452:	9c 81       	ldd	r25, Y+4	; 0x04
    3454:	2d 81       	ldd	r18, Y+5	; 0x05
    3456:	fc 01       	movw	r30, r24
    3458:	23 83       	std	Z+3, r18	; 0x03
			(sm->chkstr)[2] = '\0';
    345a:	8b 81       	ldd	r24, Y+3	; 0x03
    345c:	9c 81       	ldd	r25, Y+4	; 0x04
    345e:	fc 01       	movw	r30, r24
    3460:	14 82       	std	Z+4, r1	; 0x04
			sm->state = outside; // not inside a datagram anymore
    3462:	8b 81       	ldd	r24, Y+3	; 0x03
    3464:	9c 81       	ldd	r25, Y+4	; 0x04
    3466:	fc 01       	movw	r30, r24
    3468:	10 82       	st	Z, r1
		
			u16 cs = strtoul(sm->chkstr,NULL,16);
    346a:	8b 81       	ldd	r24, Y+3	; 0x03
    346c:	9c 81       	ldd	r25, Y+4	; 0x04
    346e:	02 96       	adiw	r24, 0x02	; 2
    3470:	40 e1       	ldi	r20, 0x10	; 16
    3472:	50 e0       	ldi	r21, 0x00	; 0
    3474:	60 e0       	ldi	r22, 0x00	; 0
    3476:	70 e0       	ldi	r23, 0x00	; 0
    3478:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <strtoul>
    347c:	dc 01       	movw	r26, r24
    347e:	cb 01       	movw	r24, r22
    3480:	89 83       	std	Y+1, r24	; 0x01
    3482:	9a 83       	std	Y+2, r25	; 0x02
		 	if( (u8)(sm->chksum) != cs )
    3484:	8b 81       	ldd	r24, Y+3	; 0x03
    3486:	9c 81       	ldd	r25, Y+4	; 0x04
    3488:	fc 01       	movw	r30, r24
    348a:	81 81       	ldd	r24, Z+1	; 0x01
    348c:	28 2f       	mov	r18, r24
    348e:	30 e0       	ldi	r19, 0x00	; 0
    3490:	89 81       	ldd	r24, Y+1	; 0x01
    3492:	9a 81       	ldd	r25, Y+2	; 0x02
    3494:	28 17       	cp	r18, r24
    3496:	39 07       	cpc	r19, r25
    3498:	59 f0       	breq	.+22     	; 0x34b0 <internalSetState+0x11a>
				return false;
    349a:	80 e0       	ldi	r24, 0x00	; 0
    349c:	0b c0       	rjmp	.+22     	; 0x34b4 <internalSetState+0x11e>
		break;
		default:
			sm->state = outside;
    349e:	8b 81       	ldd	r24, Y+3	; 0x03
    34a0:	9c 81       	ldd	r25, Y+4	; 0x04
    34a2:	fc 01       	movw	r30, r24
    34a4:	10 82       	st	Z, r1
		break;
    34a6:	05 c0       	rjmp	.+10     	; 0x34b2 <internalSetState+0x11c>
			if( cChar=='$' || cChar=='!' )
			{
				sm->chksum = 0; // '$' is not part of the check sum, start with new checksum calc here!
				sm->state  = inside ;	
			}
		break;
    34a8:	00 00       	nop
    34aa:	03 c0       	rjmp	.+6      	; 0x34b2 <internalSetState+0x11c>
				sm->state = eom; // next 2 chars are the checksum		 
			else
				sm->chksum ^= cChar;
			if( cChar == '\r' || cChar == '\n' )
				sm->state = outside;
		break;
    34ac:	00 00       	nop
    34ae:	01 c0       	rjmp	.+2      	; 0x34b2 <internalSetState+0x11c>
			sm->state = outside; // not inside a datagram anymore
		
			u16 cs = strtoul(sm->chkstr,NULL,16);
		 	if( (u8)(sm->chksum) != cs )
				return false;
		break;
    34b0:	00 00       	nop
		default:
			sm->state = outside;
		break;
	}
	return true; // everything OK, including checksum
    34b2:	81 e0       	ldi	r24, 0x01	; 1
}
    34b4:	25 96       	adiw	r28, 0x05	; 5
    34b6:	cd bf       	out	0x3d, r28	; 61
    34b8:	de bf       	out	0x3e, r29	; 62
    34ba:	df 91       	pop	r29
    34bc:	cf 91       	pop	r28
    34be:	08 95       	ret

000034c0 <strtoul>:
    34c0:	3f 92       	push	r3
    34c2:	4f 92       	push	r4
    34c4:	5f 92       	push	r5
    34c6:	6f 92       	push	r6
    34c8:	7f 92       	push	r7
    34ca:	8f 92       	push	r8
    34cc:	9f 92       	push	r9
    34ce:	af 92       	push	r10
    34d0:	bf 92       	push	r11
    34d2:	cf 92       	push	r12
    34d4:	df 92       	push	r13
    34d6:	ef 92       	push	r14
    34d8:	ff 92       	push	r15
    34da:	0f 93       	push	r16
    34dc:	1f 93       	push	r17
    34de:	cf 93       	push	r28
    34e0:	df 93       	push	r29
    34e2:	5c 01       	movw	r10, r24
    34e4:	6b 01       	movw	r12, r22
    34e6:	7a 01       	movw	r14, r20
    34e8:	61 15       	cp	r22, r1
    34ea:	71 05       	cpc	r23, r1
    34ec:	19 f0       	breq	.+6      	; 0x34f4 <strtoul+0x34>
    34ee:	fb 01       	movw	r30, r22
    34f0:	80 83       	st	Z, r24
    34f2:	91 83       	std	Z+1, r25	; 0x01
    34f4:	e1 14       	cp	r14, r1
    34f6:	f1 04       	cpc	r15, r1
    34f8:	29 f0       	breq	.+10     	; 0x3504 <strtoul+0x44>
    34fa:	c7 01       	movw	r24, r14
    34fc:	02 97       	sbiw	r24, 0x02	; 2
    34fe:	83 97       	sbiw	r24, 0x23	; 35
    3500:	08 f0       	brcs	.+2      	; 0x3504 <strtoul+0x44>
    3502:	c9 c0       	rjmp	.+402    	; 0x3696 <strtoul+0x1d6>
    3504:	e5 01       	movw	r28, r10
    3506:	21 96       	adiw	r28, 0x01	; 1
    3508:	f5 01       	movw	r30, r10
    350a:	10 81       	ld	r17, Z
    350c:	81 2f       	mov	r24, r17
    350e:	90 e0       	ldi	r25, 0x00	; 0
    3510:	0e 94 6d 1b 	call	0x36da	; 0x36da <isspace>
    3514:	89 2b       	or	r24, r25
    3516:	11 f0       	breq	.+4      	; 0x351c <strtoul+0x5c>
    3518:	5e 01       	movw	r10, r28
    351a:	f4 cf       	rjmp	.-24     	; 0x3504 <strtoul+0x44>
    351c:	1d 32       	cpi	r17, 0x2D	; 45
    351e:	29 f4       	brne	.+10     	; 0x352a <strtoul+0x6a>
    3520:	21 96       	adiw	r28, 0x01	; 1
    3522:	f5 01       	movw	r30, r10
    3524:	11 81       	ldd	r17, Z+1	; 0x01
    3526:	01 e0       	ldi	r16, 0x01	; 1
    3528:	07 c0       	rjmp	.+14     	; 0x3538 <strtoul+0x78>
    352a:	1b 32       	cpi	r17, 0x2B	; 43
    352c:	21 f4       	brne	.+8      	; 0x3536 <strtoul+0x76>
    352e:	e5 01       	movw	r28, r10
    3530:	22 96       	adiw	r28, 0x02	; 2
    3532:	f5 01       	movw	r30, r10
    3534:	11 81       	ldd	r17, Z+1	; 0x01
    3536:	00 e0       	ldi	r16, 0x00	; 0
    3538:	e1 14       	cp	r14, r1
    353a:	f1 04       	cpc	r15, r1
    353c:	b1 f0       	breq	.+44     	; 0x356a <strtoul+0xaa>
    353e:	f0 e1       	ldi	r31, 0x10	; 16
    3540:	ef 16       	cp	r14, r31
    3542:	f1 04       	cpc	r15, r1
    3544:	29 f4       	brne	.+10     	; 0x3550 <strtoul+0x90>
    3546:	b0 c0       	rjmp	.+352    	; 0x36a8 <strtoul+0x1e8>
    3548:	10 e3       	ldi	r17, 0x30	; 48
    354a:	e1 14       	cp	r14, r1
    354c:	f1 04       	cpc	r15, r1
    354e:	01 f1       	breq	.+64     	; 0x3590 <strtoul+0xd0>
    3550:	2a e0       	ldi	r18, 0x0A	; 10
    3552:	e2 16       	cp	r14, r18
    3554:	f1 04       	cpc	r15, r1
    3556:	b1 f1       	breq	.+108    	; 0x35c4 <strtoul+0x104>
    3558:	80 e1       	ldi	r24, 0x10	; 16
    355a:	e8 16       	cp	r14, r24
    355c:	f1 04       	cpc	r15, r1
    355e:	71 f0       	breq	.+28     	; 0x357c <strtoul+0xbc>
    3560:	e8 e0       	ldi	r30, 0x08	; 8
    3562:	ee 16       	cp	r14, r30
    3564:	f1 04       	cpc	r15, r1
    3566:	f1 f4       	brne	.+60     	; 0x35a4 <strtoul+0xe4>
    3568:	13 c0       	rjmp	.+38     	; 0x3590 <strtoul+0xd0>
    356a:	10 33       	cpi	r17, 0x30	; 48
    356c:	41 f5       	brne	.+80     	; 0x35be <strtoul+0xfe>
    356e:	88 81       	ld	r24, Y
    3570:	8f 7d       	andi	r24, 0xDF	; 223
    3572:	88 35       	cpi	r24, 0x58	; 88
    3574:	49 f7       	brne	.-46     	; 0x3548 <strtoul+0x88>
    3576:	19 81       	ldd	r17, Y+1	; 0x01
    3578:	22 96       	adiw	r28, 0x02	; 2
    357a:	02 60       	ori	r16, 0x02	; 2
    357c:	f0 e1       	ldi	r31, 0x10	; 16
    357e:	ef 2e       	mov	r14, r31
    3580:	f1 2c       	mov	r15, r1
    3582:	88 24       	eor	r8, r8
    3584:	8a 94       	dec	r8
    3586:	98 2c       	mov	r9, r8
    3588:	a8 2c       	mov	r10, r8
    358a:	af e0       	ldi	r26, 0x0F	; 15
    358c:	ba 2e       	mov	r11, r26
    358e:	20 c0       	rjmp	.+64     	; 0x35d0 <strtoul+0x110>
    3590:	78 e0       	ldi	r23, 0x08	; 8
    3592:	e7 2e       	mov	r14, r23
    3594:	f1 2c       	mov	r15, r1
    3596:	88 24       	eor	r8, r8
    3598:	8a 94       	dec	r8
    359a:	98 2c       	mov	r9, r8
    359c:	a8 2c       	mov	r10, r8
    359e:	ef e1       	ldi	r30, 0x1F	; 31
    35a0:	be 2e       	mov	r11, r30
    35a2:	16 c0       	rjmp	.+44     	; 0x35d0 <strtoul+0x110>
    35a4:	6f ef       	ldi	r22, 0xFF	; 255
    35a6:	7f ef       	ldi	r23, 0xFF	; 255
    35a8:	cb 01       	movw	r24, r22
    35aa:	97 01       	movw	r18, r14
    35ac:	0f 2c       	mov	r0, r15
    35ae:	00 0c       	add	r0, r0
    35b0:	44 0b       	sbc	r20, r20
    35b2:	55 0b       	sbc	r21, r21
    35b4:	0e 94 99 1b 	call	0x3732	; 0x3732 <__udivmodsi4>
    35b8:	49 01       	movw	r8, r18
    35ba:	5a 01       	movw	r10, r20
    35bc:	09 c0       	rjmp	.+18     	; 0x35d0 <strtoul+0x110>
    35be:	8a e0       	ldi	r24, 0x0A	; 10
    35c0:	e8 2e       	mov	r14, r24
    35c2:	f1 2c       	mov	r15, r1
    35c4:	69 e9       	ldi	r22, 0x99	; 153
    35c6:	86 2e       	mov	r8, r22
    35c8:	98 2c       	mov	r9, r8
    35ca:	a8 2c       	mov	r10, r8
    35cc:	69 e1       	ldi	r22, 0x19	; 25
    35ce:	b6 2e       	mov	r11, r22
    35d0:	40 e0       	ldi	r20, 0x00	; 0
    35d2:	60 e0       	ldi	r22, 0x00	; 0
    35d4:	70 e0       	ldi	r23, 0x00	; 0
    35d6:	cb 01       	movw	r24, r22
    35d8:	27 01       	movw	r4, r14
    35da:	0f 2c       	mov	r0, r15
    35dc:	00 0c       	add	r0, r0
    35de:	66 08       	sbc	r6, r6
    35e0:	77 08       	sbc	r7, r7
    35e2:	fe 01       	movw	r30, r28
    35e4:	50 ed       	ldi	r21, 0xD0	; 208
    35e6:	35 2e       	mov	r3, r21
    35e8:	31 0e       	add	r3, r17
    35ea:	29 e0       	ldi	r18, 0x09	; 9
    35ec:	23 15       	cp	r18, r3
    35ee:	70 f4       	brcc	.+28     	; 0x360c <strtoul+0x14c>
    35f0:	2f eb       	ldi	r18, 0xBF	; 191
    35f2:	21 0f       	add	r18, r17
    35f4:	2a 31       	cpi	r18, 0x1A	; 26
    35f6:	18 f4       	brcc	.+6      	; 0x35fe <strtoul+0x13e>
    35f8:	39 ec       	ldi	r19, 0xC9	; 201
    35fa:	33 2e       	mov	r3, r19
    35fc:	06 c0       	rjmp	.+12     	; 0x360a <strtoul+0x14a>
    35fe:	2f e9       	ldi	r18, 0x9F	; 159
    3600:	21 0f       	add	r18, r17
    3602:	2a 31       	cpi	r18, 0x1A	; 26
    3604:	30 f5       	brcc	.+76     	; 0x3652 <strtoul+0x192>
    3606:	29 ea       	ldi	r18, 0xA9	; 169
    3608:	32 2e       	mov	r3, r18
    360a:	31 0e       	add	r3, r17
    360c:	23 2d       	mov	r18, r3
    360e:	30 e0       	ldi	r19, 0x00	; 0
    3610:	2e 15       	cp	r18, r14
    3612:	3f 05       	cpc	r19, r15
    3614:	f4 f4       	brge	.+60     	; 0x3652 <strtoul+0x192>
    3616:	4f 3f       	cpi	r20, 0xFF	; 255
    3618:	c9 f0       	breq	.+50     	; 0x364c <strtoul+0x18c>
    361a:	86 16       	cp	r8, r22
    361c:	97 06       	cpc	r9, r23
    361e:	a8 06       	cpc	r10, r24
    3620:	b9 06       	cpc	r11, r25
    3622:	88 f0       	brcs	.+34     	; 0x3646 <strtoul+0x186>
    3624:	a3 01       	movw	r20, r6
    3626:	92 01       	movw	r18, r4
    3628:	0e 94 89 1b 	call	0x3712	; 0x3712 <__mulsi3>
    362c:	23 2d       	mov	r18, r3
    362e:	30 e0       	ldi	r19, 0x00	; 0
    3630:	40 e0       	ldi	r20, 0x00	; 0
    3632:	50 e0       	ldi	r21, 0x00	; 0
    3634:	62 0f       	add	r22, r18
    3636:	73 1f       	adc	r23, r19
    3638:	84 1f       	adc	r24, r20
    363a:	95 1f       	adc	r25, r21
    363c:	62 17       	cp	r22, r18
    363e:	73 07       	cpc	r23, r19
    3640:	84 07       	cpc	r24, r20
    3642:	95 07       	cpc	r25, r21
    3644:	10 f4       	brcc	.+4      	; 0x364a <strtoul+0x18a>
    3646:	4f ef       	ldi	r20, 0xFF	; 255
    3648:	01 c0       	rjmp	.+2      	; 0x364c <strtoul+0x18c>
    364a:	41 e0       	ldi	r20, 0x01	; 1
    364c:	21 96       	adiw	r28, 0x01	; 1
    364e:	10 81       	ld	r17, Z
    3650:	c8 cf       	rjmp	.-112    	; 0x35e2 <strtoul+0x122>
    3652:	c1 14       	cp	r12, r1
    3654:	d1 04       	cpc	r13, r1
    3656:	51 f0       	breq	.+20     	; 0x366c <strtoul+0x1ac>
    3658:	44 23       	and	r20, r20
    365a:	11 f0       	breq	.+4      	; 0x3660 <strtoul+0x1a0>
    365c:	21 97       	sbiw	r28, 0x01	; 1
    365e:	03 c0       	rjmp	.+6      	; 0x3666 <strtoul+0x1a6>
    3660:	01 ff       	sbrs	r16, 1
    3662:	04 c0       	rjmp	.+8      	; 0x366c <strtoul+0x1ac>
    3664:	22 97       	sbiw	r28, 0x02	; 2
    3666:	f6 01       	movw	r30, r12
    3668:	c0 83       	st	Z, r28
    366a:	d1 83       	std	Z+1, r29	; 0x01
    366c:	00 ff       	sbrs	r16, 0
    366e:	07 c0       	rjmp	.+14     	; 0x367e <strtoul+0x1be>
    3670:	90 95       	com	r25
    3672:	80 95       	com	r24
    3674:	70 95       	com	r23
    3676:	61 95       	neg	r22
    3678:	7f 4f       	sbci	r23, 0xFF	; 255
    367a:	8f 4f       	sbci	r24, 0xFF	; 255
    367c:	9f 4f       	sbci	r25, 0xFF	; 255
    367e:	4f 3f       	cpi	r20, 0xFF	; 255
    3680:	79 f4       	brne	.+30     	; 0x36a0 <strtoul+0x1e0>
    3682:	82 e2       	ldi	r24, 0x22	; 34
    3684:	90 e0       	ldi	r25, 0x00	; 0
    3686:	80 93 a5 2c 	sts	0x2CA5, r24	; 0x802ca5 <errno>
    368a:	90 93 a6 2c 	sts	0x2CA6, r25	; 0x802ca6 <errno+0x1>
    368e:	3f ef       	ldi	r19, 0xFF	; 255
    3690:	2f ef       	ldi	r18, 0xFF	; 255
    3692:	9f ef       	ldi	r25, 0xFF	; 255
    3694:	0d c0       	rjmp	.+26     	; 0x36b0 <strtoul+0x1f0>
    3696:	40 e0       	ldi	r20, 0x00	; 0
    3698:	30 e0       	ldi	r19, 0x00	; 0
    369a:	20 e0       	ldi	r18, 0x00	; 0
    369c:	90 e0       	ldi	r25, 0x00	; 0
    369e:	08 c0       	rjmp	.+16     	; 0x36b0 <strtoul+0x1f0>
    36a0:	46 2f       	mov	r20, r22
    36a2:	37 2f       	mov	r19, r23
    36a4:	28 2f       	mov	r18, r24
    36a6:	04 c0       	rjmp	.+8      	; 0x36b0 <strtoul+0x1f0>
    36a8:	10 33       	cpi	r17, 0x30	; 48
    36aa:	09 f0       	breq	.+2      	; 0x36ae <strtoul+0x1ee>
    36ac:	67 cf       	rjmp	.-306    	; 0x357c <strtoul+0xbc>
    36ae:	5f cf       	rjmp	.-322    	; 0x356e <strtoul+0xae>
    36b0:	64 2f       	mov	r22, r20
    36b2:	73 2f       	mov	r23, r19
    36b4:	82 2f       	mov	r24, r18
    36b6:	df 91       	pop	r29
    36b8:	cf 91       	pop	r28
    36ba:	1f 91       	pop	r17
    36bc:	0f 91       	pop	r16
    36be:	ff 90       	pop	r15
    36c0:	ef 90       	pop	r14
    36c2:	df 90       	pop	r13
    36c4:	cf 90       	pop	r12
    36c6:	bf 90       	pop	r11
    36c8:	af 90       	pop	r10
    36ca:	9f 90       	pop	r9
    36cc:	8f 90       	pop	r8
    36ce:	7f 90       	pop	r7
    36d0:	6f 90       	pop	r6
    36d2:	5f 90       	pop	r5
    36d4:	4f 90       	pop	r4
    36d6:	3f 90       	pop	r3
    36d8:	08 95       	ret

000036da <isspace>:
    36da:	91 11       	cpse	r25, r1
    36dc:	0c 94 86 1b 	jmp	0x370c	; 0x370c <__ctype_isfalse>
    36e0:	80 32       	cpi	r24, 0x20	; 32
    36e2:	19 f0       	breq	.+6      	; 0x36ea <isspace+0x10>
    36e4:	89 50       	subi	r24, 0x09	; 9
    36e6:	85 50       	subi	r24, 0x05	; 5
    36e8:	c8 f7       	brcc	.-14     	; 0x36dc <isspace+0x2>
    36ea:	08 95       	ret

000036ec <memcpy>:
    36ec:	fb 01       	movw	r30, r22
    36ee:	dc 01       	movw	r26, r24
    36f0:	02 c0       	rjmp	.+4      	; 0x36f6 <memcpy+0xa>
    36f2:	01 90       	ld	r0, Z+
    36f4:	0d 92       	st	X+, r0
    36f6:	41 50       	subi	r20, 0x01	; 1
    36f8:	50 40       	sbci	r21, 0x00	; 0
    36fa:	d8 f7       	brcc	.-10     	; 0x36f2 <memcpy+0x6>
    36fc:	08 95       	ret

000036fe <memset>:
    36fe:	dc 01       	movw	r26, r24
    3700:	01 c0       	rjmp	.+2      	; 0x3704 <memset+0x6>
    3702:	6d 93       	st	X+, r22
    3704:	41 50       	subi	r20, 0x01	; 1
    3706:	50 40       	sbci	r21, 0x00	; 0
    3708:	e0 f7       	brcc	.-8      	; 0x3702 <memset+0x4>
    370a:	08 95       	ret

0000370c <__ctype_isfalse>:
    370c:	99 27       	eor	r25, r25
    370e:	88 27       	eor	r24, r24

00003710 <__ctype_istrue>:
    3710:	08 95       	ret

00003712 <__mulsi3>:
    3712:	db 01       	movw	r26, r22
    3714:	8f 93       	push	r24
    3716:	9f 93       	push	r25
    3718:	0e 94 bb 1b 	call	0x3776	; 0x3776 <__muluhisi3>
    371c:	bf 91       	pop	r27
    371e:	af 91       	pop	r26
    3720:	a2 9f       	mul	r26, r18
    3722:	80 0d       	add	r24, r0
    3724:	91 1d       	adc	r25, r1
    3726:	a3 9f       	mul	r26, r19
    3728:	90 0d       	add	r25, r0
    372a:	b2 9f       	mul	r27, r18
    372c:	90 0d       	add	r25, r0
    372e:	11 24       	eor	r1, r1
    3730:	08 95       	ret

00003732 <__udivmodsi4>:
    3732:	a1 e2       	ldi	r26, 0x21	; 33
    3734:	1a 2e       	mov	r1, r26
    3736:	aa 1b       	sub	r26, r26
    3738:	bb 1b       	sub	r27, r27
    373a:	fd 01       	movw	r30, r26
    373c:	0d c0       	rjmp	.+26     	; 0x3758 <__udivmodsi4_ep>

0000373e <__udivmodsi4_loop>:
    373e:	aa 1f       	adc	r26, r26
    3740:	bb 1f       	adc	r27, r27
    3742:	ee 1f       	adc	r30, r30
    3744:	ff 1f       	adc	r31, r31
    3746:	a2 17       	cp	r26, r18
    3748:	b3 07       	cpc	r27, r19
    374a:	e4 07       	cpc	r30, r20
    374c:	f5 07       	cpc	r31, r21
    374e:	20 f0       	brcs	.+8      	; 0x3758 <__udivmodsi4_ep>
    3750:	a2 1b       	sub	r26, r18
    3752:	b3 0b       	sbc	r27, r19
    3754:	e4 0b       	sbc	r30, r20
    3756:	f5 0b       	sbc	r31, r21

00003758 <__udivmodsi4_ep>:
    3758:	66 1f       	adc	r22, r22
    375a:	77 1f       	adc	r23, r23
    375c:	88 1f       	adc	r24, r24
    375e:	99 1f       	adc	r25, r25
    3760:	1a 94       	dec	r1
    3762:	69 f7       	brne	.-38     	; 0x373e <__udivmodsi4_loop>
    3764:	60 95       	com	r22
    3766:	70 95       	com	r23
    3768:	80 95       	com	r24
    376a:	90 95       	com	r25
    376c:	9b 01       	movw	r18, r22
    376e:	ac 01       	movw	r20, r24
    3770:	bd 01       	movw	r22, r26
    3772:	cf 01       	movw	r24, r30
    3774:	08 95       	ret

00003776 <__muluhisi3>:
    3776:	0e 94 c6 1b 	call	0x378c	; 0x378c <__umulhisi3>
    377a:	a5 9f       	mul	r26, r21
    377c:	90 0d       	add	r25, r0
    377e:	b4 9f       	mul	r27, r20
    3780:	90 0d       	add	r25, r0
    3782:	a4 9f       	mul	r26, r20
    3784:	80 0d       	add	r24, r0
    3786:	91 1d       	adc	r25, r1
    3788:	11 24       	eor	r1, r1
    378a:	08 95       	ret

0000378c <__umulhisi3>:
    378c:	a2 9f       	mul	r26, r18
    378e:	b0 01       	movw	r22, r0
    3790:	b3 9f       	mul	r27, r19
    3792:	c0 01       	movw	r24, r0
    3794:	a3 9f       	mul	r26, r19
    3796:	70 0d       	add	r23, r0
    3798:	81 1d       	adc	r24, r1
    379a:	11 24       	eor	r1, r1
    379c:	91 1d       	adc	r25, r1
    379e:	b2 9f       	mul	r27, r18
    37a0:	70 0d       	add	r23, r0
    37a2:	81 1d       	adc	r24, r1
    37a4:	11 24       	eor	r1, r1
    37a6:	91 1d       	adc	r25, r1
    37a8:	08 95       	ret

000037aa <_exit>:
    37aa:	f8 94       	cli

000037ac <__stop_program>:
    37ac:	ff cf       	rjmp	.-2      	; 0x37ac <__stop_program>
